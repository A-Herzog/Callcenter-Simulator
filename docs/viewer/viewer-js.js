/*! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.1",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+-new Date,v=a.document,w=0,x=0,y=gb(),z=gb(),A=gb(),B=function(a,b){return a===b&&(l=!0),0},C="undefined",D=1<<31,E={}.hasOwnProperty,F=[],G=F.pop,H=F.push,I=F.push,J=F.slice,K=F.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},L="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",N="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=N.replace("w","w#"),P="\\["+M+"*("+N+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+O+"))|)"+M+"*\\]",Q=":("+N+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+P+")*)|.*)\\)|)",R=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),S=new RegExp("^"+M+"*,"+M+"*"),T=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),V=new RegExp(Q),W=new RegExp("^"+O+"$"),X={ID:new RegExp("^#("+N+")"),CLASS:new RegExp("^\\.("+N+")"),TAG:new RegExp("^("+N.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+Q),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+L+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{I.apply(F=J.call(v.childNodes),v.childNodes),F[v.childNodes.length].nodeType}catch(eb){I={apply:F.length?function(a,b){H.apply(a,J.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],!a||"string"!=typeof a)return d;if(1!==(k=b.nodeType)&&9!==k)return[];if(p&&!e){if(f=_.exec(a))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return I.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return I.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=9===k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+qb(o[l]);w=ab.test(a)&&ob(b.parentNode)||b,x=o.join(",")}if(x)try{return I.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function gb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function hb(a){return a[u]=!0,a}function ib(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function jb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function kb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||D)-(~a.sourceIndex||D);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function lb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function nb(a){return hb(function(b){return b=+b,hb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function ob(a){return a&&typeof a.getElementsByTagName!==C&&a}c=fb.support={},f=fb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fb.setDocument=function(a){var b,e=a?a.ownerDocument||a:v,g=e.defaultView;return e!==n&&9===e.nodeType&&e.documentElement?(n=e,o=e.documentElement,p=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){m()},!1):g.attachEvent&&g.attachEvent("onunload",function(){m()})),c.attributes=ib(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ib(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(e.getElementsByClassName)&&ib(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=ib(function(a){return o.appendChild(a).id=u,!e.getElementsByName||!e.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==C&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c=typeof a.getAttributeNode!==C&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==C?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==C&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(e.querySelectorAll))&&(ib(function(a){a.innerHTML="<select msallowclip=''><option selected=''></option></select>",a.querySelectorAll("[msallowclip^='']").length&&q.push("[*^$]="+M+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+M+"*(?:value|"+L+")"),a.querySelectorAll(":checked").length||q.push(":checked")}),ib(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+M+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ib(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",Q)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===v&&t(v,a)?-1:b===e||b.ownerDocument===v&&t(v,b)?1:k?K.call(k,a)-K.call(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],i=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:k?K.call(k,a)-K.call(k,b):0;if(f===g)return kb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?kb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},e):n},fb.matches=function(a,b){return fb(a,null,null,b)},fb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fb(b,n,null,[a]).length>0},fb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&E.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fb.selectors={cacheLength:50,createPseudo:hb,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+M+")"+a+"("+M+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==C&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?hb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=K.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:hb(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?hb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:hb(function(a){return function(b){return fb(a,b).length>0}}),contains:hb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:hb(function(a){return W.test(a||"")||fb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:nb(function(){return[0]}),last:nb(function(a,b){return[b-1]}),eq:nb(function(a,b,c){return[0>c?c+b:c]}),even:nb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:nb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:nb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:nb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=lb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=mb(b);function pb(){}pb.prototype=d.filters=d.pseudos,d.setFilters=new pb,g=fb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fb.error(a):z(a,i).slice(0)};function qb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function rb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function sb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function tb(a,b,c){for(var d=0,e=b.length;e>d;d++)fb(a,b[d],c);return c}function ub(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function vb(a,b,c,d,e,f){return d&&!d[u]&&(d=vb(d)),e&&!e[u]&&(e=vb(e,f)),hb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||tb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ub(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ub(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?K.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ub(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):I.apply(g,r)})}function wb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=rb(function(a){return a===b},h,!0),l=rb(function(a){return K.call(b,a)>-1},h,!0),m=[function(a,c,d){return!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>i;i++)if(c=d.relative[a[i].type])m=[rb(sb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return vb(i>1&&sb(m),i>1&&qb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&wb(a.slice(i,e)),f>e&&wb(a=a.slice(e)),f>e&&qb(a))}m.push(c)}return sb(m)}function xb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=G.call(i));s=ub(s)}I.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&fb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?hb(f):f}return h=fb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xb(e,d)),f.selector=a}return f},i=fb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&ob(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qb(j),!a)return I.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&ob(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ib(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ib(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||jb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ib(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||jb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ib(function(a){return null==a.getAttribute("disabled")})||jb(L,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fb}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+Math.random()}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)
},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(ob(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(ob(c,"script"),kb),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(hb,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function tb(a){var b=l,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:"0",fontWeight:"400"},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?zb.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=yb(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(n.cssHooks[a+b].set=Gb)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}n.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Kb.prototype.init,n.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=n.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||tb(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?tb(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ub(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return n.map(k,Ub,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xb,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xb(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),n.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Lb=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Lb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Mb||(Mb=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Mb),Mb=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Yb,Zb,$b=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))
},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||n.find.attr;$b[b]=function(a,b,d){var e,f;return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=n.now(),dc=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var ec,fc,gc=/#.*$/,hc=/([?&])_=[^&]*/,ic=/^(.*?):[ \t]*([^\r\n]*)$/gm,jc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,kc=/^(?:GET|HEAD)$/,lc=/^\/\//,mc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,nc={},oc={},pc="*/".concat("*");try{fc=location.href}catch(qc){fc=l.createElement("a"),fc.href="",fc=fc.href}ec=mc.exec(fc.toLowerCase())||[];function rc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function sc(a,b,c,d){var e={},f=a===oc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function tc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function uc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function vc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:fc,type:"GET",isLocal:jc.test(ec[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":pc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?tc(tc(a,n.ajaxSettings),b):tc(n.ajaxSettings,a)},ajaxPrefilter:rc(nc),ajaxTransport:rc(oc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=ic.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||fc)+"").replace(gc,"").replace(lc,ec[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=mc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===ec[1]&&h[2]===ec[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(ec[3]||("http:"===ec[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),sc(nc,k,b,v),2===t)return v;i=k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!kc.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=hc.test(d)?d.replace(hc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+pc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=sc(oc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=uc(k,v,f)),u=vc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var wc=/%20/g,xc=/\[\]$/,yc=/\r?\n/g,zc=/^(?:submit|button|image|reset|file)$/i,Ac=/^(?:input|select|textarea|keygen)/i;function Bc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||xc.test(a)?d(a,e):Bc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Bc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Bc(c,a[c],b,e);return d.join("&").replace(wc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Ac.test(this.nodeName)&&!zc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(yc,"\r\n")}}):{name:b.name,value:c.replace(yc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Cc=0,Dc={},Ec={0:200,1223:204},Fc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on("unload",function(){for(var a in Dc)Dc[a]()}),k.cors=!!Fc&&"withCredentials"in Fc,k.ajax=Fc=!!Fc,n.ajaxTransport(function(a){var b;return k.cors||Fc&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Cc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Dc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Ec[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Dc[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Gc=[],Hc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Gc.pop()||n.expando+"_"+cc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Hc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Hc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Hc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Gc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Ic=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Ic)return Ic.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Jc=a.document.documentElement;function Kc(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Kc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Jc;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Jc})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Kc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=yb(k.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Lc=a.jQuery,Mc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Mc),b&&a.jQuery===n&&(a.jQuery=Lc),n},typeof b===U&&(a.jQuery=a.$=n),n});

/*
 ### jQuery XML to JSON Plugin v1.3 - 2013-02-18 ###
 * http://www.fyneworks.com/ - diego@fyneworks.com
	* Licensed under http://en.wikipedia.org/wiki/MIT_License
 ###
 Website: http://www.fyneworks.com/jquery/xml-to-json/
*//*
 # INSPIRED BY: http://www.terracoder.com/
           AND: http://www.thomasfrank.se/xml_to_json.html
											AND: http://www.kawa.net/works/js/xml/objtree-e.html
*//*
 This simple script converts XML (document of code) into a JSON object. It is the combination of 2
 'xml to json' great parsers (see below) which allows for both 'simple' and 'extended' parsing modes.
*/
// Avoid collisions
;if(window.jQuery) (function($){
 
 // Add function to jQuery namespace
 $.extend({
  
  // converts xml documents and xml text to json object
  xml2json: function(xml, extended) {
   if(!xml) return {}; // quick fail
   
   //### PARSER LIBRARY
   // Core function
   function parseXML(node, simple){
    if(!node) return null;
    var txt = '', obj = null, att = null;
    var nt = node.nodeType, nn = jsVar(node.localName || node.nodeName);
    var nv = node.text || node.nodeValue || '';
    /*DBG*/ //if(window.console) console.log(['x2j',nn,nt,nv.length+' bytes']);
    if(node.childNodes){
     if(node.childNodes.length>0){
      /*DBG*/ //if(window.console) console.log(['x2j',nn,'CHILDREN',node.childNodes]);
      $.each(node.childNodes, function(n,cn){
       var cnt = cn.nodeType, cnn = jsVar(cn.localName || cn.nodeName);
       var cnv = cn.text || cn.nodeValue || '';
       /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>a',cnn,cnt,cnv]);
       if(cnt == 8){
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>b',cnn,'COMMENT (ignore)']);
        return; // ignore comment node
       }
       else if(cnt == 3 || cnt == 4 || !cnn){
        // ignore white-space in between tags
        if(cnv.match(/^\s+$/)){
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>c',cnn,'WHITE-SPACE (ignore)']);
         return;
        };
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>d',cnn,'TEXT']);
        txt += cnv.replace(/^\s+/,'').replace(/\s+$/,'');
								// make sure we ditch trailing spaces from markup
       }
       else{
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>e',cnn,'OBJECT']);
        obj = obj || {};
        if(obj[cnn]){
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>f',cnn,'ARRAY']);
         
									// http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
									if(!obj[cnn].length) obj[cnn] = myArr(obj[cnn]);
									obj[cnn] = myArr(obj[cnn]);
         
									obj[cnn][ obj[cnn].length ] = parseXML(cn, true/* simple */);
         obj[cnn].length = obj[cnn].length;
        }
        else{
         /*DBG*/ //if(window.console) console.log(['x2j',nn,'node>g',cnn,'dig deeper...']);
         obj[cnn] = parseXML(cn);
        };
       };
      });
     };//node.childNodes.length>0
    };//node.childNodes
    if(node.attributes){
     if(node.attributes.length>0){
      /*DBG*/ //if(window.console) console.log(['x2j',nn,'ATTRIBUTES',node.attributes])
      att = {}; obj = obj || {};
      $.each(node.attributes, function(a,at){
       var atn = jsVar(at.name), atv = at.value;
       att[atn] = atv;
       if(obj[atn]){
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'ARRAY']);
        
								// http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
								//if(!obj[atn].length) obj[atn] = myArr(obj[atn]);//[ obj[ atn ] ];
        obj[cnn] = myArr(obj[cnn]);
								
								obj[atn][ obj[atn].length ] = atv;
        obj[atn].length = obj[atn].length;
       }
       else{
        /*DBG*/ //if(window.console) console.log(['x2j',nn,'attr>',atn,'TEXT']);
        obj[atn] = atv;
       };
      });
      //obj['attributes'] = att;
     };//node.attributes.length>0
    };//node.attributes
    if(obj){
     obj = $.extend( (txt!='' ? new String(txt) : {}),/* {text:txt},*/ obj || {}/*, att || {}*/);
     //txt = (obj.text) ? (typeof(obj.text)=='object' ? obj.text : [obj.text || '']).concat([txt]) : txt;
     txt = (obj.text) ? ([obj.text || '']).concat([txt]) : txt;
     if(txt) obj.text = txt;
     txt = '';
    };
    var out = obj || txt;
    //console.log([extended, simple, out]);
    if(extended){
     if(txt) out = {};//new String(out);
     txt = out.text || txt || '';
     if(txt) out.text = txt;
     if(!simple) out = myArr(out);
    };
    return out;
   };// parseXML
   // Core Function End
   // Utility functions
   var jsVar = function(s){ return String(s || '').replace(/-/g,"_"); };
   
			// NEW isNum function: 01/09/2010
			// Thanks to Emile Grau, GigaTecnologies S.L., www.gigatransfer.com, www.mygigamail.com
			function isNum(s){
				// based on utility function isNum from xml2json plugin (http://www.fyneworks.com/ - diego@fyneworks.com)
				// few bugs corrected from original function :
				// - syntax error : regexp.test(string) instead of string.test(reg)
				// - regexp modified to accept  comma as decimal mark (latin syntax : 25,24 )
				// - regexp modified to reject if no number before decimal mark  : ".7" is not accepted
				// - string is "trimmed", allowing to accept space at the beginning and end of string
				var regexp=/^((-)?([0-9]+)(([\.\,]{0,1})([0-9]+))?$)/
				return (typeof s == "number") || regexp.test(String((s && typeof s == "string") ? jQuery.trim(s) : ''));
			};
			// OLD isNum function: (for reference only)
			//var isNum = function(s){ return (typeof s == "number") || String((s && typeof s == "string") ? s : '').test(/^((-)?([0-9]*)((\.{0,1})([0-9]+))?$)/); };
																
   var myArr = function(o){
    
				// http://forum.jquery.com/topic/jquery-jquery-xml2json-problems-when-siblings-of-the-same-tagname-only-have-a-textnode-as-a-child
				//if(!o.length) o = [ o ]; o.length=o.length;
    if(!$.isArray(o)) o = [ o ]; o.length=o.length;
				
				// here is where you can attach additional functionality, such as searching and sorting...
    return o;
   };
   // Utility functions End
   //### PARSER LIBRARY END
   
   // Convert plain text to xml
   if(typeof xml=='string') xml = $.text2xml(xml);
   
   // Quick fail if not xml (or if this is a node)
   if(!xml.nodeType) return;
   if(xml.nodeType == 3 || xml.nodeType == 4) return xml.nodeValue;
   
   // Find xml root node
   var root = (xml.nodeType == 9) ? xml.documentElement : xml;
   
   // Convert xml to json
   var out = parseXML(root, true /* simple */);
   
   // Clean-up memory
   xml = null; root = null;
   
   // Send output
   return out;
  },
  
  // Convert text to XML DOM
  text2xml: function(str) {
   // NOTE: I'd like to use jQuery for this, but jQuery makes all tags uppercase
   //return $(xml)[0];
   
   /* prior to jquery 1.9 */
   /*
   var out;
   try{
    var xml = ((!$.support.opacity && !$.support.style))?new ActiveXObject("Microsoft.XMLDOM"):new DOMParser();
    xml.async = false;
   }catch(e){ throw new Error("XML Parser could not be instantiated") };
   try{
    if((!$.support.opacity && !$.support.style)) out = (xml.loadXML(str))?xml:false;
    else out = xml.parseFromString(str, "text/xml");
   }catch(e){ throw new Error("Error parsing XML string") };
   return out;
   */

   /* jquery 1.9+ */
   return $.parseXML(str);
  }
		
 }); // extend $

})(jQuery);


/*
 * aciPlugin little jQuery plugin helper v1.5.1
 * http://acoderinsights.ro
 *
 * Copyright (c) 2013 Dragos Ursu
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Require jQuery Library >= v1.2.3 http://jquery.com
 */

(function(d,c,e){if(typeof aciPluginClass!=="undefined"){return}var a;this.aciPluginClass=function(){};aciPluginClass.extend=function(g,j){i.extend=arguments.callee;function i(){if(a){this._instance={};return this.__construct.apply(this,arguments)}}a=false;i.prototype=new this();a=true;var h=this.prototype;for(var f in g){i.prototype[f]=((typeof g[f]=="function")&&(f!="proxy"))?(function(k){return function(){var p=this._parent;this._parent=h;var n=this._super;this._super=h[k];var o=this._private;if(this._instance&&j){var m=this._instance._private;if(m[j]===e){m[j]={nameSpace:"."+j}}this._private=m[j]}var l=g[k].apply(this,arguments);this._parent=p;this._super=n;this._private=o;return l}})(f):g[f]}return i};var b=0;aciPluginClass.aciPluginUi=aciPluginClass.extend({__construct:function(k,l,i,h,j){var f="."+k;var g=l.data(f);if(g){this._instance=g._instance;return g.__request(i,h,j)}l.data(f,this);d.extend(true,this._instance,{_private:{},nameSpace:f,jQuery:l,options:d.extend(true,{},d.fn[k].defaults,(typeof i=="object")?i:{}),index:b++,wasInit:false});this.__extend();return this.__request(i,h,j)},__extend:function(){},__request:function(g,f,h){if((g===e)||(typeof g=="object")){if(this._instance.options.autoInit){this.init()}}else{if(typeof g=="string"){switch(g){case"init":this.init();break;case"api":return{object:this};case"options":if(f===e){return{object:this.options()}}else{if(typeof f=="string"){return{object:this.options(f)}}else{this.options(f)}}break;case"option":this.option(f,h);break;case"destroy":this.destroy();break}}}return this._instance.jQuery},proxy:function(j,h){var m=c.Array.prototype.slice;var f=m.call(arguments,2);var i=this,g=i._parent,l=i._super,k=i._private;return function(){i._parent=g;i._super=l;i._private=k;return j.apply(i,h?f.concat([this],m.call(arguments)):f.concat(m.call(arguments)))}},init:function(){if(!this._instance.wasInit){this._instance.wasInit=true;return true}return false},wasInit:function(){return this._instance.wasInit},__parent:function(h,f,l){var m=f.split(".");if(m.length>1){var j=h,k;for(var g in m){k=j;j=j[m[g]]}l.name=m[g];return k}l.name=f;return h},options:function(f){if(f){var i={name:null};var h;if(typeof f=="string"){h=this.__parent(this._instance.options,f,i);return h[i.name]}else{for(var g in f){h=this.__parent(this._instance.options,g,i);h[i.name]=f[g]}}}else{return this._instance.options}},option:function(g,i){var h={name:null};var f=this.__parent(this._instance.options,g,h);f[h.name]=i},destroy:function(){if(this._instance.wasInit){this._instance.wasInit=false;this._instance.jQuery.removeData(this._instance.nameSpace);return true}return false}});aciPluginClass.plugins={};aciPluginClass.publish=function(f,g){d.fn[f]=function(j,m,n){var h=null;for(var l=0,k=this.length;l<k;l++){h=new aciPluginClass.plugins[f](f,d(this[l]),j,m,n);if(!(h instanceof d)){return h.object}}return this};d.fn[f].defaults=d.extend(true,{autoInit:true},(typeof g=="object")?g:{})};aciPluginClass.defaults=function(f,g){d.extend(true,d.fn[f].defaults,(typeof g=="object")?g:{})}})(jQuery,this);


/*
 * aciTree jQuery Plugin v4.5.0-rc.6
 * http://acoderinsights.ro
 *
 * Copyright (c) 2014 Dragos Ursu
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Require jQuery Library >= v1.9.0 http://jquery.com
 * + aciPlugin >= v1.5.1 https://github.com/dragosu/jquery-aciPlugin
 */

// DOM
aciPluginClass.plugins.aciTree_dom={container:function(b){var a=b.lastChild;if(a&&(a.nodeName=="UL")){return a}return null},firstChild:function(b,d){var a=this.container(b);if(a){var c=a.firstChild;if(d){while(c&&!d.call(this,c)){c=c.nextSibling}}return c}return null},lastChild:function(c,d){var a=this.container(c);if(a){var b=a.lastChild;if(d){while(b&&!d.call(this,b)){b=b.previousSibling}}return b}return null},prev:function(b,c){var a=b.previousSibling;if(c){while(a&&!c.call(this,a)){a=a.previousSibling}}return a},next:function(b,c){var a=b.nextSibling;if(c){while(a&&!c.call(this,a)){a=a.nextSibling}}return a},prevAll:function(f,h){var e,d,g,a,c,b;while(true){e=this.prev(f);if(e){if(h){a=h.call(this,e);if(a===null){f=e;continue}}d=this.lastChild(e);if(d){if(h&&(h.call(this,d)===null)){f=d;continue}c=false;while(g=this.lastChild(d)){d=g;if(h){a=h.call(this,d);if(a===null){f=d;c=true;break}}}if(c){continue}if(h){a=h.call(this,d);if(a){return d}else{if(a!==null){f=d;continue}}}else{return d}}else{if(!h||a){return e}else{f=e;continue}}}b=this.parent(f);if(b){if(h){a=h.call(this,b);if(a){return b}else{f=b}}else{return b}}else{return null}}return null},nextAll:function(d,g){var e,a,c,b,f;while(true){e=this.firstChild(d);if(e){if(g){a=g.call(this,e);if(a){return e}else{d=e;if(a!==null){continue}}}else{return e}}while(true){c=this.next(d);if(c){if(g){a=g.call(this,c);if(a){return c}else{d=c;if(a!==null){break}else{continue}}}else{return c}}else{b=d;f=null;while(b=this.parent(b)){c=this.next(b);if(c){if(g){a=g.call(this,c);if(a){return c}else{d=c;if(a!==null){f=true}else{f=false}break}}else{return c}}}if(f!==null){if(f){break}else{continue}}return null}}}return null},first:function(b,d){var a=this.container(b);if(a){var c=a.firstChild;if(c){if(d&&!d.call(this,c)){return this.nextAll(c,d)}return c}}return null},last:function(c,e){var a=this.container(c);if(a){var b=a.lastChild;if(b){if(e&&(e.call(this,b)===null)){return this.prevAll(b,e)}else{var d;while(d=this.lastChild(b)){b=d}if(e&&!e.call(this,b)){return this.prevAll(b,e)}return b}}}return null},children:function(b,f,h){var a=[],i=[],d,c,g;var e=this.firstChild(b);if(e){while(true){g=false;do{if(h){d=h.call(this,e);if(d){a.push(e)}if(f&&(d!==null)){c=this.firstChild(e);if(c){i.push(e);e=c;g=true;break}}}else{a.push(e);if(f){c=this.firstChild(e);if(c){i.push(e);e=c;g=true;break}}}}while(e=e.nextSibling);if(!g){while(e=i.pop()){e=e.nextSibling;if(e){break}}if(!e){break}}}}return a},childrenTill:function(d,g){var e=[],a,b,c;var f=d.firstChild;if(f){while(true){c=false;do{a=g.call(this,f);if(a){return f}else{if(a===null){return null}}b=f.firstChild;if(b){e.push(f);f=b;c=true;break}}while(f=f.nextSibling);if(!c){while(f=e.pop()){f=f.nextSibling;if(f){break}}if(!f){break}}}}return null},childrenByClass:function(b,a){if(b.getElementsByClassName){var c=b.getElementsByClassName(a instanceof Array?a.join(" "):a);return c?c[0]:null}else{return this.childrenTill(b,function(d){return this.hasClass(d,a)})}},parent:function(b){var a=b.parentNode.parentNode;if(a&&(a.nodeName=="LI")){return a}return null},parentFrom:function(a){while(a.nodeName!="LI"){a=a.parentNode;if(!a){return null}}return a},parentTill:function(b,c){var a;while(b=b.parentNode){a=c.call(this,b);if(a){return b}else{if(a===null){return null}}}return null},parentByClass:function(b,a){return this.parentTill(b,function(c){return this.hasClass(c,a)})},hasClass:function(e,d,a){var b=" "+e.className+" ";if(a instanceof Array){for(var c=0;c<a.length;c++){if(b.indexOf(" "+a[c]+" ")!=-1){return false}}}else{if(a&&b.indexOf(" "+a+" ")!=-1){return false}}if(d instanceof Array){for(var c=0;c<d.length;c++){if(b.indexOf(" "+d[c]+" ")==-1){return false}}}else{if(d&&b.indexOf(" "+d+" ")==-1){return false}}return true},withClass:function(b,e,a){var d=[];for(var c=0;c<b.length;c++){if(this.hasClass(b[c],e,a)){d.push(b[c])}}return d},hasAnyClass:function(e,d,a){var b=" "+e.className+" ";if(a instanceof Array){for(var c=0;c<a.length;c++){if(b.indexOf(" "+a[c]+" ")!=-1){return false}}}else{if(a&&b.indexOf(" "+a+" ")!=-1){return false}}if(d instanceof Array){for(var c=0;c<d.length;c++){if(b.indexOf(" "+d[c]+" ")!=-1){return true}}}else{if(d&&b.indexOf(" "+d+" ")!=-1){return true}}return false},withAnyClass:function(b,e,a){var d=[];for(var c=0;c<b.length;c++){if(this.hasAnyClass(b[c],e,a)){d.push(b[c])}}return d},addClass:function(e,d){var b=" "+e.className+" ",a="";if(d instanceof Array){for(var c=0;c<d.length;c++){if(b.indexOf(" "+d[c]+" ")==-1){a+=" "+d[c]}}}else{if(b.indexOf(" "+d+" ")==-1){a+=" "+d}}if(a){e.className=e.className+a;return true}return false},addListClass:function(a,c,d){for(var b=0;b<a.length;b++){this.addClass(a[b],c);if(d){d.call(this,a[b])}}},removeClass:function(d,c){var a=" "+d.className+" ";if(c instanceof Array){for(var b=0;b<c.length;b++){a=a.replace(" "+c[b]+" "," ")}}else{a=a.replace(" "+c+" "," ")}a=a.substr(1,a.length-2);if(d.className!=a){d.className=a;return true}return false},removeListClass:function(a,c,d){for(var b=0;b<a.length;b++){this.removeClass(a[b],c);if(d){d.call(this,a[b])}}},toggleClass:function(b,a,c){if(c){return this.addClass(b,a)}else{return this.removeClass(b,a)}},toggleListClass:function(a,c,d,e){for(var b=0;b<a.length;b++){this.toggleClass(a[b],c,d);if(e){e.call(this,a[b])}}},addRemoveClass:function(d,e,f){var b=" "+d.className+" ";if(f){if(f instanceof Array){for(var c=0;c<f.length;c++){b=b.replace(" "+f[c]+" "," ")}}else{b=b.replace(" "+f+" "," ")}}if(e){var a="";if(e instanceof Array){for(var c=0;c<e.length;c++){if(b.indexOf(" "+e[c]+" ")==-1){a+=e[c]+" "}}}else{if(b.indexOf(" "+e+" ")==-1){a+=e+" "}}b+=a}b=b.substr(1,b.length-2);if(d.className!=b){d.className=b;return true}return false},addRemoveListClass:function(a,c,d,e){for(var b=0;b<a.length;b++){this.addRemoveClass(a[b],c,d);if(e){e.call(this,a[b])}}}};

// core
(function(d,c,f){var b={ajax:{url:null,dataType:"json"},dataSource:null,rootData:null,queue:{async:4,interval:50,delay:20},loaderDelay:500,expand:false,collapse:false,unique:false,empty:false,show:{props:{height:"show"},duration:"medium",easing:"linear"},animateRoot:true,hide:{props:{height:"hide"},duration:"medium",easing:"linear"},view:{duration:"medium",easing:"linear"},ajaxHook:function(h,g){g.url+=(h?this.getId(h):"")},itemHook:function(h,i,g,j){},serialize:function(g,i,h){if(typeof i=="object"){return h}else{return"|"+h}}};var e={__extend:function(){d.extend(this._instance,{queue:new this._queue(this,this._instance.options.queue)});d.extend(this._private,{locked:false,itemClone:{},loaderHide:null,loaderInterval:null,delayBusy:0})},init:function(h){h=this._options(h);if(this.wasInit()){this._trigger(null,"wasinit",h);this._fail(null,h);return}if(this.isLocked()){this._trigger(null,"locked",h);this._fail(null,h);return}if(!this._trigger(null,"beforeinit",h)){this._trigger(null,"initfail",h);this._fail(null,h);return}this._private.locked=true;this._instance.jQuery.addClass("aciTree"+this._instance.index).attr("role","tree").on("click"+this._instance.nameSpace,".aciTreeButton",this.proxy(function(k){var j=this.itemFrom(k.target);if(!this.isBusy(j)){this.toggle(j,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique})}})).on("mouseenter"+this._instance.nameSpace+" mouseleave"+this._instance.nameSpace,".aciTreePush",function(k){var j=k.target;if(!a.hasClass(j,"aciTreePush")){j=a.parentByClass(j,"aciTreePush")}a.toggleClass(j,"aciTreeHover",k.type=="mouseenter")}).on("mouseenter"+this._instance.nameSpace+" mouseleave"+this._instance.nameSpace,".aciTreeLine",function(k){var j=k.target;if(!a.hasClass(j,"aciTreeLine")){j=a.parentByClass(j,"aciTreeLine")}a.toggleClass(j,"aciTreeHover",k.type=="mouseenter")});this._initHook();var i=this.proxy(function(){this._super();this._private.locked=false;this._trigger(null,"init",h);this._success(null,h)});var g=this.proxy(function(){this._super();this._private.locked=false;this._trigger(null,"initfail",h);this._fail(null,h)});if(this._instance.options.rootData){this.loadFrom(null,this._inner(h,{success:i,fail:g,itemData:this._instance.options.rootData}))}else{if(this._instance.options.ajax.url){this.ajaxLoad(null,this._inner(h,{success:i,fail:g}))}else{i.apply(this)}}},_initHook:function(){},isLocked:function(){return this._private.locked},_format:function(p,h){if(!(h instanceof Array)){return p}var j=p.split(/(%[0-9]+)/gm);var q="",g,l,o=false,m;var n=new c.RegExp("^%[0-9]+$");for(var k=0;k<j.length;k++){g=j[k];m=g.length;if(m){if(!o&&n.test(g)){l=c.parseInt(g.substr(1))-1;if((l>=0)&&(l<h.length)){q+=h[l];continue}}else{o=false;if(g.substr(m-1)=="%"){if(g.substr(m-2)!="%%"){o=true}g=g.substr(0,m-1)}}q+=g}}return q},_coreDOM:{leaf:function(g){a.addRemoveListClass(g.toArray(),"aciTreeLeaf",["aciTreeInode","aciTreeInodeMaybe","aciTreeOpen"],function(h){h.firstChild.removeAttribute("aria-expanded")})},inode:function(g,h){a.addRemoveListClass(g.toArray(),h?"aciTreeInode":"aciTreeInodeMaybe","aciTreeLeaf",function(i){i.firstChild.setAttribute("aria-expanded",false)})},toggle:function(g,h){a.toggleListClass(g.toArray(),"aciTreeOpen",h,function(i){i.firstChild.setAttribute("aria-expanded",h)})},oddEven:function(g,k){var j=g.toArray();for(var h=0;h<j.length;h++){a.addRemoveClass(j[h],k?"aciTreeOdd":"aciTreeEven",k?"aciTreeEven":"aciTreeOdd");k=!k}}},_queue:function(i,s){var l=false;var r=[],q=[];var p=0,h=0,m=0,o=0;var k=function(){if(l){o--;return}var t=new c.Date().getTime();if(m>t){o--;return}var v,u=false;if(p<s.async*2){v=r.shift()}if(!v&&(h<s.async)){v=q.shift();u=true}if(v){if(u){h++;v.call(i,function(){h--});if(o<40){o++;k()}}else{p++;v.call(i,function(){if(t-m>s.interval){m=t+s.delay}p--;if(o<40){o++;k()}})}}o--};var j=[];var g=function(){for(var t=0;t<4;t++){j[t]=c.setInterval(function(){if(o<20){o++;k()}},10)}};var n=function(){for(var t=0;t<j.length;t++){c.clearInterval(j[t])}};g();this.init=function(){this.destroy();g();return this};this.push=function(u,t){if(!l){if(t){q.push(u)}else{r.push(u)}}return this};this.busy=function(){return(p!=0)||(h!=0)||(r.length!=0)||(q.length!=0)};this.destroy=function(){l=true;n();r=[];q=[];p=0;h=0;m=0;o=0;l=false;return this}},_task:function(g,j){var h=0,i=false;this.push=function(l,k){h++;g.push(function(m){var n=this;l.call(this,function(){h--;if((h<1)&&!i){i=true;j.call(n,m)}else{m()}})},k)}},_options:function(h,j,n,i,m){var o=d.extend({uid:"ui",success:null,fail:null,notify:null,expand:this._instance.options.expand,collapse:this._instance.options.collapse,unique:this._instance.options.unique,unanimated:false,itemData:{}},h);var l=j?((typeof j=="string")?function(){this._trigger(m,j,o)}:j):null;var g=n?((typeof n=="string")?function(){this._trigger(m,n,o)}:n):null;var k=i?((typeof i=="string")?function(){this._trigger(m,i,o)}:i):null;if(l){if(h&&h.success){o.success=function(){l.apply(this,arguments);h.success.apply(this,arguments)}}else{o.success=l}}if(g){if(h&&h.fail){o.fail=function(){g.apply(this,arguments);h.fail.apply(this,arguments)}}else{o.fail=g}}if(k){if(h&&h.notify){o.notify=function(){k.apply(this,arguments);h.notify.apply(this,arguments)}}else{if(!o.notify&&h&&h.success){o.notify=function(){k.apply(this,arguments);h.success.apply(this,arguments)}}else{o.notify=k}}}else{if(!o.notify&&h&&h.success){o.notify=h.success}}return o},_inner:function(g,h){return d.extend({},g,{success:null,fail:null,notify:null},h)},_trigger:function(j,g,h){var i=d.Event("acitree");if(!h){h=this._options()}this._instance.jQuery.trigger(i,[this,j,g,h]);return !i.isDefaultPrevented()},_success:function(h,g){if(g&&g.success){g.success.call(this,h,g)}},_fail:function(h,g){if(g&&g.fail){g.fail.call(this,h,g)}},_notify:function(h,g){if(g&&g.notify){g.notify.call(this,h,g)}},_delayBusy:function(g,h){if((this._private.delayBusy<10)&&this.isBusy(g)){this._private.delayBusy++;c.setTimeout(this.proxy(function(){this._delayBusy.call(this,g,h);this._private.delayBusy--}),10);return}h.apply(this)},_dataSource:function(h){var j=this._instance.options.dataSource;if(j){var i=this.itemData(h);if(i&&i.source&&j[i.source]){return j[i.source]}var g;do{g=this.parent(h);i=this.itemData(g);if(i&&i.source&&j[i.source]){return j[i.source]}}while(g.length)}return this._instance.options.ajax},ajaxLoad:function(h,g){if(h&&this.isBusy(h)){this._delayBusy(h,function(){this.ajaxLoad(h,g)});return}g=this._options(g,function(){this._loading(h);this._trigger(h,"loaded",g)},function(){this._loading(h);this._trigger(h,"loadfail",g)},function(){this._loading(h);this._trigger(h,"wasloaded",g)});if(!h||this.isInode(h)){this._instance.queue.push(function(i){if(!this._trigger(h,"beforeload",g)){this._fail(h,g);i();return}this._loading(h,true);if(this.wasLoad(h)){this._notify(h,g);i();return}var j=d.extend({},this._dataSource(h));this._instance.options.ajaxHook.call(this,h,j);j.success=this.proxy(function(k){if(k&&(k instanceof Array)&&k.length){var l=function(){if(this.wasLoad(h)){this._notify(h,g);i()}else{this._createBranch(h,this._inner(g,{success:function(){this._success(h,g);i()},fail:function(){this._fail(h,g);i()},itemData:k}))}};if(!h||this.isInode(h)){l.apply(this)}else{this.setInode(h,this._inner(g,{success:l,fail:g.fail}))}}else{var l=function(){this._fail(h,g);i()};if(!h||this.isLeaf(h)){l.apply(this)}else{this.setLeaf(h,this._inner(g,{success:l,fail:l}))}}});j.error=this.proxy(function(){this._fail(h,g);i()});d.ajax(j)},true)}else{this._fail(h,g)}},loadFrom:function(h,g){if(h&&this.isBusy(h)){this._delayBusy(h,function(){this.loadFrom(h,g)});return}g=this._options(g,function(){this._loading(h);this._trigger(h,"loaded",g)},function(){this._loading(h);this._trigger(h,"loadfail",g)},function(){this._loading(h);this._trigger(h,"wasloaded",g)});if(!h||this.isInode(h)){if(!this._trigger(h,"beforeload",g)){this._fail(h,g);return}this._loading(h,true);if(this.wasLoad(h)){this._notify(h,g);return}if(g.itemData&&(g.itemData instanceof Array)&&g.itemData.length){var i=function(){if(this.wasLoad(h)){this._notify(h,g)}else{this._createBranch(h,g)}};if(!h||this.isInode(h)){i.apply(this)}else{this.setInode(h,this._inner(g,{success:i,fail:g.fail}))}}else{if(!h||this.isLeaf(h)){this._fail(h,g)}else{this.setLeaf(h,this._inner(g,{success:g.fail,fail:g.fail}))}}}else{this._fail(h,g)}},unload:function(j,g){g=this._options(g,function(){this._loading(j);this._trigger(j,"unloaded",g)},function(){this._loading(j);this._trigger(j,"unloadfail",g)},function(){this._loading(j);this._trigger(j,"notloaded",g)});if(!j||this.isInode(j)){if(!this._trigger(j,"beforeunload",g)){this._fail(j,g);return}this._loading(j,true);if(!this.wasLoad(j)){this._notify(j,g);return}var i=false;var h=this.children(j,true,true);h.each(this.proxy(function(l){var m=d(l);if(this.isInode(m)){if(this.isOpen(m)){if(!this._trigger(m,"beforeclose",g)){i=true;return false}}if(this.wasLoad(m)){if(!this._trigger(m,"beforeunload",g)){i=true;return false}}}if(!this._trigger(m,"beforeremove",g)){i=true;return false}},true));if(i){this._fail(j,g);return}var k=function(){h.each(this.proxy(function(l){var m=d(l);if(this.isInode(m)){if(this.isOpen(m)){this._trigger(m,"closed",g)}if(this.wasLoad(m)){this._trigger(m,"unloaded",g)}}this._trigger(m,"removed",g)},true))};if(j){if(this.isOpen(j)){this.close(j,this._inner(g,{success:function(){k.call(this);this._removeContainer(j);this._success(j,g)},fail:g.fail}))}else{k.call(this);this._removeContainer(j);this._success(j,g)}}else{this._animate(j,false,!this._instance.options.animateRoot||g.unanimated,function(){k.call(this);this._removeContainer();this._success(j,g)})}}else{this._fail(j,g)}},remove:function(i,g){if(this.isItem(i)){if(this.hasSiblings(i,true)){g=this._options(g,function(){if(this.isOpenPath(i)){a.removeClass(i[0],"aciTreeVisible");this._setOddEven(i)}this._trigger(i,"removed",g)},"removefail",null,i);if(!this._trigger(i,"beforeremove",g)){this._fail(i,g);return}if(this.wasLoad(i)){this.unload(i,this._inner(g,{success:function(){this._success(i,g);this._removeItem(i)},fail:g.fail}))}else{this._success(i,g);this._removeItem(i)}}else{var h=this.parent(i);if(h.length){this.setLeaf(h,g)}else{this.unload(null,g)}}}else{this._trigger(i,"removefail",g);this._fail(i,g)}},_openChildren:function(i,h){if(h.expand){var g=this._instance.queue;this.inodes(this.children(i)).each(function(){var j=d(this);g.push(function(k){this.open(j,this._inner(h));k()})});g.push(function(j){this._success(i,h);j()})}else{this._success(i,h)}},_openItem:function(h,g){if(!g.unanimated&&!this.isVisible(h)){g.unanimated=true}if(g.unique){this.closeOthers(h);g.unique=false}this._coreDOM.toggle(h,true);this._setOddEvenChildren(h);this._animate(h,true,g.unanimated,function(){this._openChildren(h,g)})},open:function(h,g){g=this._options(g,function(){if(this.isOpenPath(h)){this._updateVisible(h);this._setOddEven(h)}this._trigger(h,"opened",g)},"openfail","wasopened",h);if(this.isInode(h)){if(!this._trigger(h,"beforeopen",g)){this._fail(h,g);return}if(this.isOpen(h)){g.success=g.notify;this._openChildren(h,g)}else{if(this.wasLoad(h)){this._openItem(h,g)}else{this.ajaxLoad(h,this._inner(g,{success:function(){this._openItem(h,g)},fail:g.fail}))}}}else{this._fail(h,g)}},_closeChildren:function(i,h){if(this._instance.options.empty){h.unanimated=true;this.unload(i,h)}else{if(h.collapse){var g=this._instance.queue;this.inodes(this.children(i)).each(function(){var j=d(this);g.push(function(k){this.close(j,this._inner(h,{unanimated:true}));k()})});g.push(function(j){this._success(i,h);j()})}else{this._success(i,h)}}},_closeItem:function(h,g){if(!g.unanimated&&!this.isVisible(h)){g.unanimated=true}this._coreDOM.toggle(h,false);this._animate(h,false,g.unanimated,function(){this._closeChildren(h,g)})},close:function(h,g){g=this._options(g,function(){if(this.isOpenPath(h)){this._updateVisible(h);this._setOddEven(h)}this._trigger(h,"closed",g)},"closefail","wasclosed",h);if(this.isInode(h)){if(!this._trigger(h,"beforeclose",g)){this._fail(h,g);return}if(this.isOpen(h)){this._closeItem(h,g)}else{if(this.wasLoad(h)){g.success=g.notify;this._closeChildren(h,g)}else{this._notify(h,g)}}}else{this._fail(h,g)}},_updateVisible:function(g){if(this.isOpenPath(g)){if(!this.isHidden(g)){a.addClass(g[0],"aciTreeVisible");if(this.isOpen(g)){a.children(g[0],false,this.proxy(function(h){if(!a.hasClass(h,"aciTreeVisible")){this._updateVisible(d(h))}}))}else{a.children(g[0],true,function(h){return a.removeClass(h,"aciTreeVisible")?true:null})}}}else{if(a.removeClass(g[0],"aciTreeVisible")){a.children(g[0],true,function(h){return a.removeClass(h,"aciTreeVisible")?true:null})}}},closeOthers:function(j,i){i=this._options(i);if(this.isItem(j)){var g=this._instance.queue;var h=j.add(this.path(j)).add(this.children(j,true));this.inodes(this.children(null,true,true),true).not(h).each(function(){var k=d(this);g.push(function(l){this.close(k,this._inner(i));l()})});g.push(function(k){this._success(j,i);k()})}else{this._fail(j,i)}},toggle:function(h,g){g=this._options(g,"toggled","togglefail",null,h);if(this.isInode(h)){if(!this._trigger(h,"beforetoggle",g)){this._fail(h,g);return}if(this.isOpen(h)){this.close(h,g)}else{this.open(h,g)}}else{this._fail(h,g)}},path:function(i,g){if(i){var h=i[0],j=[];while(h=a.parent(h)){j.push(h)}return g?d(j):d(j.reverse())}return d([])},isVisible:function(k,h){if(k&&a.hasClass(k[0],"aciTreeVisible")){var j=this._instance.jQuery[0].getBoundingClientRect();var i=k[0].firstChild;var m=i.getBoundingClientRect();var g=i.offsetHeight;var l=h?(j.bottom-j.top)/2:0;if((m.bottom-g<j.top+l)||(m.top+g>j.bottom-l)){return false}return true}return false},openPath:function(i,h){h=this._options(h);if(this.isItem(i)){var g=this._instance.queue;this.inodes(this.path(i),false).each(function(){var j=d(this);g.push(function(k){this.open(j,this._inner(h));k()})});g.push(function(j){this._success(i,h);j()})}else{this._fail(i,h)}},isOpenPath:function(h){var g=this.parent(h);return g[0]?this.isOpen(g)&&a.hasClass(g[0],"aciTreeVisible"):true},_speedFraction:function(i,g,j){if((j<g)&&g){var h=parseInt(i);if(isNaN(h)){switch(i){case"slow":h=600;break;case"medium":h=400;break;case"fast":h=200;break;default:return i}}return h*j/g}return i},setVisible:function(h,g){g=this._options(g,"visible","visiblefail","wasvisible",h);if(this.isItem(h)){if(!this._trigger(h,"beforevisible",g)){this._fail(h,g);return}if(this.isVisible(h)){this._notify(h,g);return}var i=function(){var l=this._instance.jQuery[0].getBoundingClientRect();var k=h[0].firstChild;var o=k.getBoundingClientRect();var j=k.offsetHeight;var n=g.center?(l.bottom-l.top)/2:0;if(o.bottom-j<l.top+n){var m=l.top+n-o.bottom+j;if(!g.unanimated&&this._instance.options.view){this._instance.jQuery.stop(true).animate({scrollTop:this._instance.jQuery.scrollTop()-m},{duration:this._speedFraction(this._instance.options.view.duration,l.bottom-l.top,m),easing:this._instance.options.view.easing,complete:this.proxy(function(){this._success(h,g)})})}else{this._instance.jQuery.stop(true)[0].scrollTop=this._instance.jQuery.scrollTop()-m;this._success(h,g)}}else{if(o.top+j>l.bottom-n){var m=o.top-l.bottom+n+j;if(!g.unanimated&&this._instance.options.view){this._instance.jQuery.stop(true).animate({scrollTop:this._instance.jQuery.scrollTop()+m},{duration:this._speedFraction(this._instance.options.view.duration,l.bottom-l.top,m),easing:this._instance.options.view.easing,complete:this.proxy(function(){this._success(h,g)})})}else{this._instance.jQuery.stop(true)[0].scrollTop=this._instance.jQuery.scrollTop()+m;this._success(h,g)}}else{this._success(h,g)}}};if(this.hasParent(h)){this.openPath(h,this._inner(g,{success:i,fail:g.fail}))}else{i.apply(this)}}else{this._fail(h,g)}},hasParent:function(g){return this.parent(g).length>0},parent:function(g){return g?d(a.parent(g[0])):d([])},topParent:function(g){return this.path(g).eq(0)},_createBranch:function(l,i){var k=0;var j=function(o){var n;for(var p=0;p<o.length;p++){n=o[p];if(n.branch&&(n.branch instanceof Array)&&n.branch.length){j(n.branch)}}k++};j(i.itemData);var h=0;var g=this.proxy(function(){h++;if(h>=k){this._success(l,i)}});var m=this.proxy(function(o,n){if(o){a.addRemoveClass(o[0],"aciTreeInode","aciTreeInodeMaybe")}this.append(o,this._inner(i,{success:function(s,q){var p;for(var r=0;r<q.itemData.length;r++){p=q.itemData[r];if(p.branch&&(p.branch instanceof Array)&&p.branch.length){m(q.items.eq(r),p.branch)}if(p.open){this.open(q.items.eq(r),this._inner(q,{itemData:null,items:null}))}}g()},fail:i.fail,itemData:n}))});m(l,i.itemData)},_getFirstLast:function(g){if(!g){g=this._instance.jQuery}return d(a.withAnyClass(a.children(g[0]),["aciTreeFirst","aciTreeLast"]))},_setFirstLast:function(h,g){if(g){a.removeListClass(g.toArray(),["aciTreeFirst","aciTreeLast"])}var i=this.first(h);if(i[0]){a.addClass(i[0],"aciTreeFirst");a.addClass(this.last(h)[0],"aciTreeLast")}},_setOddEven:function(g){var k;if(this._instance.jQuery[0].getElementsByClassName){k=this._instance.jQuery[0].getElementsByClassName("aciTreeVisible");k=k?c.Array.prototype.slice.call(k):[]}else{k=d(a.children(this._instance.jQuery[0],true,function(l){return this.hasClass(l,"aciTreeVisible")?true:null}))}var i=true;if(k.length){var h=0;if(g){g.each(function(){if(k.indexOf){var m=k.indexOf(this);if(m!=-1){h=c.Math.min(m,h)}}else{for(var l=0;l<k.length;l++){if(k[l]===this){h=c.Math.min(l,h);break}}}});h=c.Math.max(h-1,0)}if(h>0){var j=k[h];if(a.hasClass(j,"aciTreOdd")){i=false}k=k.slice(h+1)}}this._coreDOM.oddEven(d(k),i)},_setOddEvenChildren:function(h){var i=a.hasClass(h[0],"aciTreeOdd");var g=this.children(h);this._coreDOM.oddEven(g,!i)},_itemHook:function(h,i,g,j){if(this._instance.options.itemHook){this._instance.options.itemHook.apply(this,arguments)}},_createItem:function(h,g){if(this._private.itemClone[g]){var r=this._private.itemClone[g].cloneNode(true);var u=r.firstChild;var n=u;for(var j=0;j<g;j++){n=n.firstChild}n=n.firstChild.lastChild.firstChild;var s=n.nextSibling}else{var r=c.document.createElement("LI");r.setAttribute("role","presentation");var u=c.document.createElement("DIV");r.appendChild(u);u.setAttribute("tabindex",-1);u.setAttribute("role","treeitem");u.setAttribute("aria-selected",false);u.className="aciTreeLine";var q=u,p;for(var j=0;j<g;j++){p=c.document.createElement("DIV");q.appendChild(p);p.className="aciTreeBranch aciTreeLevel"+j;q=p}var o=c.document.createElement("DIV");q.appendChild(o);o.className="aciTreeEntry";var k=c.document.createElement("SPAN");o.appendChild(k);k.className="aciTreeButton";var m=c.document.createElement("SPAN");k.appendChild(m);m.className="aciTreePush";m.appendChild(c.document.createElement("SPAN"));var t=c.document.createElement("SPAN");o.appendChild(t);t.className="aciTreeItem";var n=c.document.createElement("SPAN");t.appendChild(n);var s=c.document.createElement("SPAN");t.appendChild(s);s.className="aciTreeText";this._private.itemClone[g]=r.cloneNode(true)}r.className="aciTreeLi"+(h.inode||(h.inode===null)?(h.inode||(h.branch&&h.branch.length)?" aciTreeInode":" aciTreeInodeMaybe"):" aciTreeLeaf")+" aciTreeLevel"+g+(h.disabled?" aciTreeDisabled":"");u.setAttribute("aria-level",g+1);if(h.inode||(h.inode===null)){u.setAttribute("aria-expanded",false)}if(h.icon){if(h.icon instanceof Array){n.className="aciTreeIcon "+h.icon[0];n.style.backgroundPosition=h.icon[1]+"px "+h.icon[2]+"px"}else{n.className="aciTreeIcon "+h.icon}}else{n.parentNode.removeChild(n)}s.innerHTML=h.label;var l=d(r);l.data("itemData"+this._instance.nameSpace,d.extend({},h,{branch:h.branch&&h.branch.length}));return l},_removeItem:function(h){var g=this.parent(h);h.remove();this._setFirstLast(g.length?g:null)},_createItems:function(m,p,h,k,g,r){var o=[],n=c.document.createDocumentFragment();var j=new this._task(this._instance.queue,function(i){o=d(o);if(o.length){if(m){m[0].appendChild(n)}else{if(p){p[0].parentNode.insertBefore(n,p[0])}else{if(h){h[0].parentNode.insertBefore(n,h[0].nextSibling)}}}}r.call(this,o);i()});if(k){this._loader(true);var q;if(m){q=this.itemFrom(m)}else{if(p){q=this.parent(p)}else{if(h){q=this.parent(h)}}}if(k instanceof Array){for(var l=0;l<k.length;l++){(function(i){j.push(function(s){var t=this._createItem(i,g);this._itemHook(q,t,i,g);n.appendChild(t[0]);o.push(t[0]);s()})})(k[l])}}else{j.push(function(i){var s=this._createItem(k,g);this._itemHook(q,s,k,g);n.appendChild(s[0]);o.push(s[0]);i()})}}j.push(function(i){i()})},_createContainer:function(h){if(!h){h=this._instance.jQuery}var g=a.container(h[0]);if(!g){var g=c.document.createElement("UL");g.setAttribute("role","group");g.className="aciTreeUl";g.style.display="none";h[0].appendChild(g)}return d(g)},_removeContainer:function(h){if(!h){h=this._instance.jQuery}var g=a.container(h[0]);g.parentNode.removeChild(g)},append:function(j,h){h=this._options(h,"appended","appendfail",null,j);if(j){if(this.isInode(j)){if(!this._trigger(j,"beforeappend",h)){this._fail(j,h);return}var g=this._createContainer(j);var i=this.last(j);this._createItems(g,null,null,h.itemData,this.level(j)+1,function(k){if(k.length){a.addRemoveClass(j[0],"aciTreeInode","aciTreeInodeMaybe");this._setFirstLast(j,i);if(this.isHidden(j)){a.addListClass(k.toArray(),"aciTreeHidden")}else{if(this.isOpenPath(j)&&this.isOpen(j)){a.addListClass(k.toArray(),"aciTreeVisible");this._setOddEven(k.first())}}k.each(this.proxy(function(l){this._trigger(d(l),"added",h)},true))}else{if(!this.hasChildren(j,true)){g.remove()}}h.items=k;this._success(j,h)})}else{this._fail(j,h)}}else{if(!this._trigger(j,"beforeappend",h)){this._fail(j,h);return}var g=this._createContainer();var i=this.last();this._createItems(g,null,null,h.itemData,0,function(k){if(k.length){this._setFirstLast(null,i);a.addListClass(k.toArray(),"aciTreeVisible");this._setOddEven();k.each(this.proxy(function(l){this._trigger(d(l),"added",h)},true));this._animate(null,true,!this._instance.options.animateRoot||h.unanimated)}else{if(!this.hasChildren(null,true)){g.remove()}}h.items=k;this._success(j,h)})}},before:function(i,g){g=this._options(g,"before","beforefail",null,i);if(this.isItem(i)){if(!this._trigger(i,"beforebefore",g)){this._fail(i,g);return}var h=this.prev(i);this._createItems(null,i,null,g.itemData,this.level(i),function(k){if(k.length){if(!h.length){a.removeClass(i[0],"aciTreeFirst");a.addClass(k.first()[0],"aciTreeFirst")}var j=this.parent(i);if(j.length&&this.isHidden(j)){a.addListClass(k.toArray(),"aciTreeHidden")}else{if(this.isOpenPath(i)){a.addListClass(k.toArray(),"aciTreeVisible");this._setOddEven(k.first())}}k.each(this.proxy(function(l){this._trigger(d(l),"added",g)},true))}g.items=k;this._success(i,g)})}else{this._fail(i,g)}},after:function(i,g){g=this._options(g,"after","afterfail",null,i);if(this.isItem(i)){if(!this._trigger(i,"beforeafter",g)){this._fail(i,g);return}var h=this.next(i);this._createItems(null,null,i,g.itemData,this.level(i),function(k){if(k.length){if(!h.length){a.removeClass(i[0],"aciTreeLast");a.addClass(k.last()[0],"aciTreeLast")}var j=this.parent(i);if(j.length&&this.isHidden(j)){a.addListClass(k.toArray(),"aciTreeHidden")}else{if(this.isOpenPath(i)){a.addListClass(k.toArray(),"aciTreeVisible");this._setOddEven(k.first())}}k.each(this.proxy(function(l){this._trigger(d(l),"added",g)},true))}g.items=k;this._success(i,g)})}else{this._fail(i,g)}},itemFrom:function(g){if(g){var h=d(g);if(h[0]===this._instance.jQuery[0]){return d([])}else{return d(a.parentFrom(h[0]))}}return d([])},children:function(h,g,i){return d(a.children(h&&h[0]?h[0]:this._instance.jQuery[0],g,i?null:function(j){return this.hasClass(j,"aciTreeHidden")?null:true}))},visible:function(h,g){var l=a.withClass(h.toArray(),"aciTreeVisible");if(g){var k=[];for(var j=0;j<l.length;j++){if(this.isVisible(d(l[j]))){k.push(l[j])}}return d(k)}return d(l)},inodes:function(g,h){if(h!==f){if(h){return d(a.withClass(g.toArray(),"aciTreeOpen"))}else{return d(a.withAnyClass(g.toArray(),["aciTreeInode","aciTreeInodeMaybe"],"aciTreeOpen"))}}return d(a.withAnyClass(g.toArray(),["aciTreeInode","aciTreeInodeMaybe"]))},leaves:function(g){return d(a.withClass(g.toArray(),"aciTreeLeaf"))},isInode:function(g){return g&&a.hasAnyClass(g[0],["aciTreeInode","aciTreeInodeMaybe"])},isLeaf:function(g){return g&&a.hasClass(g[0],"aciTreeLeaf")},wasLoad:function(g){if(g){return a.container(g[0])!==null}return a.container(this._instance.jQuery[0])!==null},setInode:function(h,g){g=this._options(g,"inodeset","inodefail","wasinode",h);if(this.isItem(h)){if(!this._trigger(h,"beforeinode",g)){this._fail(h,g);return}if(this.isLeaf(h)){this._coreDOM.inode(h,true);this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},setLeaf:function(h,g){g=this._options(g,"leafset","leaffail","wasleaf",h);if(this.isItem(h)){if(!this._trigger(h,"beforeleaf",g)){this._fail(h,g);return}if(this.isInode(h)){var i=function(){this._coreDOM.leaf(h);this._success(h,g)};if(this.wasLoad(h)){this.unload(h,this._inner(g,{success:i,fail:g.fail}))}else{i.apply(this)}}else{this._notify(h,g)}}else{this._fail(h,g)}},addIcon:function(i,g){g=this._options(g,"iconadded","addiconfail","wasicon",i);if(this.isItem(i)){if(!this._trigger(i,"beforeaddicon",g)){this._fail(i,g);return}var k=this.itemData(i);g.oldIcon=k.icon;var h=a.childrenByClass(i[0].firstChild,"aciTreeItem");var j=a.childrenByClass(h,"aciTreeIcon");if(j&&k.icon&&(g.icon.toString()==k.icon.toString())){this._notify(i,g)}else{if(!j){j=c.document.createElement("DIV");h.insertBefore(j,h.firstChild)}if(g.icon instanceof Array){j.className="aciTreeIcon "+g.icon[0];j.style.backgroundPosition=g.icon[1]+"px "+g.icon[2]+"px"}else{j.className="aciTreeIcon "+g.icon}k.icon=g.icon;this._success(i,g)}}else{this._fail(i,g)}},removeIcon:function(i,g){g=this._options(g,"iconremoved","removeiconfail","noticon",i);if(this.isItem(i)){if(!this._trigger(i,"beforeremoveicon",g)){this._fail(i,g);return}var k=this.itemData(i);g.oldIcon=k.icon;var h=a.childrenByClass(i[0].firstChild,"aciTreeItem");var j=a.childrenByClass(h,"aciTreeIcon");if(j){h.removeChild(j);k.icon=null;this._success(i,g)}else{this._notify(i,g)}}else{this._fail(i,g)}},hasIcon:function(g){return !!this.getIcon(g)},getIcon:function(g){var h=this.itemData(g);return h?h.icon:null},setLabel:function(h,g){g=this._options(g,"labelset","labelfail","waslabel",h);if(this.isItem(h)){if(!this._trigger(h,"beforelabel",g)){this._fail(h,g);return}var i=this.itemData(h);g.oldLabel=i.label;if(g.label==g.oldLabel){this._notify(h,g)}else{a.childrenByClass(h[0].firstChild,"aciTreeText").innerHTML=g.label;i.label=g.label;this._success(h,g)}}else{this._fail(h,g)}},disable:function(h,g){g=this._options(g,"disabled","disablefail","wasdisabled",h);if(this.isItem(h)){if(!this._trigger(h,"beforedisable",g)){this._fail(h,g);return}if(this.isDisabled(h)){this._notify(h,g)}else{a.addClass(h[0],"aciTreeDisabled");this._success(h,g)}}else{this._fail(h,g)}},isDisabled:function(g){return g&&a.hasClass(g[0],"aciTreeDisabled")},isDisabledPath:function(g){return a.withClass(this.path(g).toArray(),"aciTreeDisabled").length>0},disabled:function(g){return d(a.withClass(g.toArray(),"aciTreeDisabled"))},enable:function(h,g){g=this._options(g,"enabled","enablefail","wasenabled",h);if(this.isItem(h)){if(!this._trigger(h,"beforeenable",g)){this._fail(h,g);return}if(this.isDisabled(h)){a.removeClass(h[0],"aciTreeDisabled");this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},isEnabled:function(g){return g&&!a.hasClass(g[0],"aciTreeDisabled")},isEnabledPath:function(g){return a.withClass(this.path(g).toArray(),"aciTreeDisabled").length==0},enabled:function(g){return d(a.withClass(g.toArray(),null,"aciTreeDisabled"))},hide:function(i,g){g=this._options(g,"hidden","hidefail","washidden",i);if(this.isItem(i)){if(!this._trigger(i,"beforehide",g)){this._fail(i,g);return}if(this.isHidden(i)){this._notify(i,g)}else{a.addRemoveClass(i[0],"aciTreeHidden","aciTreeVisible");a.addRemoveClass(this.children(i,true).toArray(),"aciTreeHidden","aciTreeVisible");var h=this.parent(i);this._setFirstLast(h.length?h:null,i);this._setOddEven(i);this._success(i,g)}}else{this._fail(i,g)}},isHidden:function(g){return g&&a.hasClass(g[0],"aciTreeHidden")},isHiddenPath:function(h){var g=this.parent(h);return g[0]&&a.hasClass(g[0],"aciTreeHidden")},_updateHidden:function(g){if(this.isHiddenPath(g)){if(!this.isHidden(g)){a.addClass(g[0],"aciTreeHidden");this._updateVisible(g)}}else{this._updateVisible(g)}},hidden:function(g){return d(a.withClass(g.toArray(),"aciTreeHidden"))},_showHidden:function(h){var g=null;this.path(h).add(h).each(this.proxy(function(i){var j=d(i);if(this.isHidden(j)){a.removeClass(j[0],"aciTreeHidden");if(this.isOpenPath(j)&&(!g||this.isOpen(g))){a.addClass(j[0],"aciTreeVisible")}this._setFirstLast(g,this._getFirstLast(g))}g=j},true))},show:function(i,g){g=this._options(g,"shown","showfail","wasshown",i);if(this.isItem(i)){if(!this._trigger(i,"beforeshow",g)){this._fail(i,g);return}if(this.isHidden(i)){this._showHidden(i);var h=this.topParent(i);this._setOddEven(h.length?h:i);this._success(i,g)}else{this._notify(i,g)}}else{this._fail(i,g)}},isOpen:function(g){return g&&a.hasClass(g[0],"aciTreeOpen")},isClosed:function(g){return g&&!a.hasClass(g[0],"aciTreeOpen")},hasChildren:function(g,h){return this.children(g,false,h).length>0},hasSiblings:function(g,h){return this.siblings(g,h).length>0},hasPrev:function(g,h){return this.prev(g,h).length>0},hasNext:function(g,h){return this.next(g,h).length>0},siblings:function(g,h){return g?d(a.children(g[0].parentNode.parentNode,false,function(i){return(i!=g[0])&&(h||!this.hasClass(i,"aciTreeHidden"))})):d([])},prev:function(g,h){return g?d(a.prev(g[0],h?null:function(i){return !this.hasClass(i,"aciTreeHidden")})):d([])},next:function(g,h){return g?d(a.next(g[0],h?null:function(i){return !this.hasClass(i,"aciTreeHidden")})):d([])},level:function(h){var i=-1;if(h){var g=h[0];while(a.hasClass(g,"aciTreeLi")){g=g.parentNode.parentNode;i++}}return i},getId:function(g){var h=this.itemData(g);return h?h.id:null},itemData:function(g){return g?g.data("itemData"+this._instance.nameSpace):null},setId:function(h,g){g=this._options(g,"idset","idfail","wasid",h);if(this.isItem(h)){if(!this._trigger(h,"beforeid",g)){this._fail(h,g);return}var i=this.itemData(h);g.oldId=i.id;if(g.id==g.oldId){this._notify(h,g)}else{i.id=g.id;this._success(h,g)}}else{this._fail(h,g)}},getIndex:function(j){if(j&&j[0]){if(c.Array.prototype.indexOf){return c.Array.prototype.indexOf.call(j[0].parentNode.childNodes,j[0])}else{var h=j[0].parentNode.childNodes;for(var g=0;g<h.length;g++){if(h[g]==j[0]){return g}}}}return null},setIndex:function(i,g){g=this._options(g,"indexset","indexfail","wasindex",i);if(this.isItem(i)){var k=this.getIndex(i);var j=this.siblings(i);if((g.index!=k)&&!j.length){this._fail(i,g);return}if(!this._trigger(i,"beforeindex",g)){this._fail(i,g);return}g.oldIndex=k;if(g.index==k){this._notify(i,g)}else{if(g.index<1){j.first().before(i)}else{if(g.index>=j.length){j.last().after(i)}else{j.eq(g.index).before(i)}}var h=this.parent(i);this._setFirstLast(h.length?h:null,i.add([j[0],j.get(-1)]));this._setOddEven(h);this._success(i,g)}}else{this._fail(i,g)}},getLabel:function(g){var h=this.itemData(g);return h?h.label:null},isItem:function(g){return g&&a.hasClass(g[0],"aciTreeLi")},_animate:function(j,k,i,l){if(!j){j=this._instance.jQuery}if(!i){var h=k?this._instance.options.show:this._instance.options.hide;if(h){var g=a.container(j[0]);if(g){d(g).stop(true,true).animate(h.props,{duration:h.duration,easing:h.easing,complete:l?this.proxy(l):null})}else{if(l){l.apply(this)}}return}}d(a.container(j[0])).stop(true,true).toggle(k);if(l){l.apply(this)}},first:function(g,h){if(!g){g=this._instance.jQuery}return d(a.firstChild(g[0],h?null:function(i){return !this.hasClass(i,"aciTreeHidden")}))},isFirst:function(h,i){if(h){var g=a.parent(h[0]);return this.first(g?d(g):null,i)[0]==h[0]}return false},last:function(g,h){if(!g){g=this._instance.jQuery}return d(a.lastChild(g[0],h?null:function(i){return !this.hasClass(i,"aciTreeHidden")}))},isLast:function(h,i){if(h){var g=a.parent(h[0]);return this.last(g?d(g):null,i)[0]==h[0]}return false},isBusy:function(g){if(g){return a.hasClass(g[0],"aciTreeLoad")}else{return this._instance.queue.busy()}},_loading:function(g,h){if(g){a.toggleClass(g[0],"aciTreeLoad",h);if(h){g[0].firstChild.setAttribute("aria-busy",true)}else{g[0].firstChild.removeAttribute("aria-busy")}}else{if(h){this._loader(h)}}},_loader:function(g){if(g||this.isBusy()){if(!this._private.loaderInterval){this._private.loaderInterval=c.setInterval(this.proxy(function(){this._loader()}),this._instance.options.loaderDelay)}a.addClass(this._instance.jQuery[0],"aciTreeLoad");c.clearTimeout(this._private.loaderHide);this._private.loaderHide=c.setTimeout(this.proxy(function(){a.removeClass(this._instance.jQuery[0],"aciTreeLoad")}),this._instance.options.loaderDelay*2)}},isChildren:function(h,g){if(!h){h=this._instance.jQuery}return g&&(h.has(g).length>0)},isImmediateChildren:function(h,g){if(!h){h=this._instance.jQuery}return g&&h.children(".aciTreeUl").children(".aciTreeLi").is(g)},sameParent:function(i,g){if(i&&g){var j=this.parent(i);var h=this.parent(g);return(!j.length&&!h.length)||(j[0]==h[0])}return false},sameTopParent:function(i,g){if(i&&g){var j=this.topParent(i);var h=this.topParent(g);return(!j.length&&!h.length)||(j[0]==h[0])}return false},_serialize:function(g,i){var h=this.itemData(g);if(this.isInode(g)){h.inode=true;if(this.wasLoad(g)){if(h.hasOwnProperty("open")){h.open=this.isOpen(g)}else{if(this.isOpen(g)){h.open=true}}h.branch=[];this.children(g,false,true).each(this.proxy(function(j){var k=this._serialize(d(j),i);if(i){k=i.call(this,d(j),{},k)}else{k=this._instance.options.serialize.call(this,d(j),{},k)}if(k){h.branch.push(k)}},true));if(!h.branch.length){h.branch=null}}else{if(h.hasOwnProperty("open")){h.open=false}if(h.hasOwnProperty("branch")){h.branch=null}}}else{if(h.hasOwnProperty("inode")){h.inode=false}if(h.hasOwnProperty("open")){h.open=null}if(h.hasOwnProperty("branch")){h.branch=null}}if(h.hasOwnProperty("disabled")){h.disabled=this.isDisabled(g)}else{if(this.isDisabled(g)){h.disabled=true}}return h},serialize:function(g,j,k){if(typeof j=="object"){if(g){var i=this._serialize(g,k);if(k){i=k.call(this,g,{},i)}else{i=this._instance.options.serialize.call(this,g,{},i)}return i}else{var h=[];this.children(null,false,true).each(this.proxy(function(l){var m=this._serialize(d(l),k);if(k){m=k.call(this,d(l),{},m)}else{m=this._instance.options.serialize.call(this,d(l),{},m)}if(m){h.push(m)}},true));return h}}return""},destroy:function(g){g=this._options(g);if(!this.wasInit()){this._trigger(null,"notinit",g);this._fail(null,g);return}if(this.isLocked()){this._trigger(null,"locked",g);this._fail(null,g);return}if(!this._trigger(null,"beforedestroy",g)){this._trigger(null,"destroyfail",g);this._fail(null,g);return}this._private.locked=true;this._instance.jQuery.addClass("aciTreeLoad").attr("aria-busy",true);this._instance.queue.destroy();this._destroyHook(false);this.unload(null,this._inner(g,{success:this.proxy(function(){c.clearTimeout(this._private.loaderHide);c.clearInterval(this._private.loaderInterval);this._private.itemClone={};this._destroyHook(true);this._instance.jQuery.unbind(this._instance.nameSpace).off(this._instance.nameSpace,".aciTreeButton").off(this._instance.nameSpace,".aciTreeLine");this._instance.jQuery.removeClass("aciTree"+this._instance.index+" aciTreeLoad").removeAttr("role aria-busy");this._private.locked=false;this._super();this._trigger(null,"destroyed",g);this._success(null,g)}),fail:function(){this._instance.jQuery.removeClass("aciTreeLoad");this._private.locked=false;this._trigger(null,"destroyfail",g);this._fail(null,g)}}))},_destroyHook:function(g){}};aciPluginClass.plugins.aciTree=aciPluginClass.aciPluginUi.extend(e,"aciTreeCore");aciPluginClass.publish("aciTree",b);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// utils
(function(e,d,f){var b={filterHook:function(h,g,i){return g.length?i.test(d.String(this.getLabel(h))):true}};var c={__extend:function(){e.extend(this._instance,{filter:new this._queue(this,this._instance.options.queue)});this._instance.filter.destroy();this._super()},branch:function(h,k,i){var g=this._instance.queue;var j=this.proxy(function(m,o,l){var n=l?this.next(m):this.first(m);if(n.length){if(this.isInode(n)){if(this.wasLoad(n)){g.push(function(p){o.call(this,n);j(n,o);j(n,o,true);p()})}else{if(i){this.ajaxLoad(n,{success:function(){o.call(this,n);j(n,o);j(n,o,true)},fail:function(){j(n,o,true)}})}else{g.push(function(p){o.call(this,n);j(n,o,true);p()})}}}else{g.push(function(p){o.call(this,n);j(n,o,true);p()})}}});j(h,k)},swap:function(i){i=this._options(i,null,"swapfail",null,null);var h=i.item1;var g=i.item2;if(this.isItem(h)&&this.isItem(g)&&!this.isChildren(h,g)&&!this.isChildren(g,h)&&(h[0]!=g[0])){if(!this._trigger(null,"beforeswap",i)){this._fail(null,i);return}var l=this.prev(h);if(l.length){if(g[0]==l[0]){g.before(h)}else{h.insertAfter(g);g.insertAfter(l)}}else{var k=this.next(h);if(k.length){if(g[0]==k[0]){g.after(h)}else{h.insertAfter(g);g.insertBefore(k)}}else{var j=h.parent();h.insertAfter(g);j.append(g)}}this._updateLevel(h);var j=this.parent(h);this._setFirstLast(j.length?j:null,h);this._updateHidden(h);this._updateLevel(g);j=this.parent(g);this._setFirstLast(j.length?j:null,g);this._updateHidden(g);this._setOddEven(h.add(g));this._trigger(null,"swapped",i);this._success(null,i)}else{this._fail(null,i)}},_updateItemLevel:function(n,h,k){a.addRemoveClass(n[0],"aciTreeLevel"+k,"aciTreeLevel"+h);var g=n[0].firstChild;g.setAttribute("aria-level",k+1);var m=a.childrenByClass(g,"aciTreeEntry");if(h<k){g=m.parentNode;var l;for(var j=h;j<k;j++){l=d.document.createElement("DIV");g.appendChild(l);l.className="aciTreeBranch aciTreeLevel"+j;g=l}g.appendChild(m)}else{var l=m;for(var j=k;j<=h;j++){l=l.parentNode}l.removeChild(l.firstChild);l.appendChild(m)}},_updateChildLevel:function(i,g,h){this.children(i,false,true).each(this.proxy(function(j){var k=e(j);this._updateItemLevel(k,g,h);if(this.isInode(k)){this._updateChildLevel(k,g+1,h+1)}},true))},_updateLevel:function(g){var i=this.level(g);var h=d.parseInt(g.attr("class").match(/aciTreeLevel[0-9]+/)[0].match(/[0-9]+/));if(i!=h){this._updateItemLevel(g,h,i);this._updateChildLevel(g,h+1,i+1)}},moveUp:function(h,g){g=this._options(g);g.index=d.Math.max(this.getIndex(h)-1,0);this.setIndex(h,g)},moveDown:function(h,g){g=this._options(g);g.index=d.Math.min(this.getIndex(h)+1,this.siblings(h).length);this.setIndex(h,g)},moveFirst:function(h,g){g=this._options(g);g.index=0;this.setIndex(h,g)},moveLast:function(h,g){g=this._options(g);g.index=this.siblings(h).length;this.setIndex(h,g)},moveBefore:function(j,g){g=this._options(g,null,"movefail","wasbefore",j);var k=g.before;if(this.isItem(j)&&this.isItem(k)&&!this.isChildren(j,k)&&(j[0]!=k[0])){if(!this._trigger(j,"beforemove",g)){this._fail(j,g);return}if(this.prev(k,true)[0]==j[0]){this._notify(j,g)}else{var h=this.parent(j);var i=this.prev(j,true);if(!i.length){i=h.length?h:this.first()}j.insertBefore(k);if(h.length&&!this.hasChildren(h,true)){this.setLeaf(h)}this._updateLevel(j);this._setFirstLast(h.length?h:null);h=this.parent(j);this._setFirstLast(h.length?h:null,j.add(k));this._updateHidden(j);this._setOddEven(j.add(k).add(i));this._trigger(j,"moved",g);this._success(j,g)}}else{this._fail(j,g)}},moveAfter:function(j,g){g=this._options(g,null,"movefail","wasafter",j);var k=g.after;if(this.isItem(j)&&this.isItem(k)&&!this.isChildren(j,k)&&(j[0]!=k[0])){if(!this._trigger(j,"beforemove",g)){this._fail(j,g);return}if(this.next(k,true)[0]==j[0]){this._notify(j,g)}else{var h=this.parent(j);var i=this.prev(j,true);if(!i.length){i=h.length?h:this.first()}j.insertAfter(k);if(h.length&&!this.hasChildren(h,true)){this.setLeaf(h)}this._updateLevel(j);this._setFirstLast(h.length?h:null);h=this.parent(j);this._setFirstLast(h.length?h:null,j.add(k));this._updateHidden(j);this._setOddEven(j.add(k).add(i));this._trigger(j,"moved",g);this._success(j,g)}}else{this._fail(j,g)}},asChild:function(i,g){g=this._options(g,null,"childfail",null,i);var h=g.parent;if(this.isItem(i)&&this.isItem(h)&&!this.isChildren(i,h)&&!this.hasChildren(h,true)&&(i[0]!=h[0])){if(!this._trigger(i,"beforechild",g)){this._fail(i,g);return}var j=function(){var l=this.parent(i);var m=this.prev(i);if(!m.length){m=l.length?l:this.first()}var k=this._createContainer(h);k.append(i);if(l.length&&!this.hasChildren(l,true)){this.setLeaf(l)}this._updateLevel(i);this._setFirstLast(l.length?l:null);this._setFirstLast(h.length?h:null,i);this._updateHidden(i);this._setOddEven(i.add(m));this._trigger(i,"childset",g);this._success(i,g)};if(this.isInode(h)){j.apply(this)}else{this.setInode(h,this._inner(g,{success:j,fail:g.fail}))}}else{this._fail(i,g)}},_search:function(o,l){var n=this.children(o);var p,g,j,r,m=false;for(var k=0,q=n.length;k<q;k++){p=n.eq(k);g=d.String(this.getId(p));j=g.length;if(j){if(g==l.substr(0,j)){r=p;m=l.length==j;break}}}if(r){if(!m){var h=this._search(r,l);if(h){return h}}return{item:r,exact:m}}else{return null}},searchId:function(k,i,g){g=this._options(g);var l=g.id;if(k){if(i){var j=this.proxy(function(m){var n=this._search(m,l);if(n){if(n.exact){this._success(n.item,g)}else{if(this.wasLoad(n.item)){this._fail(m,g)}else{this.ajaxLoad(n.item,this._inner(g,{success:function(){j(n.item)},fail:g.fail}))}}}else{this._fail(m,g)}});j()}else{var h=this._search(null,l);if(h&&h.exact){this._success(h.item,g)}else{this._fail(null,g)}}}else{var h=e();this._instance.jQuery.find(".aciTreeLi").each(this.proxy(function(m){if(l==this.getId(e(m))){h=e(m);return false}},true));if(h.length){this._success(h,g)}else{this._fail(null,g)}}},search:function(l,h){var k=[];h=this._options(h);var g=new this._task(new this._queue(this,this._instance.options.queue),function(m){if(k.length){h.results=e(k);this._success(e(k[0]),h)}else{this._fail(l,h)}m()});var j=this.proxy(function(m){this.children(m,false,true).each(this.proxy(function(o){if(h.callback){var n=h.callback.call(this,e(o),h.search);if(n){k.push(o)}else{if(n===null){return}}}else{if(this.getId(e(o))==h.search){k.push(o)}}if(this.isInode(e(o))){g.push(function(p){i(e(o));p()})}},true))});var i=this.proxy(function(m){if(this.wasLoad(m)){g.push(function(n){j(m);n()})}else{if(h.load){g.push(function(n){this.ajaxLoad(m,{success:function(){j(m);n()},fail:n})})}}});g.push(function(m){i(l);m()})},searchPath:function(i,g){g=this._options(g);var j=g.path;var h=this.proxy(function(k,l){this.search(k,{success:function(m){if(j.length){h(m,j.shift())}else{this._success(m,g)}},fail:function(){this._fail(k,g)},search:l,load:g.load,callback:function(n,m){return(this.getId(n)==m)?true:null}})});h(i,j.shift())},pathId:function(h,g){var i=this.path(h,g),j=[];i.each(this.proxy(function(k){j.push(this.getId(e(k)))},true));return j},_regexp:function(g){return new d.RegExp(d.String(g).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08"),"i")},filter:function(j,h){h=this._options(h,null,"filterfail",null,j);if(!j||this.isItem(j)){if(!this._trigger(j,"beforefilter",h)){this._fail(j,h);return}var i=d.String(h.search);var k=this._regexp(i);var m=null;this._instance.filter.init();var g=new this._task(this._instance.filter,function(n){this._instance.filter.destroy();h.first=m;this._setOddEven();this._trigger(j,"filtered",h);this._success(j,h);n()});var l=this.proxy(function(o){var n=this.children(o,false,true);var p=false;n.each(this.proxy(function(q){var r=e(q);if(this._instance.options.filterHook.call(this,r,i,k)){if(!m){m=r}p=true;a.removeClass(r[0],"aciTreeHidden")}else{a.addRemoveClass(r[0],"aciTreeHidden","aciTreeVisible")}if(this.isInode(r)){g.push(function(s){l(r);s()})}},true));if(p){if(o&&this.isHidden(o)){this._showHidden(o)}if(!o||(this.isOpenPath(o)&&this.isOpen(o))){n.not(".aciTreeHidden").addClass("aciTreeVisible")}this._setFirstLast(o,this._getFirstLast(o))}});g.push(function(n){l(j);n()})}else{this._fail(j,h)}},_firstAll:function(g){g.call(this,this.first())},_lastAll:function(g,i,h){if(g){if(this.isInode(g)){if(this.wasLoad(g)){this._lastAll(this.last(g),i,h);return}else{if(h){this.ajaxLoad(g,{success:function(){this._lastAll(this.last(g),i,h)},fail:function(){i.call(this,g)}});return}}}i.call(this,g)}else{i.call(this,this.last())}},_nextAll:function(i,k,j){if(i){if(this.isInode(i)){if(this.wasLoad(i)){k.call(this,this.first(i));return}else{if(j){this.ajaxLoad(i,{success:function(){k.call(this,this.first(i))},fail:function(){this._nextAll(i,k,j)}});return}}}var h=this.next(i);if(h.length){k.call(this,h)}else{var g=this.proxy(function(n){var m=this.parent(n);if(m.length){var l=this.next(m);if(l.length){return l}else{return g(m)}}return null});k.call(this,g(i))}}else{k.call(this,this.first())}},_prevAll:function(i,k,j){if(i){var h=this.prev(i);if(h.length){if(this.isInode(h)){this._lastAll(h,k,j)}else{k.call(this,h)}}else{var g=this.parent(i);k.call(this,g.length?g:null)}}else{k.call(this,this.last())}},prevMatch:function(i,h,l){var j=this._regexp(h);this._instance.filter.init();var g=new this._task(this._instance.filter,function(m){this._instance.filter.destroy();m()});var k=function(m){g.push(function(n){this._prevAll(m,function(o){if(o){if(this._instance.options.filterHook.call(this,o,h,j)){l.call(this,o)}else{k(o)}}else{l.call(this,null)}n()})})};k(this.isItem(i)?i:null)},nextMatch:function(i,h,l){var j=this._regexp(h);this._instance.filter.init();var g=new this._task(this._instance.filter,function(m){this._instance.filter.destroy();m()});var k=function(m){g.push(function(n){this._nextAll(m,function(o){if(o){if(this._instance.options.filterHook.call(this,o,h,j)){l.call(this,o)}else{k(o)}}else{l.call(this,null)}n()})})};k(this.isItem(i)?i:null)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(c,"aciTreeUtils");aciPluginClass.defaults("aciTree",b);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// selectable
(function(d,c,e){var b={selectable:true,multiSelectable:false,fullRow:false,textSelection:false};var f={__extend:function(){d.extend(this._instance,{focus:false});d.extend(this._private,{blurTimeout:null,spinPoint:null});this._super()},hasFocus:function(){return this._instance.focus},_selectableInit:function(){if(this._instance.jQuery.attr("tabindex")===e){this._instance.jQuery.attr("tabindex",0)}if(!this._instance.options.textSelection){this._selectable(false)}this._instance.jQuery.bind("acitree"+this._private.nameSpace,function(k,i,j,g,h){switch(g){case"closed":var l=i.focused();if(i.isChildren(j,l)){i._focusOne(j)}i.children(j,true).each(i.proxy(function(m){var n=d(m);if(this.isSelected(n)){this.deselect(n)}},true));break}}).bind("focusin"+this._private.nameSpace,this.proxy(function(){c.clearTimeout(this._private.blurTimeout);if(!this.hasFocus()){this._instance.focus=true;a.addClass(this._instance.jQuery[0],"aciTreeFocus");this._trigger(null,"focused")}})).bind("focusout"+this._private.nameSpace,this.proxy(function(){c.clearTimeout(this._private.blurTimeout);this._private.blurTimeout=c.setTimeout(this.proxy(function(){if(this.hasFocus()){this._instance.focus=false;a.removeClass(this._instance.jQuery[0],"aciTreeFocus");this._trigger(null,"blurred")}}),10)})).bind("keydown"+this._private.nameSpace,this.proxy(function(j){if(!this.hasFocus()){return}var i=this.focused();if(i.length&&this.isBusy(i)){return false}var h=d([]);switch(j.which){case 65:if(this._instance.options.multiSelectable&&j.ctrlKey){var g=this.visible(this.enabled(this.children(null,true))).not(this.selected());g.each(this.proxy(function(k){this.select(d(k),{focus:false})},true));if(!this.focused().length){this._focusOne(this.visible(g,true).first())}j.preventDefault()}break;case 38:h=i.length?this._prev(i):this.first();break;case 40:h=i.length?this._next(i):this.first();break;case 37:if(i.length){if(this.isOpen(i)){h=i;this.close(i,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique})}else{h=this.parent(i)}}else{h=this._first()}break;case 39:if(i.length){if(this.isInode(i)&&this.isClosed(i)){h=i;this.open(i,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique})}else{h=this.first(i)}}else{h=this._first()}break;case 33:h=i.length?this._prevPage(i):this._first();break;case 34:h=i.length?this._nextPage(i):this._first();break;case 36:h=this._first();break;case 35:h=this._last();break;case 13:case 107:h=i;if(this.isInode(i)&&this.isClosed(i)){this.open(i,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique})}break;case 27:case 109:h=i;if(this.isOpen(i)){this.close(i,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique})}if(j.which==27){j.preventDefault()}break;case 32:h=i;if(this.isInode(i)&&!j.ctrlKey){this.toggle(i,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique})}j.preventDefault();break;case 106:h=i;if(this.isInode(i)){this.open(i,{collapse:this._instance.options.collapse,expand:true,unique:this._instance.options.unique})}break}if(h.length){if(this._instance.options.multiSelectable&&!j.ctrlKey&&!j.shiftKey){this._unselect(this.selected().not(h))}if(!this.isVisible(h)){this.setVisible(h)}if(j.ctrlKey){if((j.which==32)&&this.isEnabled(h)){if(this.isSelected(h)){this.deselect(h)}else{this.select(h)}this._private.spinPoint=h}else{this._focusOne(h)}}else{if(j.shiftKey){this._shiftSelect(h)}else{if(!this.isSelected(h)&&this.isEnabled(h)){this.select(h)}else{this._focusOne(h)}this._private.spinPoint=h}}return false}}));this._fullRow(this._instance.options.fullRow);this._multiSelectable(this._instance.options.multiSelectable)},_fullRow:function(g){this._instance.jQuery.off(this._private.nameSpace,".aciTreeLine,.aciTreeItem").off(this._private.nameSpace,".aciTreeItem");this._instance.jQuery.on("mousedown"+this._private.nameSpace+" click"+this._private.nameSpace,g?".aciTreeLine,.aciTreeItem":".aciTreeItem",this.proxy(function(i){var h=this.itemFrom(i.target);if(!this.isVisible(h)){this.setVisible(h)}if(i.ctrlKey){if(i.type=="click"){if(this.isEnabled(h)){if(this.isSelected(h)){this.deselect(h);this._focusOne(h)}else{this.select(h)}}else{this._focusOne(h)}}}else{if(this._instance.options.multiSelectable&&i.shiftKey){this._shiftSelect(h)}else{if(this._instance.options.multiSelectable&&(!this.isSelected(h)||(i.type=="click"))){this._unselect(this.selected().not(h))}this._selectOne(h)}}if(!i.shiftKey){this._private.spinPoint=h}})).on("dblclick"+this._private.nameSpace,g?".aciTreeLine,.aciTreeItem":".aciTreeItem",this.proxy(function(i){var h=this.itemFrom(i.target);if(this.isInode(h)){this.toggle(h,{collapse:this._instance.options.collapse,expand:this._instance.options.expand,unique:this._instance.options.unique});return false}}));if(g){a.addClass(this._instance.jQuery[0],"aciTreeFullRow")}else{a.removeClass(this._instance.jQuery[0],"aciTreeFullRow")}},_multiSelectable:function(g){if(g){this._instance.jQuery.attr("aria-multiselectable",true)}else{var h=this.focused();this._unselect(this.selected().not(h));this._instance.jQuery.removeAttr("aria-multiselectable")}},_shiftSelect:function(i){var l=this._private.spinPoint;if(!l||!d.contains(this._instance.jQuery[0],l[0])||!this.isOpenPath(l)){l=this.focused()}if(l.length){var g=[i[0]],m=l[0],j=false,h=i[0];var k=this.visible(this.children(null,true));k.each(this.proxy(function(n){if(j){if(this.isEnabled(d(n))){g.push(n)}if((n==m)||(n==h)){return false}}else{if((n==m)||(n==h)){if(this.isEnabled(d(n))){g.push(n)}if((n==m)&&(n==h)){return false}j=true}}},true));this._unselect(this.selected().not(g));d(g).not(i).each(this.proxy(function(n){var o=d(n);if(!this.isSelected(o)){this.select(o,{focus:false})}},true))}this._selectOne(i)},_initHook:function(){if(this.extSelectable()){this._selectableInit()}this._super()},_itemHook:function(h,i,g,j){if(this.extSelectable()&&g.selected){this._selectableDOM.select(i,true)}this._super(h,i,g,j)},_selectableDOM:{select:function(g,h){if(h){a.addListClass(g.toArray(),"aciTreeSelected",function(i){i.firstChild.setAttribute("aria-selected",true)})}else{a.removeListClass(g.toArray(),"aciTreeSelected",function(i){i.firstChild.setAttribute("aria-selected",false)})}},focus:function(g,h){if(h){a.addClass(g[0],"aciTreeFocus");g[0].firstChild.focus()}else{a.removeListClass(g.toArray(),"aciTreeFocus")}}},_selectable:function(g){if(g){this._instance.jQuery.css({"-webkit-user-select":"text","-moz-user-select":"text","-ms-user-select":"text","-o-user-select":"text","user-select":"text"}).attr({unselectable:null,onselectstart:null}).unbind("selectstart"+this._private.nameSpace)}else{this._instance.jQuery.css({"-webkit-user-select":"none","-moz-user-select":"-moz-none","-ms-user-select":"none","-o-user-select":"none","user-select":"none"}).attr({unselectable:"on",onselectstart:"return false"}).bind("selectstart"+this._private.nameSpace,function(h){if(!d(h.target).is("input,textarea")){return false}})}},_first:function(){return d(a.first(this._instance.jQuery[0],function(g){return this.hasClass(g,"aciTreeVisible")?true:null}))},_last:function(){return d(a.last(this._instance.jQuery[0],function(g){return this.hasClass(g,"aciTreeVisible")?true:null}))},_prev:function(g){return d(a.prevAll(g[0],function(h){return this.hasClass(h,"aciTreeVisible")?true:null}))},_next:function(g){return d(a.nextAll(g[0],function(h){return this.hasClass(h,"aciTreeVisible")?true:null}))},_prevPage:function(j){var k=this._instance.jQuery.height();var g=j[0].firstChild.offsetHeight;var i=j,h=d();while(g<k){i=this._prev(i);if(i[0]){g+=i[0].firstChild.offsetHeight;h=i}else{break}}return h},_nextPage:function(j){var k=this._instance.jQuery.height();var g=j[0].firstChild.offsetHeight;var h=j,i=d();while(g<k){h=this._next(h);if(h[0]){g+=h[0].firstChild.offsetHeight;i=h}else{break}}return i},_selectOne:function(g){if(this.isSelected(g)){this._focusOne(g)}else{if(this.isEnabled(g)){this.select(g)}else{this._focusOne(g)}}},_unselect:function(g){g.each(this.proxy(function(h){this.deselect(d(h))},true))},_focusOne:function(g){if(!this._instance.options.multiSelectable){this._unselect(this.selected().not(g))}if(!this.isFocused(g)){this.focus(g)}},select:function(i,h){h=this._options(h,"selected","selectfail","wasselected",i);if(this.extSelectable()&&this.isItem(i)){if(!this._trigger(i,"beforeselect",h)){this._fail(i,h);return}h.oldSelected=this.selected();if(!this._instance.options.multiSelectable){var g=h.oldSelected.not(i);this._selectableDOM.select(g,false);g.each(this.proxy(function(j){this._trigger(d(j),"deselected",h)},true))}if(this.isSelected(i)){this._notify(i,h)}else{this._selectableDOM.select(i,true);this._success(i,h)}if((h.focus===e)||h.focus){if(!this.isFocused(i)||h.focus){this.focus(i,this._inner(h))}}}else{this._fail(i,h)}},deselect:function(h,g){g=this._options(g,"deselected","deselectfail","notselected",h);if(this.extSelectable()&&this.isItem(h)){if(!this._trigger(h,"beforedeselect",g)){this._fail(h,g);return}if(this.isSelected(h)){this._selectableDOM.select(h,false);this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},focus:function(i,h){h=this._options(h,"focus","focusfail","wasfocused",i);if(this.extSelectable()&&this.isItem(i)){if(!this._trigger(i,"beforefocus",h)){this._fail(i,h);return}h.oldFocused=this.focused();var g=h.oldFocused.not(i);this._selectableDOM.focus(g,false);g.each(this.proxy(function(j){this._trigger(d(j),"blur",h)},true));if(this.isFocused(i)){this._notify(i,h)}else{this._selectableDOM.focus(i,true);this._success(i,h)}}else{this._fail(i,h)}},blur:function(h,g){g=this._options(g,"blur","blurfail","notfocused",h);if(this.extSelectable()&&this.isItem(h)){if(!this._trigger(h,"beforeblur",g)){this._fail(h,g);return}if(this.isFocused(h)){this._selectableDOM.focus(h,false);this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},selected:function(){return this._instance.jQuery.find(".aciTreeSelected")},_serialize:function(g,i){var h=this._super(g,i);if(h&&this.extSelectable()){if(h.hasOwnProperty("selected")){h.selected=this.isSelected(g)}else{if(this.isSelected(g)){h.selected=true}}}return h},isSelected:function(g){return g&&a.hasClass(g[0],"aciTreeSelected")},focused:function(){return this._instance.jQuery.find(".aciTreeFocus")},isFocused:function(g){return g&&a.hasClass(g[0],"aciTreeFocus")},extSelectable:function(){return this._instance.options.selectable},option:function(g,h){if(this.wasInit()&&!this.isLocked()){if((g=="selectable")&&(h!=this.extSelectable())){if(h){this._selectableInit()}else{this._selectableDone()}}if((g=="multiSelectable")&&(h!=this._instance.options.multiSelectable)){this._multiSelectable(h)}if((g=="fullRow")&&(h!=this._instance.options.fullRow)){this._fullRow(h)}if((g=="textSelection")&&(h!=this._instance.options.textSelection)){this._selectable(h)}}this._super(g,h)},_selectableDone:function(g){if(this._instance.jQuery.attr("tabindex")==0){this._instance.jQuery.removeAttr("tabindex")}if(!this._instance.options.textSelection){this._selectable(true)}this._instance.jQuery.unbind(this._private.nameSpace);this._instance.jQuery.off(this._private.nameSpace,".aciTreeLine,.aciTreeItem").off(this._private.nameSpace,".aciTreeItem");a.removeClass(this._instance.jQuery[0],["aciTreeFocus","aciTreeFullRow"]);this._instance.jQuery.removeAttr("aria-multiselectable");this._instance.focus=false;this._private.spinPoint=null;if(!g){this._unselect(this.selected());var h=this.focused();if(h.length){this.blur(h)}}},_destroyHook:function(g){if(g){this._selectableDone(true)}this._super(g)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(f,"aciTreeSelectable");aciPluginClass.defaults("aciTree",b);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// checkbox (works best with selectable)
(function(e,d,f){var c={checkbox:false,checkboxChain:true,checkboxBreak:true,checkboxClick:false};var b={_checkboxInit:function(){this._instance.jQuery.bind("acitree"+this._private.nameSpace,function(k,i,j,g,h){switch(g){case"loaded":i._checkboxLoad(j);break}}).bind("keydown"+this._private.nameSpace,this.proxy(function(h){switch(h.which){case 32:if(this.extSelectable&&this.extSelectable()&&!h.ctrlKey){var g=this.focused();if(this.hasCheckbox(g)&&this.isEnabled(g)){if(this.isChecked(g)){this.uncheck(g)}else{this.check(g)}h.stopImmediatePropagation();h.preventDefault()}}break}})).on("click"+this._private.nameSpace,".aciTreeItem",this.proxy(function(h){if(!this._instance.options.checkboxClick||e(h.target).is(".aciTreeCheck")){var g=this.itemFrom(h.target);if(this.hasCheckbox(g)&&this.isEnabled(g)&&(!this.extSelectable||!this.extSelectable()||(!h.ctrlKey&&!h.shiftKey))){if(this.isChecked(g)){this.uncheck(g)}else{this.check(g)}h.preventDefault()}}}))},_initHook:function(){if(this.extCheckbox()){this._checkboxInit()}this._super()},_itemHook:function(i,j,g,k){if(this.extCheckbox()){var h=this.extRadio&&this.hasRadio(j);if(!h&&(g.checkbox||((g.checkbox===f)&&(!this.extRadio||!this.extRadio())))){this._checkboxDOM.add(j,g)}}this._super(i,j,g,k)},_checkboxDOM:{add:function(k,g){a.addClass(k[0],g.checked?["aciTreeCheckbox","aciTreeChecked"]:"aciTreeCheckbox");var l=a.childrenByClass(k[0].firstChild,"aciTreeText");var j=l.parentNode;var i=d.document.createElement("LABEL");var h=d.document.createElement("SPAN");h.className="aciTreeCheck";i.appendChild(h);i.appendChild(l);j.appendChild(i);k[0].firstChild.setAttribute("aria-checked",!!g.checked)},remove:function(i){a.removeClass(i[0],["aciTreeCheckbox","aciTreeChecked","aciTreeTristate"]);var j=a.childrenByClass(i[0].firstChild,"aciTreeText");var g=j.parentNode;var h=g.parentNode;h.replaceChild(j,g);i[0].firstChild.removeAttribute("aria-checked")},check:function(g,h){a.toggleListClass(g.toArray(),"aciTreeChecked",h,function(i){i.firstChild.setAttribute("aria-checked",h)})},tristate:function(g,h){a.toggleListClass(g.toArray(),"aciTreeTristate",h)}},_checkboxLoad:function(g){if(this._instance.options.checkboxChain===false){return}var h=f;if(this.hasCheckbox(g)){if(this.isChecked(g)){if(!this.checkboxes(this.children(g,false,true),true).length){h=true}}else{h=false}}this._checkboxUpdate(g,h)},_checkboxChildren:function(h){if(this._instance.options.checkboxBreak){var i=[];var j=this.proxy(function(l){var k=this.children(l,false,true);k.each(this.proxy(function(m){var n=e(m);if(this.hasCheckbox(n)){i.push(m);j(n)}},true))});j(h);return e(i)}else{var g=this.children(h,true,true);return this.checkboxes(g)}},_checkboxUpdate:function(j,k){var g=this.proxy(function(p,o,q){var l=this.children(p,false,true);var n=0;var m=0;l.each(this.proxy(function(s){var u=e(s);var t={total:0,checked:0};if(this.hasCheckbox(u)){if((q!==f)&&(this._instance.options.checkboxChain!==-1)){this._checkboxDOM.check(u,q)}n++;if(this.isChecked(u)){m++}g(u,t,q)}else{if(this._instance.options.checkboxBreak){var r={total:0,checked:0};g(u,r)}else{g(u,t,q)}}n+=t.total;m+=t.checked},true));if(p){this._checkboxDOM.tristate(p,(m>0)&&(m!=n));o.total+=n;o.checked+=m}});var i={total:0,checked:0};g(j,i,k);var h=this.proxy(function(p,o,q){var m=this.parent(p);if(m.length){if(!o){var l=this._checkboxChildren(m);var n=this.checkboxes(l,true).length;var o=(n>0)&&(n!=l.length)}if(this.hasCheckbox(m)){if((q!==f)&&(this._instance.options.checkboxChain!==1)){this._checkboxDOM.check(m,o?true:q)}this._checkboxDOM.tristate(m,o);h(m,o,q)}else{if(this._instance.options.checkboxBreak){h(m)}else{h(m,o,q)}}}});h(j,f,k)},hasCheckbox:function(g){return g&&a.hasClass(g[0],"aciTreeCheckbox")},addCheckbox:function(h,g){g=this._options(g,"checkboxadded","addcheckboxfail","wascheckbox",h);if(this.isItem(h)){if(!this._trigger(h,"beforeaddcheckbox",g)){this._fail(h,g);return}if(this.hasCheckbox(h)){this._notify(h,g)}else{var i=function(){this._checkboxDOM.add(h,{});this._success(h,g)};if(this.extRadio&&this.hasRadio(h)){this.removeRadio(h,this._inner(g,{success:i,fail:g.fail}))}else{i.apply(this)}}}else{this._fail(h,g)}},removeCheckbox:function(h,g){g=this._options(g,"checkboxremoved","removecheckboxfail","notcheckbox",h);if(this.isItem(h)){if(!this._trigger(h,"beforeremovecheckbox",g)){this._fail(h,g);return}if(this.hasCheckbox(h)){this._checkboxDOM.remove(h);this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},isChecked:function(g){if(this.hasCheckbox(g)){return a.hasClass(g[0],"aciTreeChecked")}if(this._super){return this._super(g)}return false},check:function(h,g){if(this.extCheckbox&&this.hasCheckbox(h)){g=this._options(g,"checked","checkfail","waschecked",h);if(!this._trigger(h,"beforecheck",g)){this._fail(h,g);return}if(this.isChecked(h)){this._notify(h,g)}else{this._checkboxDOM.check(h,true);if(this._instance.options.checkboxChain!==false){this._checkboxUpdate(h,true)}this._success(h,g)}}else{if(this._super){this._super(h,g)}else{this._trigger(h,"checkfail",g);this._fail(h,g)}}},uncheck:function(h,g){if(this.extCheckbox&&this.hasCheckbox(h)){g=this._options(g,"unchecked","uncheckfail","notchecked",h);if(!this._trigger(h,"beforeuncheck",g)){this._fail(h,g);return}if(this.isChecked(h)){this._checkboxDOM.check(h,false);if(this._instance.options.checkboxChain!==false){this._checkboxUpdate(h,false)}this._success(h,g)}else{this._notify(h,g)}}else{if(this._super){this._super(h,g)}else{this._trigger(h,"uncheckfail",g);this._fail(h,g)}}},checkboxes:function(g,h){if(h!==f){return e(a.withClass(g.toArray(),h?["aciTreeCheckbox","aciTreeChecked"]:"aciTreeCheckbox",h?null:"aciTreeChecked"))}return e(a.withClass(g.toArray(),"aciTreeCheckbox"))},_serialize:function(g,i){var h=this._super(g,i);if(h&&this.extCheckbox()){if(h.hasOwnProperty("checkbox")){h.checkbox=this.hasCheckbox(g);h.checked=this.isChecked(g)}else{if(this.hasCheckbox(g)){if(this.extRadio&&this.extRadio()){h.checkbox=true}h.checked=this.isChecked(g)}}}return h},serialize:function(h,j,k){if(j=="checkbox"){var i="";var g=this.children(h,true,true);this.checkboxes(g,true).each(this.proxy(function(l){var m=e(l);if(k){i+=k.call(this,m,j,this.getId(m))}else{i+=this._instance.options.serialize.call(this,m,j,this.getId(m))}},true));return i}return this._super(h,j,k)},isTristate:function(g){return g&&a.hasClass(g[0],"aciTreeTristate")},tristate:function(g){return e(a.withClass(g.toArray(),"aciTreeTristate"))},extCheckbox:function(){return this._instance.options.checkbox},option:function(g,h){if(this.wasInit()&&!this.isLocked()){if((g=="checkbox")&&(h!=this.extCheckbox())){if(h){this._checkboxInit()}else{this._checkboxDone()}}}this._super(g,h)},_checkboxDone:function(g){this._instance.jQuery.unbind(this._private.nameSpace);this._instance.jQuery.off(this._private.nameSpace,".aciTreeItem");if(!g){this.checkboxes(this.children(null,true,true)).each(this.proxy(function(h){this.removeCheckbox(e(h))},true))}},_destroyHook:function(g){if(g){this._checkboxDone(true)}this._super(g)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(b,"aciTreeCheckbox");aciPluginClass.defaults("aciTree",c);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// radio (works best with selectable)
(function(e,c,f){var b={radio:false,radioChain:true,radioBreak:true,radioClick:false};var d={_radioInit:function(){this._instance.jQuery.bind("acitree"+this._private.nameSpace,function(k,i,j,g,h){switch(g){case"loaded":if(j){i._radioLoad(j)}break}}).bind("keydown"+this._private.nameSpace,this.proxy(function(h){switch(h.which){case 32:if(this.extSelectable&&this.extSelectable()&&!h.ctrlKey){var g=this.focused();if(this.hasRadio(g)&&this.isEnabled(g)){if(!this.isChecked(g)){this.check(g)}h.stopImmediatePropagation();h.preventDefault()}}break}})).on("click"+this._private.nameSpace,".aciTreeItem",this.proxy(function(h){if(!this._instance.options.radioClick||e(h.target).is(".aciTreeCheck")){var g=this.itemFrom(h.target);if(this.hasRadio(g)&&this.isEnabled(g)&&(!this.extSelectable||!this.extSelectable()||(!h.ctrlKey&&!h.shiftKey))){if(!this.isChecked(g)){this.check(g)}h.preventDefault()}}}))},_initHook:function(){if(this.extRadio()){this._radioInit()}this._super()},_itemHook:function(h,i,g,k){if(this.extRadio()){var j=this.extCheckbox&&this.hasCheckbox(i);if(!j&&(g.radio||((g.radio===f)&&(!this.extCheckbox||!this.extCheckbox())))){this._radioDOM.add(i,g)}}this._super(h,i,g,k)},_radioDOM:{add:function(k,g){a.addClass(k[0],g.checked?["aciTreeRadio","aciTreeChecked"]:"aciTreeRadio");var l=a.childrenByClass(k[0].firstChild,"aciTreeText");var j=l.parentNode;var i=c.document.createElement("LABEL");var h=c.document.createElement("SPAN");h.className="aciTreeCheck";i.appendChild(h);i.appendChild(l);j.appendChild(i);k[0].firstChild.setAttribute("aria-checked",!!g.checked)},remove:function(i){a.removeClass(i[0],["aciTreeRadio","aciTreeChecked"]);var j=a.childrenByClass(i[0].firstChild,"aciTreeText");var g=j.parentNode;var h=g.parentNode;h.replaceChild(j,g);i[0].firstChild.removeAttribute("aria-checked")},check:function(g,h){a.toggleListClass(g.toArray(),"aciTreeChecked",h,function(i){i.firstChild.setAttribute("aria-checked",h)})}},_radioLoad:function(g){if(!this._instance.options.radioChain){return}if(this.hasRadio(g)){if(this.isChecked(g)){if(!this.radios(this.children(g,false,true),true).length){this._radioUpdate(g,true)}}else{this._radioUpdate(g)}}},_radioChildren:function(h){if(this._instance.options.radioBreak){var i=[];var j=this.proxy(function(l){var k=this.children(l,false,true);k.each(this.proxy(function(m){var n=e(m);if(this.hasRadio(n)){i.push(m);j(n)}},true))});j(h);return e(i)}else{var g=this.children(h,true,true);return this.radios(g)}},_radioLevel:function(g){var h=[];g.each(this.proxy(function(j){var k=e(j);var i=this.children(k,false,true);i.each(this.proxy(function(l){var m=e(l);if(!this._instance.options.radioBreak||this.hasRadio(m)){h.push(l)}},true))},true));return e(h)},_radioUpdate:function(i,j){var k=this.proxy(function(l){var m=this.siblings(l,true);this._radioDOM.check(this.radios(m),false);m.each(this.proxy(function(n){var o=e(n);if(!this._instance.options.radioBreak||this.hasRadio(o)){this._radioDOM.check(this._radioChildren(o),false)}},true))});if(j){k(i)}var g=this.proxy(function(n){var l=this._radioLevel(n);var o=this.radios(l);if(o.length){var m=this.radios(l,true);if(m.length){m=m.first();this._radioDOM.check(m,true);k(m);g(m)}else{m=o.first();this._radioDOM.check(m,true);k(m);g(m)}}else{if(l.length){g(l)}}});if(j){g(i)}else{this._radioDOM.check(this._radioChildren(i),false)}var h=this.proxy(function(m){var l=this.parent(m);if(l.length){if(this.hasRadio(l)){if(j){k(l)}this._radioDOM.check(l,j);h(l)}else{if(!this._instance.options.radioBreak){if(j){k(l)}h(l)}}}});if(j!==f){h(i)}},hasRadio:function(g){return g&&a.hasClass(g[0],"aciTreeRadio")},addRadio:function(h,g){g=this._options(g,"radioadded","addradiofail","wasradio",h);if(this.isItem(h)){if(!this._trigger(h,"beforeaddradio",g)){this._fail(h,g);return}if(this.hasRadio(h)){this._notify(h,g)}else{var i=function(){this._radioDOM.add(h,{});this._success(h,g)};if(this.extCheckbox&&this.hasCheckbox(h)){this.removeCheckbox(h,this._inner(g,{success:i,fail:g.fail}))}else{i.apply(this)}}}else{this._fail(h,g)}},removeRadio:function(h,g){g=this._options(g,"radioremoved","removeradiofail","notradio",h);if(this.isItem(h)){if(!this._trigger(h,"beforeremoveradio",g)){this._fail(h,g);return}if(this.hasRadio(h)){this._radioDOM.remove(h);this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},isChecked:function(g){if(this.hasRadio(g)){return a.hasClass(g[0],"aciTreeChecked")}if(this._super){return this._super(g)}return false},check:function(h,g){if(this.extRadio&&this.hasRadio(h)){g=this._options(g,"checked","checkfail","waschecked",h);if(!this._trigger(h,"beforecheck",g)){this._fail(h,g);return}if(this.isChecked(h)){this._notify(h,g)}else{this._radioDOM.check(h,true);if(this._instance.options.radioChain){this._radioUpdate(h,true)}this._success(h,g)}}else{if(this._super){this._super(h,g)}else{this._trigger(h,"checkfail",g);this._fail(h,g)}}},uncheck:function(h,g){if(this.extRadio&&this.hasRadio(h)){g=this._options(g,"unchecked","uncheckfail","notchecked",h);if(!this._trigger(h,"beforeuncheck",g)){this._fail(h,g);return}if(this.isChecked(h)){this._radioDOM.check(h,false);if(this._instance.options.radioChain){this._radioUpdate(h,false)}this._success(h,g)}else{this._notify(h,g)}}else{if(this._super){this._super(h,g)}else{this._trigger(h,"uncheckfail",g);this._fail(h,g)}}},radios:function(g,h){if(h!==f){return e(a.withClass(g.toArray(),h?["aciTreeRadio","aciTreeChecked"]:"aciTreeRadio",h?null:"aciTreeChecked"))}return e(a.withClass(g.toArray(),"aciTreeRadio"))},_serialize:function(g,i){var h=this._super(g,i);if(h&&this.extRadio()){if(h.hasOwnProperty("radio")){h.radio=this.hasRadio(g);h.checked=this.isChecked(g)}else{if(this.hasRadio(g)){if(this.extCheckbox&&this.extCheckbox()){h.radio=true}h.checked=this.isChecked(g)}}}return h},serialize:function(h,j,k){if(j=="radio"){var i="";var g=this.children(h,true,true);this.radios(g,true).each(this.proxy(function(l){var m=e(l);if(k){i+=k.call(this,m,j,this.getId(m))}else{i+=this._instance.options.serialize.call(this,m,j,this.getId(m))}},true));return i}return this._super(h,j,k)},extRadio:function(){return this._instance.options.radio},option:function(g,h){if(this.wasInit()&&!this.isLocked()){if((g=="radio")&&(h!=this.extRadio())){if(h){this._radioInit()}else{this._radioDone()}}}this._super(g,h)},_radioDone:function(g){this._instance.jQuery.unbind(this._private.nameSpace);this._instance.jQuery.off(this._private.nameSpace,".aciTreeItem");if(!g){this.radios(this.children(null,true,true)).each(this.proxy(function(h){this.removeRadio(e(h))},true))}},_destroyHook:function(g){if(g){this._radioDone(true)}this._super(g)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(d,"aciTreeRadio");aciPluginClass.defaults("aciTree",b);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// column
(function(e,c,f){var b={columnData:[]};var d={__extend:function(){e.extend(this._private,{propsIndex:{}});this._super()},_initHook:function(){if(this._instance.options.columnData.length){var j=false,h;for(var g in this._instance.options.columnData){h=this._instance.options.columnData[g];if(h.width!==f){this._updateCss(".aciTree.aciTree"+this._instance.index+" .aciTreeColumn"+g,"width:"+h.width+"px;");j=true}this._private.propsIndex[h.props]=g}if(j){this._updateWidth()}}this._super()},_getCss:function(m,p,o){var h="_getCss_"+c.String(m).replace(/[^a-z0-9_-]/ig,"_");var l=e("body").find("#"+h);if(!l.length){if(m instanceof Array){var g="",j="";for(var k in m){g+='<div class="'+m[k]+'">';j+="</div>"}g+=j}else{var g='<div class="'+m+'"></div>'}e("body").append('<div id="'+h+'" style="position:relative;display:inline-block;width:0px;height:0px;line-height:0px;overflow:hidden">'+g+"</div>");l=e("body").find("#"+h)}var n=l.find("*:last").css(p);if(o){n=parseInt(n);if(isNaN(n)){n=null}}return n},_updateCss:function(i,g){var k="_updateCss_"+c.String(i).replace(">","_gt_").replace(/[^a-z0-9_-]/ig,"_");var h='<style id="'+k+'" type="text/css">'+i+"{"+g+"}</style>";var j=e("body").find("#"+k);if(j.length){j.replaceWith(h)}else{e("body").prepend(h)}},getWidth:function(g){if((g>=0)&&(g<this.columns())){return this._getCss(["aciTree aciTree"+this._instance.index,"aciTreeColumn"+g],"width",true)}return null},setWidth:function(g,h){if((g>=0)&&(g<this.columns())){this._updateCss(".aciTree.aciTree"+this._instance.index+" .aciTreeColumn"+g,"width:"+h+"px;");this._updateWidth()}},_updateWidth:function(){var j=0;for(var g in this._instance.options.columnData){if(this.isColumn(g)){j+=this.getWidth(g)}}var h=this._getCss(["aciTree","aciTreeIcon"],"width",true);j+=this._getCss(["aciTree","aciTreeItem"],"padding-left",true)+this._getCss(["aciTree","aciTreeItem"],"padding-right",true);this._updateCss(".aciTree.aciTree"+this._instance.index+" .aciTreeItem","margin-right:"+(h+j)+"px;");this._updateCss(".aciTree[dir=rtl].aciTree"+this._instance.index+" .aciTreeItem","margin-right:0;margin-left:"+(h+j)+"px;")},isColumn:function(g){if((g>=0)&&(g<this.columns())){return this._getCss(["aciTree aciTree"+this._instance.index,"aciTreeColumn"+g],"display")!="none"}return false},columnIndex:function(g){if(this._private.propsIndex[g]!==f){return this._private.propsIndex[g]}return -1},columns:function(){return this._instance.options.columnData.length},toggleColumn:function(h,g){if((h>=0)&&(h<this.columns())){if(g===f){var g=!this.isColumn(h)}this._updateCss(".aciTree.aciTree"+this._instance.index+" .aciTreeColumn"+h,"display:"+(g?"inherit":"none")+";");this._updateWidth()}},_itemHook:function(l,m,h,o){if(this.columns()){var g=a.childrenByClass(m[0].firstChild,"aciTreeEntry"),n,k;for(var j in this._instance.options.columnData){n=this._instance.options.columnData[j];k=this._createColumn(h,n,j);g.insertBefore(k,g.firstChild)}}this._super(l,m,h,o)},_createColumn:function(g,j,h){var k=j.props&&(g[j.props]!==f)?g[j.props]:((j.value===f)?"":j.value);var i=c.document.createElement("DIV");i.className="aciTreeColumn aciTreeColumn"+h;i.innerHTML=k.length?k:"&nbsp;";return i},setColumn:function(h,g){g=this._options(g,"columnset","columnfail","wascolumn",h);if(this.isItem(h)&&(g.index>=0)&&(g.index<this.columns())){if(!this._trigger(h,"beforecolumn",g)){this._fail(h,g);return}var i=this.itemData(h);g.oldValue=i[this._instance.options.columnData[g.index].props];if(g.value==g.oldValue){this._notify(h,g)}else{h.children(".aciTreeLine").find(".aciTreeColumn"+g.index).html(g.value);i[this._instance.options.columnData[g.index].props]=g.value;this._success(h,g)}}else{this._fail(h,g)}},getColumn:function(h,g){if((g>=0)&&(g<this.columns())){var i=this.itemData(h);return i?i[this._instance.options.columnData[g].props]:null}return null}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(d,"aciTreeColumn");aciPluginClass.defaults("aciTree",b);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// editable (works best with selectable)
(function(d,c,f){var b={editable:false,editDelay:250};var e={__extend:function(){d.extend(this._private,{editTimestamp:null});this._super()},_editableInit:function(){this._instance.jQuery.bind("acitree"+this._private.nameSpace,function(k,i,j,g,h){switch(g){case"blurred":var j=i.edited();if(j.length){i.endEdit()}break;case"deselected":if(i.isEdited(j)){i.endEdit()}break}}).bind("click"+this._private.nameSpace,this.proxy(function(){var g=this.edited();if(g.length){this.endEdit()}})).bind("keydown"+this._private.nameSpace,this.proxy(function(h){switch(h.which){case 113:if(this.extSelectable&&this.extSelectable()){var g=this.focused();if(g.length&&!this.isEdited(g)&&this.isEnabled(g)){this.edit(g);h.preventDefault()}}break}})).on("mousedown"+this._private.nameSpace,".aciTreeItem",this.proxy(function(g){if(d(g.target).is(".aciTreeItem,.aciTreeText")){this._private.editTimestamp=d.now()}})).on("mouseup"+this._private.nameSpace,".aciTreeItem",this.proxy(function(h){if(d(h.target).is(".aciTreeItem,.aciTreeText")){var i=d.now()-this._private.editTimestamp;if((i>this._instance.options.editDelay)&&(i<this._instance.options.editDelay*4)){var g=this.itemFrom(h.target);if((!this.extSelectable||!this.extSelectable()||(this.isFocused(g)&&(this.selected().length==1)))&&this.isEnabled(g)){this.edit(g)}}}})).on("keydown"+this._private.nameSpace,"input[type=text]",this.proxy(function(g){switch(g.which){case 13:this.itemFrom(g.target).focus();this.endEdit();g.stopPropagation();break;case 27:this.itemFrom(g.target).focus();this.endEdit({save:false});g.stopPropagation();g.preventDefault();break;case 38:case 40:case 37:case 39:case 33:case 34:case 36:case 35:case 32:case 107:case 109:case 106:g.stopPropagation();break}})).on("blur"+this._private.nameSpace,"input[type=text]",this.proxy(function(){if(!this.extSelectable||!this.extSelectable()){this.endEdit()}})).on("click"+this._private.nameSpace+" dblclick"+this._private.nameSpace,"input[type=text]",function(g){g.stopPropagation()})},_initHook:function(){if(this.extEditable()){this._editableInit()}this._super()},_editableDOM:{add:function(h){var g=h.addClass("aciTreeEdited").children(".aciTreeLine");g.find(".aciTreeText").html('<input id="aciTree-editable-tree-item" type="text" value="" style="-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;-o-user-select:text;user-select:text" />');g.find("label").attr("for","aciTree-editable-tree-item");this._editableDOM.get(h).val(this.getLabel(h))},remove:function(i,h){var g=i.removeClass("aciTreeEdited").children(".aciTreeLine");g.find(".aciTreeText").html(this.getLabel(i));g.find("label").removeAttr("for")},get:function(g){return g?g.children(".aciTreeLine").find("input[type=text]"):d([])}},edited:function(){return this._instance.jQuery.find(".aciTreeEdited")},isEdited:function(g){return g&&a.hasClass(g[0],"aciTreeEdited")},_focusEdit:function(h){var i=this._editableDOM.get(h).focus().trigger("click")[0];if(i){if(typeof i.selectionStart=="number"){i.selectionStart=i.selectionEnd=i.value.length}else{if(i.createTextRange!==f){var g=i.createTextRange();g.collapse(false);g.select()}}}},setLabel:function(h,g){if(!this.extEditable()||!this.isEdited(h)){this._super(h,g)}},edit:function(h,g){g=this._options(g,"edit","editfail","wasedit",h);if(this.extEditable()&&this.isItem(h)){if(!this._trigger(h,"beforeedit",g)){this._fail(h,g);return}var i=this.edited();if(i.length){if(i[0]==h[0]){this._notify(h,g);return}else{this._editableDOM.remove.call(this,i);this._trigger(i,"endedit",g)}}this._editableDOM.add.call(this,h);this._focusEdit(h);this._success(h,g)}else{this._fail(h,g)}},endEdit:function(g){var h=this.edited();g=this._options(g,"edited","endeditfail","endedit",h);if(this.extEditable()&&this.isItem(h)){if(!this._trigger(h,"beforeendedit",g)){this._fail(h,g);return}var i=this._editableDOM.get(h).val();this._editableDOM.remove.call(this,h);if((g.save===f)||g.save){this.setLabel(h,{label:i});this._success(h,g)}else{this._notify(h,g)}}else{this._fail(h,g)}},extEditable:function(){return this._instance.options.editable},option:function(g,h){if(this.wasInit()&&!this.isLocked()){if((g=="editable")&&(h!=this.extEditable())){if(h){this._editableInit()}else{this._editableDone()}}}this._super(g,h)},_editableDone:function(){this._instance.jQuery.unbind(this._private.nameSpace);this._instance.jQuery.off(this._private.nameSpace,".aciTreeItem");this._instance.jQuery.off(this._private.nameSpace,"input[type=text]");var g=this.edited();if(g.length){this.endEdit()}},_destroyHook:function(g){if(g){this._editableDone()}this._super(g)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(e,"aciTreeEditable");aciPluginClass.defaults("aciTree",b);var a=aciPluginClass.plugins.aciTree_dom})(jQuery,this);

// persist (require utils extension & jStorage plugin)
(function(c,b,e){var a={persist:null};var d={__extend:function(){c.extend(this._private,{selectTimeout:null,focusTimeout:null,openTimeout:null});this._super()},_initPersist:function(){this._instance.jQuery.bind("acitree"+this._private.nameSpace,function(j,h,i,f,g){if(g.uid=="ui.persist"){return}switch(f){case"init":h._persistRestore();break;case"selected":case"deselected":h._persistLater("selected");break;case"focus":case"blur":h._persistLater("focused");break;case"opened":case"closed":h._persistLater("opened");break}})},_initHook:function(){if(this.extPersist()){this._initPersist()}this._super()},_persistLater:function(f){switch(f){case"selected":b.clearTimeout(this._private.selectTimeout);this._private.selectTimeout=b.setTimeout(this.proxy(function(){this._persistSelected()}),250);break;case"focused":b.clearTimeout(this._private.focusTimeout);this._private.focusTimeout=b.setTimeout(this.proxy(function(){this._persistFocused()}),250);break;case"opened":b.clearTimeout(this._private.openTimeout);this._private.openTimeout=b.setTimeout(this.proxy(function(){this._persistOpened()}),250);break}},_persistRestore:function(){var f=new this._queue(this,this._instance.options.queue);var g=new this._task(f,function(k){if(this.extSelectable&&this.extSelectable()){var m=c.jStorage.get("aciTree_"+this._instance.options.persist+"_selected");if(m instanceof Array){for(var l in m){(function(i){f.push(function(o){this.searchPath(null,{success:function(p){this.select(p,{uid:"ui.persist",success:function(){o()},fail:o,focus:false})},fail:o,path:i.split(";")})})})(m[l]);if(!this._instance.options.multiSelectable){break}}}var n=c.jStorage.get("aciTree_"+this._instance.options.persist+"_focused");if(n instanceof Array){for(var l in n){(function(i){f.push(function(o){this.searchPath(null,{success:function(p){this.focus(p,{uid:"ui.persist",success:function(q){this.setVisible(q,{center:true});o()},fail:o})},fail:o,path:i.split(";")})})})(n[l])}}}k()});var j=c.jStorage.get("aciTree_"+this._instance.options.persist+"_opened");if(j instanceof Array){for(var h in j){(function(i){g.push(function(k){this.searchPath(null,{success:function(l){this.open(l,{uid:"ui.persist",success:k,fail:k})},fail:k,path:i.split(";"),load:true})})})(j[h])}}},_persistSelected:function(){if(this.extSelectable&&this.extSelectable()){var f=[];this.selected().each(this.proxy(function(g){var h=c(g);var i=this.pathId(h);i.push(this.getId(h));f.push(i.join(";"))},true));c.jStorage.set("aciTree_"+this._instance.options.persist+"_selected",f)}},_persistFocused:function(){if(this.extSelectable&&this.extSelectable()){var f=[];this.focused().each(this.proxy(function(g){var h=c(g);var i=this.pathId(h);i.push(this.getId(h));f.push(i.join(";"))},true));c.jStorage.set("aciTree_"+this._instance.options.persist+"_focused",f)}},_persistOpened:function(){var f=[];this.inodes(this.children(null,true),true).each(this.proxy(function(g){var h=c(g);if(this.isOpenPath(h)){var i=this.pathId(h);i.push(this.getId(h));f.push(i.join(";"))}},true));c.jStorage.set("aciTree_"+this._instance.options.persist+"_opened",f)},isPersist:function(){if(this.extPersist()){var f=c.jStorage.get("aciTree_"+this._instance.options.persist+"_selected");if(f instanceof Array){return true}var g=c.jStorage.get("aciTree_"+this._instance.options.persist+"_focused");if(g instanceof Array){return true}var h=c.jStorage.get("aciTree_"+this._instance.options.persist+"_opened");if(h instanceof Array){return true}}return false},unpersist:function(){if(this.extPersist()){c.jStorage.deleteKey("aciTree_"+this._instance.options.persist+"_selected");c.jStorage.deleteKey("aciTree_"+this._instance.options.persist+"_focused");c.jStorage.deleteKey("aciTree_"+this._instance.options.persist+"_opened")}},extPersist:function(){return this._instance.options.persist},option:function(f,h){var g=this.extPersist();this._super(f,h);if(this.extPersist()!=g){if(g){this._donePersist()}else{this._initPersist()}}},_donePersist:function(){this._instance.jQuery.unbind(this._private.nameSpace)},_destroyHook:function(f){if(f){this._donePersist()}this._super(f)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(d,"aciTreePersist");aciPluginClass.defaults("aciTree",a)})(jQuery,this);

// hash (require utils extension & aciFragment plugin)
(function(d,c,e){var a={selectHash:null,openHash:null};var b={__extend:function(){d.extend(this._private,{lastSelect:null,lastOpen:null,hashApi:null});this._super()},_hashInit:function(){this._instance.jQuery.aciFragment();this._private.hashApi=this._instance.jQuery.aciFragment("api");this._instance.jQuery.bind("acitree"+this._private.nameSpace,function(j,h,i,f,g){switch(f){case"init":h._hashRestore();break}}).bind("acifragment"+this._private.nameSpace,this.proxy(function(h,g,f){h.stopPropagation();this._hashRestore()}))},_initHook:function(){if(this.extHast()){this._hashInit()}this._super()},_hashRestore:function(){var f=this._instance.queue;var i=function(l){for(var k in l){(function(m){f.push(function(n){this.search(null,{success:function(o){this.open(o,{uid:"ui.hash",success:n,fail:n})},fail:n,search:m})})})(l[k])}};if(this._instance.options.openHash){var h=this._private.hashApi.get(this._instance.options.openHash,"");if(h.length&&(h!=this._private.lastOpen)){this._private.lastOpen=h;var j=h.split(";");i(j)}}if(this._instance.options.selectHash&&this.extSelectable&&this.extSelectable()){var h=this._private.hashApi.get(this._instance.options.selectHash,"");if(h.length&&(h!=this._private.lastSelect)){this._private.lastSelect=h;var j=h.split(";");var g=j.pop();i(j);if(g){f.push(function(k){this.search(null,{success:function(l){this.select(l,{uid:"ui.hash",success:function(m){this.setVisible(m,{center:true});k()},fail:k})},fail:k,search:g})})}}}},extHast:function(){return this._instance.options.selectHash||this._instance.options.openHash},option:function(f,g){var h=this.extHast();this._super(f,g);if(this.extHast()!=h){if(h){this._hashDone()}else{this._hashInit()}}},_hashDone:function(){this._instance.jQuery.unbind(this._private.nameSpace);this._private.hashApi=null;this._instance.jQuery.aciFragment("destroy")},_destroyHook:function(f){if(f){this._hashDone()}this._super(f)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(b,"aciTreeHash");aciPluginClass.defaults("aciTree",a)})(jQuery,this);

// sortable (require utils extension & aciSortable plugin)
(function(d,c,e){var a={sortable:false,sortDelay:750,sortDrag:function(g,i,h,f){if(!h){f.html(this.getLabel(g))}},sortValid:function(j,h,k,g,l,i){var f=this.getLabel(j);if(this._private.dragDrop.length>1){f+=" and #"+(this._private.dragDrop.length-1)+" more"}if(g){i.html("move "+f+" to "+this.getLabel(this.itemFrom(h)));l.removeClass("aciTreeAfter aciTreeBefore")}else{if(k!==null){if(k){i.html("move "+f+" before "+this.getLabel(h));l.removeClass("aciTreeAfter").addClass("aciTreeBefore")}else{i.html("move "+f+" after "+this.getLabel(h));l.removeClass("aciTreeBefore").addClass("aciTreeAfter")}}}}};var b={__extend:function(){d.extend(this._private,{openTimeout:null,dragDrop:null});this._super()},_sortableInit:function(){this._instance.jQuery.aciSortable({container:".aciTreeUl",item:".aciTreeLi",child:50,childHolder:'<ul class="aciTreeUl aciTreeChild"></ul>',childHolderSelector:".aciTreeChild",placeholder:'<li class="aciTreeLi aciTreePlaceholder"><div></div></li>',placeholderSelector:".aciTreePlaceholder",helper:'<div class="aciTreeHelper"></div>',helperSelector:".aciTreeHelper",before:this.proxy(function(f){if(!this._initDrag(f)){return false}if(!this._trigger(f,"beforedrag")){this._trigger(f,"dragfail");return false}return true}),start:this.proxy(function(g,h,f){this._instance.jQuery.addClass("aciTreeDragDrop");f.css({opacity:1}).html(this.getLabel(g))}),drag:this.proxy(function(g,i,h,f){if(!h){c.clearTimeout(this._private.openTimeout)}if(this._instance.options.sortDrag){this._instance.options.sortDrag.apply(this,arguments)}}),valid:this.proxy(function(j,h,k,g,l,i){c.clearTimeout(this._private.openTimeout);if(!this._checkDrop(j,h,k,g,l,i)){return false}var f=this._options({hover:h,before:k,isContainer:g,placeholder:l,helper:i});if(!this._trigger(j,"checkdrop",f)){return false}if(!g&&this.isInode(h)){if(!this.isOpen(h)&&!h.data("opening"+this._private.nameSpace)){this._private.openTimeout=c.setTimeout(this.proxy(function(){h.data("opening"+this._private.nameSpace,true);this.open(h,{success:function(m){m.removeData("opening"+this._private.nameSpace)},fail:function(m){m.removeData("opening"+this._private.nameSpace)}})}),this._instance.options.sortDelay)}}if(this._instance.options.sortValid){this._instance.options.sortValid.apply(this,arguments)}return true}),create:this.proxy(function(g,h,f){if(this.isLeaf(f)){f.append(g._instance.options.childHolder);return true}return false},true),end:this.proxy(function(q,k,p,g){c.clearTimeout(this._private.openTimeout);var r={placeholder:p,helper:g};r=this._options(r,"sorted","dropfail",null,q);if(p.parent().length){var i=this.prev(p,true);if(i.length){p.detach();var l=d(this._private.dragDrop.get().reverse());this._private.dragDrop=null;l.each(this.proxy(function(s){this.moveAfter(d(s),this._inner(r,{success:r.success,fail:r.fail,after:i}))},true))}else{var j=this.next(p,true);if(j.length){p.detach();var l=d(this._private.dragDrop.get().reverse());this._private.dragDrop=null;l.each(this.proxy(function(s){this.moveBefore(d(s),this._inner(r,{success:r.success,fail:r.fail,before:j}))},true))}else{var o=this.parent(p);var f=p.parent();p.detach();f.remove();if(this.isLeaf(o)){var l=this._private.dragDrop;this.asChild(l.eq(0),this._inner(r,{success:function(){this._success(q,r);this.open(o);l.filter(":gt(0)").each(this.proxy(function(s){this.moveAfter(d(s),this._inner(r,{success:r.success,fail:r.fail,after:this.last(o)}))},true))},fail:r.fail,parent:o}))}else{this._fail(q,r)}}}}else{this._fail(q,r)}this._private.dragDrop=null;if(g.parent().length){var n=d(c).scrollTop();var h=d(c).scrollLeft();var m=q[0].getBoundingClientRect();g.animate({top:m.top+n,left:m.left+h,opacity:0},{complete:function(){g.detach()}})}this._instance.jQuery.removeClass("aciTreeDragDrop")})})},_initHook:function(){if(this.extSortable()){this._sortableInit()}this._super()},_parents:function(l){var h=l.length,k,g,f=[];for(var n=0;n<h-1;n++){k=l.eq(n);for(var m=n+1;m<h;m++){g=l.eq(m);if(this.isChildren(k,g)){f.push(l[m])}else{if(this.isChildren(g,k)){f.push(l[n])}}}}return l.not(f)},_initDrag:function(g){if(this.extSelectable&&this.extSelectable()){if(!this.hasFocus()){this._instance.jQuery.focus()}if(!this.isEnabled(g)){return false}var f=this.selected();if(f.length){if(!this.isSelected(g)){return false}}else{f=g}this._private.dragDrop=this._parents(f)}else{this._instance.jQuery.focus();this._private.dragDrop=g}return true},_checkDrop:function(j,h,k,g,l,i){var f=this._private.dragDrop;if(!f){return false}var m=this.itemFrom(h);if(f.is(m)||f.has(m[0]).length){return false}if(!g){m=k?this.prev(h):this.next(h);if(f.is(m)){return false}}return true},extSortable:function(){return this._instance.options.sortable},option:function(f,g){if(this.wasInit()&&!this.isLocked()){if((f=="sortable")&&(g!=this.extSortable())){if(g){this._sortableInit()}else{this._sortableDone()}}}this._super(f,g)},_sortableDone:function(){this._instance.jQuery.unbind(this._private.nameSpace);this._instance.jQuery.aciSortable("destroy")},_destroyHook:function(f){if(f){this._sortableDone()}this._super(f)}};aciPluginClass.plugins.aciTree=aciPluginClass.plugins.aciTree.extend(b,"aciTreeSortable");aciPluginClass.defaults("aciTree",a)})(jQuery,this);

/**
 * Handsontable 0.11.0-beta3
 * Handsontable is a simple jQuery plugin for editable tables with basic copy-paste compatibility with Excel and Google Docs
 *
 * Copyright 2012-2014 Marcin Warpechowski
 * Licensed under the MIT license.
 * http://handsontable.com/
 *
 * Date: Fri Jul 25 2014 11:41:59 GMT+0200 (CEST)
 */
/*jslint white: true, browser: true, plusplus: true, indent: 4, maxerr: 50 */

var Handsontable = { //class namespace
  plugins: {}, //plugin namespace
  helper: {} //helper namespace
};

(function ($, window, Handsontable) {
  "use strict";
//http://stackoverflow.com/questions/3629183/why-doesnt-indexof-work-on-an-array-ie8
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (elt /*, from*/) {
    var len = this.length >>> 0;

    var from = Number(arguments[1]) || 0;
    from = (from < 0)
      ? Math.ceil(from)
      : Math.floor(from);
    if (from < 0)
      from += len;

    for (; from < len; from++) {
      if (from in this &&
        this[from] === elt)
        return from;
    }
    return -1;
  };
}
/**
 * Array.filter() shim by Trevor Menagh (https://github.com/trevmex) with some modifications
 */

if (!Array.prototype.filter) {
  Array.prototype.filter = function (fun, thisp) {
    "use strict";

    if (typeof this === "undefined" || this === null) {
      throw new TypeError();
    }
    if (typeof fun !== "function") {
      throw new TypeError();
    }

    thisp = thisp || this;

    if (isNodeList(thisp)) {
      thisp = convertNodeListToArray(thisp);
    }

    var len = thisp.length,
      res = [],
      i,
      val;

    for (i = 0; i < len; i += 1) {
      if (thisp.hasOwnProperty(i)) {
        val = thisp[i]; // in case fun mutates this
        if (fun.call(thisp, val, i, thisp)) {
          res.push(val);
        }
      }
    }

    return res;

    function isNodeList(object) {
      return /NodeList/i.test(object.item);
    }

    function convertNodeListToArray(nodeList) {
      var array = [];

      for (var i = 0, len = nodeList.length; i < len; i++){
        array[i] = nodeList[i]
      }

      return array;
    }
  };
}

/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

if (typeof WeakMap === 'undefined') {
  (function() {
    var defineProperty = Object.defineProperty;

    try {
      var properDefineProperty = true;
      defineProperty(function(){}, 'foo', {});
    } catch (e) {
      properDefineProperty = false;
    }

    /*
      IE8 does not support Date.now() but IE8 compatibility mode in IE9 and IE10 does.
      M$ deserves a high five for this one :)
     */
    var counter = +(new Date) % 1e9;

    var WeakMap = function() {
      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
      if(!properDefineProperty){
        this._wmCache = [];
      }
    };

    if(properDefineProperty){
      WeakMap.prototype = {
        set: function(key, value) {
          var entry = key[this.name];
          if (entry && entry[0] === key)
            entry[1] = value;
          else
            defineProperty(key, this.name, {value: [key, value], writable: true});

        },
        get: function(key) {
          var entry;
          return (entry = key[this.name]) && entry[0] === key ?
            entry[1] : undefined;
        },
        'delete': function(key) {
          this.set(key, undefined);
        }
      };
    } else {
      WeakMap.prototype = {
        set: function(key, value) {

          if(typeof key == 'undefined' || typeof value == 'undefined') return;

          for(var i = 0, len = this._wmCache.length; i < len; i++){
            if(this._wmCache[i].key == key){
              this._wmCache[i].value = value;
              return;
            }
          }

          this._wmCache.push({key: key, value: value});

        },
        get: function(key) {

          if(typeof key == 'undefined') return;

          for(var i = 0, len = this._wmCache.length; i < len; i++){
            if(this._wmCache[i].key == key){
              return  this._wmCache[i].value;
            }
          }

          return;

        },
        'delete': function(key) {

          if(typeof key == 'undefined') return;

          for(var i = 0, len = this._wmCache.length; i < len; i++){
            if(this._wmCache[i].key == key){
              Array.prototype.slice.call(this._wmCache, i, 1);
            }
          }
        }
      };
    }

    window.WeakMap = WeakMap;
  })();
}

Handsontable.activeGuid = null;

/**
 * Handsontable constructor
 * @param rootElement The jQuery element in which Handsontable DOM will be inserted
 * @param userSettings
 * @constructor
 */
Handsontable.Core = function (rootElement, userSettings) {
  var priv
    , datamap
    , grid
    , selection
    , editorManager
    , instance = this
    , GridSettings = function () {};

  Handsontable.helper.extend(GridSettings.prototype, DefaultSettings.prototype); //create grid settings as a copy of default settings
  Handsontable.helper.extend(GridSettings.prototype, userSettings); //overwrite defaults with user settings
  Handsontable.helper.extend(GridSettings.prototype, expandType(userSettings));

  this.rootElement = rootElement;

  this.container = document.createElement('DIV');
  this.container.className = 'htContainer';
  rootElement.prepend(this.container);
  this.container = $(this.container);

  var $document = $(document.documentElement);
  var $body = $(document.body);
  this.guid = 'ht_' + Handsontable.helper.randomString(); //this is the namespace for global events

  if (!this.rootElement[0].id) {
    this.rootElement[0].id = this.guid; //if root element does not have an id, assign a random id
  }

  priv = {
    cellSettings: [],
    columnSettings: [],
    columnsSettingConflicts: ['data', 'width'],
    settings: new GridSettings(), // current settings instance
    selRange: null, //exposed by public method `getSelectedRange`
    isPopulated: null,
    scrollable: null,
    firstRun: true
  };

  grid = {
    /**
     * Inserts or removes rows and columns
     * @param {String} action Possible values: "insert_row", "insert_col", "remove_row", "remove_col"
     * @param {Number} index
     * @param {Number} amount
     * @param {String} [source] Optional. Source of hook runner.
     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
     */
    alter: function (action, index, amount, source, keepEmptyRows) {
      var delta;

      amount = amount || 1;

      switch (action) {
        case "insert_row":
          delta = datamap.createRow(index, amount);

          if (delta) {
            if (selection.isSelected() && priv.selRange.from.row >= index) {
              priv.selRange.from.row = priv.selRange.from.row + delta;
              selection.transformEnd(delta, 0); //will call render() internally
            }
            else {
              selection.refreshBorders(); //it will call render and prepare methods
            }
          }
          break;

        case "insert_col":
          delta = datamap.createCol(index, amount);

          if (delta) {

            if(Handsontable.helper.isArray(instance.getSettings().colHeaders)){
              var spliceArray = [index, 0];
              spliceArray.length += delta; //inserts empty (undefined) elements at the end of an array
              Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArray); //inserts empty (undefined) elements into the colHeader array
            }

            if (selection.isSelected() && priv.selRange.from.col >= index) {
              priv.selRange.from.col = priv.selRange.from.col + delta;
              selection.transformEnd(0, delta); //will call render() internally
            }
            else {
              selection.refreshBorders(); //it will call render and prepare methods
            }
          }
          break;

        case "remove_row":
          datamap.removeRow(index, amount);
          priv.cellSettings.splice(index, amount);
          grid.adjustRowsAndCols();
          selection.refreshBorders(); //it will call render and prepare methods
          break;

        case "remove_col":
          datamap.removeCol(index, amount);

          for(var row = 0, len = datamap.getAll().length; row < len; row++){
            if(row in priv.cellSettings){  //if row hasn't been rendered it wouldn't have cellSettings
              priv.cellSettings[row].splice(index, amount);
            }
          }

          if(Handsontable.helper.isArray(instance.getSettings().colHeaders)){
            if(typeof index == 'undefined'){
              index = -1;
            }
            instance.getSettings().colHeaders.splice(index, amount);
          }

          priv.columnSettings.splice(index, amount);

          grid.adjustRowsAndCols();
          selection.refreshBorders(); //it will call render and prepare methods
          break;

        default:
          throw new Error('There is no such action "' + action + '"');
          break;
      }

      if (!keepEmptyRows) {
        grid.adjustRowsAndCols(); //makes sure that we did not add rows that will be removed in next refresh
      }
    },

    /**
     * Makes sure there are empty rows at the bottom of the table
     */
    adjustRowsAndCols: function () {
      var r, rlen, emptyRows, emptyCols;

      //should I add empty rows to data source to meet minRows?
      rlen = instance.countRows();
      if (rlen < priv.settings.minRows) {
        for (r = 0; r < priv.settings.minRows - rlen; r++) {
          datamap.createRow(instance.countRows(), 1, true);
        }
      }

      emptyRows = instance.countEmptyRows(true);

      //should I add empty rows to meet minSpareRows?
      if (emptyRows < priv.settings.minSpareRows) {
        for (; emptyRows < priv.settings.minSpareRows && instance.countRows() < priv.settings.maxRows; emptyRows++) {
          datamap.createRow(instance.countRows(), 1, true);
        }
      }

      //count currently empty cols
      emptyCols = instance.countEmptyCols(true);

      //should I add empty cols to meet minCols?
      if (!priv.settings.columns && instance.countCols() < priv.settings.minCols) {
        for (; instance.countCols() < priv.settings.minCols; emptyCols++) {
          datamap.createCol(instance.countCols(), 1, true);
        }
      }

      //should I add empty cols to meet minSpareCols?
      if (!priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols) {
        for (; emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols; emptyCols++) {
          datamap.createCol(instance.countCols(), 1, true);
        }
      }

      // if (priv.settings.enterBeginsEditing) {
      //   for (; (((priv.settings.minRows || priv.settings.minSpareRows) && instance.countRows() > priv.settings.minRows) && (priv.settings.minSpareRows && emptyRows > priv.settings.minSpareRows)); emptyRows--) {
      //     datamap.removeRow();
      //   }
      // }

      // if (priv.settings.enterBeginsEditing && !priv.settings.columns) {
      //   for (; (((priv.settings.minCols || priv.settings.minSpareCols) && instance.countCols() > priv.settings.minCols) && (priv.settings.minSpareCols && emptyCols > priv.settings.minSpareCols)); emptyCols--) {
      //     datamap.removeCol();
      //   }
      // }

      var rowCount = instance.countRows();
      var colCount = instance.countCols();

      if (rowCount === 0 || colCount === 0) {
        selection.deselect();
      }

      if (selection.isSelected()) {
        var selectionChanged;
        var fromRow = priv.selRange.from.row;
        var fromCol = priv.selRange.from.col;
        var toRow = priv.selRange.to.row;
        var toCol = priv.selRange.to.col;

        //if selection is outside, move selection to last row
        if (fromRow > rowCount - 1) {
          fromRow = rowCount - 1;
          selectionChanged = true;
          if (toRow > fromRow) {
            toRow = fromRow;
          }
        } else if (toRow > rowCount - 1) {
          toRow = rowCount - 1;
          selectionChanged = true;
          if (fromRow > toRow) {
            fromRow = toRow;
          }
        }

        //if selection is outside, move selection to last row
        if (fromCol > colCount - 1) {
          fromCol = colCount - 1;
          selectionChanged = true;
          if (toCol > fromCol) {
            toCol = fromCol;
          }
        } else if (toCol > colCount - 1) {
          toCol = colCount - 1;
          selectionChanged = true;
          if (fromCol > toCol) {
            fromCol = toCol;
          }
        }

        if (selectionChanged) {
          instance.selectCell(fromRow, fromCol, toRow, toCol);
        }
      }
    },

    /**
     * Populate cells at position with 2d array
     * @param {Object} start Start selection position
     * @param {Array} input 2d array
     * @param {Object} [end] End selection position (only for drag-down mode)
     * @param {String} [source="populateFromArray"]
     * @param {String} [method="overwrite"]
     * @return {Object|undefined} ending td in pasted area (only if any cell was changed)
     */
    populateFromArray: function (start, input, end, source, method) {
      var r, rlen, c, clen, setData = [], current = {};
      rlen = input.length;
      if (rlen === 0) {
        return false;
      }

      var repeatCol
        , repeatRow
        , cmax
        , rmax;

      // insert data with specified pasteMode method
      switch (method) {
        case 'shift_down' :
          repeatCol = end ? end.col - start.col + 1 : 0;
          repeatRow = end ? end.row - start.row + 1 : 0;
          input = Handsontable.helper.translateRowsToColumns(input);
          for (c = 0, clen = input.length, cmax = Math.max(clen, repeatCol); c < cmax; c++) {
            if (c < clen) {
              for (r = 0, rlen = input[c].length; r < repeatRow - rlen; r++) {
                input[c].push(input[c][r % rlen]);
              }
              input[c].unshift(start.col + c, start.row, 0);
              instance.spliceCol.apply(instance, input[c]);
            }
            else {
              input[c % clen][0] = start.col + c;
              instance.spliceCol.apply(instance, input[c % clen]);
            }
          }
          break;

        case 'shift_right' :
          repeatCol = end ? end.col - start.col + 1 : 0;
          repeatRow = end ? end.row - start.row + 1 : 0;
          for (r = 0, rlen = input.length, rmax = Math.max(rlen, repeatRow); r < rmax; r++) {
            if (r < rlen) {
              for (c = 0, clen = input[r].length; c < repeatCol - clen; c++) {
                input[r].push(input[r][c % clen]);
              }
              input[r].unshift(start.row + r, start.col, 0);
              instance.spliceRow.apply(instance, input[r]);
            }
            else {
              input[r % rlen][0] = start.row + r;
              instance.spliceRow.apply(instance, input[r % rlen]);
            }
          }
          break;

        case 'overwrite' :
        default:
          // overwrite and other not specified options
          current.row = start.row;
          current.col = start.col;
          for (r = 0; r < rlen; r++) {
            if ((end && current.row > end.row) || (!priv.settings.minSpareRows && current.row > instance.countRows() - 1) || (current.row >= priv.settings.maxRows)) {
              break;
            }
            current.col = start.col;
            clen = input[r] ? input[r].length : 0;
            for (c = 0; c < clen; c++) {
              if ((end && current.col > end.col) || (!priv.settings.minSpareCols && current.col > instance.countCols() - 1) || (current.col >= priv.settings.maxCols)) {
                break;
              }
              if (!instance.getCellMeta(current.row, current.col).readOnly) {
                setData.push([current.row, current.col, input[r][c]]);
              }
              current.col++;
              if (end && c === clen - 1) {
                c = -1;
              }
            }
            current.row++;
            if (end && r === rlen - 1) {
              r = -1;
            }
          }
          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');
          break;
      }
    }
  };

  this.selection = selection = { //this public assignment is only temporary
    inProgress: false,

    /**
     * Sets inProgress to true. This enables onSelectionEnd and onSelectionEndByProp to function as desired
     */
    begin: function () {
      instance.selection.inProgress = true;
    },

    /**
     * Sets inProgress to false. Triggers onSelectionEnd and onSelectionEndByProp
     */
    finish: function () {
      var sel = instance.getSelected();
      Handsontable.hooks.run(instance, "afterSelectionEnd", sel[0], sel[1], sel[2], sel[3]);
      Handsontable.hooks.run(instance, "afterSelectionEndByProp", sel[0], instance.colToProp(sel[1]), sel[2], instance.colToProp(sel[3]));
      instance.selection.inProgress = false;
    },

    isInProgress: function () {
      return instance.selection.inProgress;
    },

    /**
     * Starts selection range on given td object
     * @param {WalkontableCellCoords} coords
     */
    setRangeStart: function (coords) {
      Handsontable.hooks.run(instance, "beforeSetRangeStart", coords);
      priv.selRange = new WalkontableCellRange(coords, coords, coords);
      selection.setRangeEnd(coords);
    },

    /**
     * Ends selection range on given td object
     * @param {WalkontableCellCoords} coords
     * @param {Boolean} [scrollToCell=true] If true, viewport will be scrolled to range end
     */
    setRangeEnd: function (coords, scrollToCell) {
      //trigger handlers
      Handsontable.hooks.run(instance, "beforeSetRangeEnd", coords);

      instance.selection.begin();

      priv.selRange.to = coords;
      if (!priv.settings.multiSelect) {
        priv.selRange.from = coords;
      }

      //set up current selection
      instance.view.wt.selections.current.clear();
      instance.view.wt.selections.current.add(priv.selRange.highlight);

      //set up area selection
      instance.view.wt.selections.area.clear();
      if (selection.isMultiple()) {
        instance.view.wt.selections.area.add(priv.selRange.from);
        instance.view.wt.selections.area.add(priv.selRange.to);
      }

      //set up highlight
      if (priv.settings.currentRowClassName || priv.settings.currentColClassName) {
        instance.view.wt.selections.highlight.clear();
        instance.view.wt.selections.highlight.add(priv.selRange.from);
        instance.view.wt.selections.highlight.add(priv.selRange.to);
      }

      //trigger handlers
      Handsontable.hooks.run(instance, "afterSelection", priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col);
      Handsontable.hooks.run(instance, "afterSelectionByProp", priv.selRange.from.row, datamap.colToProp(priv.selRange.from.col), priv.selRange.to.row, datamap.colToProp(priv.selRange.to.col));

      if (scrollToCell !== false && instance.view.mainViewIsActive()) {
        instance.view.scrollViewport(coords);
      }
      selection.refreshBorders();
    },

    /**
     * Destroys editor, redraws borders around cells, prepares editor
     * @param {Boolean} revertOriginal
     * @param {Boolean} keepEditor
     */
    refreshBorders: function (revertOriginal, keepEditor) {
      if (!keepEditor) {
        editorManager.destroyEditor(revertOriginal);
      }
      instance.view.render();
      if (selection.isSelected() && !keepEditor) {
        editorManager.prepareEditor();
      }
    },

    /**
     * Returns information if we have a multiselection
     * @return {Boolean}
     */
    isMultiple: function () {
      return !(priv.selRange.to.col === priv.selRange.from.col && priv.selRange.to.row === priv.selRange.from.row);
    },

    /**
     * Selects cell relative to current cell (if possible)
     */
    transformStart: function (rowDelta, colDelta, force) {
      var delta = new WalkontableCellCoords(rowDelta, colDelta);
      instance.runHooks('modifyTransformStart', delta);

      if (priv.selRange.highlight.row + rowDelta > instance.countRows() - 1) {
        if (force && priv.settings.minSpareRows > 0) {
          instance.alter("insert_row", instance.countRows());
        }
        else if (priv.settings.autoWrapCol) {
          delta.row = 1 - instance.countRows();
          delta.col = priv.selRange.highlight.col + delta.col == instance.countCols() - 1 ? 1 - instance.countCols() : 1;
        }
      }
      else if (priv.settings.autoWrapCol && priv.selRange.highlight.row + delta.row < 0 && priv.selRange.highlight.col + delta.col >= 0) {
        delta.row = instance.countRows() - 1;
        delta.col = priv.selRange.highlight.col + delta.col == 0 ? instance.countCols() - 1 : -1;
      }

      if (priv.selRange.highlight.col + delta.col > instance.countCols() - 1) {
        if (force && priv.settings.minSpareCols > 0) {
          instance.alter("insert_col", instance.countCols());
        }
        else if (priv.settings.autoWrapRow) {
          delta.row = priv.selRange.highlight.row + delta.row == instance.countRows() - 1 ? 1 - instance.countRows() : 1;
          delta.col = 1 - instance.countCols();
        }
      }
      else if (priv.settings.autoWrapRow && priv.selRange.highlight.col + delta.col < 0 && priv.selRange.highlight.row + delta.row >= 0) {
        delta.row = priv.selRange.highlight.row + delta.row == 0 ? instance.countRows() - 1 : -1;
        delta.col = instance.countCols() - 1;
      }

      var totalRows = instance.countRows();
      var totalCols = instance.countCols();
      var coords = new WalkontableCellCoords(priv.selRange.highlight.row + delta.row, priv.selRange.highlight.col + delta.col);

      if (coords.row < 0) {
        coords.row = 0;
      }
      else if (coords.row > 0 && coords.row >= totalRows) {
        coords.row = totalRows - 1;
      }

      if (coords.col < 0) {
        coords.col = 0;
      }
      else if (coords.col > 0 && coords.col >= totalCols) {
        coords.col = totalCols - 1;
      }

      selection.setRangeStart(coords);
    },

    /**
     * Sets selection end cell relative to current selection end cell (if possible)
     */
    transformEnd: function (rowDelta, colDelta) {
      var delta = new WalkontableCellCoords(rowDelta, colDelta);
      instance.runHooks('modifyTransformEnd', delta);

        var totalRows = instance.countRows();
        var totalCols = instance.countCols();
        var coords = new WalkontableCellCoords(priv.selRange.to.row + delta.row, priv.selRange.to.col + delta.col);

        if (coords.row < 0) {
          coords.row = 0;
        }
        else if (coords.row > 0 && coords.row >= totalRows) {
          coords.row = totalRows - 1;
        }

        if (coords.col < 0) {
          coords.col = 0;
        }
        else if (coords.col > 0 && coords.col >= totalCols) {
          coords.col = totalCols - 1;
        }

        selection.setRangeEnd(coords);
    },

    /**
     * Returns true if currently there is a selection on screen, false otherwise
     * @return {Boolean}
     */
    isSelected: function () {
      return (priv.selRange !== null);
    },

    /**
     * Returns true if coords is within current selection coords
     * @param {WalkontableCellCoords} coords
     * @return {Boolean}
     */
    inInSelection: function (coords) {
      if (!selection.isSelected()) {
        return false;
      }
      return priv.selRange.includes(coords);
    },

    /**
     * Deselects all selected cells
     */
    deselect: function () {
      if (!selection.isSelected()) {
        return;
      }
      instance.selection.inProgress = false; //needed by HT inception
      priv.selRange = null;
      instance.view.wt.selections.current.clear();
      instance.view.wt.selections.area.clear();
      editorManager.destroyEditor();
      selection.refreshBorders();
      Handsontable.hooks.run(instance, 'afterDeselect');
    },

    /**
     * Select all cells
     */
    selectAll: function () {
      if (!priv.settings.multiSelect) {
        return;
      }
      selection.setRangeStart(new WalkontableCellCoords(0, 0));
      selection.setRangeEnd(new WalkontableCellCoords(instance.countRows() - 1, instance.countCols() - 1), false);
    },

    /**
     * Deletes data from selected cells
     */
    empty: function () {
      if (!selection.isSelected()) {
        return;
      }
      var topLeft = priv.selRange.getTopLeftCorner();
      var bottomRight = priv.selRange.getBottomRightCorner();
      var r, c, changes = [];
      for (r = topLeft.row; r <= bottomRight.row; r++) {
        for (c = topLeft.col; c <= bottomRight.col; c++) {
          if (!instance.getCellMeta(r, c).readOnly) {
            changes.push([r, c, '']);
          }
        }
      }
      instance.setDataAtCell(changes);
    }
  };

  this.init = function () {
    Handsontable.hooks.run(instance, 'beforeInit');

    this.updateSettings(priv.settings, true);

    this.view = new Handsontable.TableView(this);
    editorManager = new Handsontable.EditorManager(instance, priv, selection, datamap);

    this.forceFullRender = true; //used when data was changed
    this.view.render();

    if (typeof priv.firstRun === 'object') {
      Handsontable.hooks.run(instance, 'afterChange', priv.firstRun[0], priv.firstRun[1]);
      priv.firstRun = false;
    }
    Handsontable.hooks.run(instance, 'afterInit');
  };

  function ValidatorsQueue() { //moved this one level up so it can be used in any function here. Probably this should be moved to a separate file
    var resolved = false;

    return {
      validatorsInQueue: 0,
      addValidatorToQueue: function () {
        this.validatorsInQueue++;
        resolved = false;
      },
      removeValidatorFormQueue: function () {
        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
        this.checkIfQueueIsEmpty();
      },
      onQueueEmpty: function () {
      },
      checkIfQueueIsEmpty: function () {
        if (this.validatorsInQueue == 0 && resolved == false) {
          resolved = true;
          this.onQueueEmpty();
        }
      }
    };
  }

  function validateChanges(changes, source, callback) {
    var waitingForValidator = new ValidatorsQueue();
    waitingForValidator.onQueueEmpty = resolve;

    for (var i = changes.length - 1; i >= 0; i--) {
      if (changes[i] === null) {
        changes.splice(i, 1);
      }
      else {
        var row = changes[i][0];
        var col = datamap.propToCol(changes[i][1]);
        var logicalCol = instance.runHooksAndReturn('modifyCol', col); //column order may have changes, so we need to translate physical col index (stored in datasource) to logical (displayed to user)
        var cellProperties = instance.getCellMeta(row, logicalCol);

        if (cellProperties.type === 'numeric' && typeof changes[i][3] === 'string') {
          if (changes[i][3].length > 0 && /^-?[\d\s]*(\.|\,)?\d*$/.test(changes[i][3])) {

            if(typeof cellProperties.language == 'undefined') {
              numeral.language('en');
            } else {
              numeral.language(cellProperties.language);
            }

            changes[i][3] = parseFloat(changes[i][3].replace(',','.'));
          }
        }

        if (instance.getCellValidator(cellProperties)) {
          waitingForValidator.addValidatorToQueue();
          instance.validateCell(changes[i][3], cellProperties, (function (i, cellProperties) {
            return function (result) {
              if (typeof result !== 'boolean') {
                throw new Error("Validation error: result is not boolean");
              }
              if (result === false && cellProperties.allowInvalid === false) {
                changes.splice(i, 1);         // cancel the change
                cellProperties.valid = true;  // we cancelled the change, so cell value is still valid
                --i;
              }
              waitingForValidator.removeValidatorFormQueue();
            }
          })(i, cellProperties)
            , source);
        }
      }
    }
    waitingForValidator.checkIfQueueIsEmpty();

    function resolve() {
      var beforeChangeResult;

      if (changes.length) {
        beforeChangeResult = Handsontable.hooks.execute(instance, "beforeChange", changes, source);
        if (typeof beforeChangeResult === 'function') {
          $.when(result).then(function () {
            callback(); //called when async validators and async beforeChange are resolved
          });
        }
        else if (beforeChangeResult === false) {
          changes.splice(0, changes.length); //invalidate all changes (remove everything from array)
        }
      }
      if (typeof beforeChangeResult !== 'function') {
        callback(); //called when async validators are resolved and beforeChange was not async
      }
    }
  }

  /**
   * Internal function to apply changes. Called after validateChanges
   * @param {Array} changes Array in form of [row, prop, oldValue, newValue]
   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
   */
  function applyChanges(changes, source) {
    var i = changes.length - 1;

    if (i < 0) {
      return;
    }

    for (; 0 <= i; i--) {
      if (changes[i] === null) {
        changes.splice(i, 1);
        continue;
      }

      if(changes[i][2] == null && changes[i][3] == null) {
        continue;
      }

      if (priv.settings.minSpareRows) {
        while (changes[i][0] > instance.countRows() - 1) {
          datamap.createRow();
        }
      }

      if (instance.dataType === 'array' && priv.settings.minSpareCols) {
        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
          datamap.createCol();
        }
      }

      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
    }

    instance.forceFullRender = true; //used when data was changed
    grid.adjustRowsAndCols();
    Handsontable.hooks.run(instance, 'beforeChangeRender', changes, source);
    selection.refreshBorders(null, true);
    Handsontable.hooks.run(instance, 'afterChange', changes, source || 'edit');
  }

  this.validateCell = function (value, cellProperties, callback, source) {
    var validator = instance.getCellValidator(cellProperties);

    if (Object.prototype.toString.call(validator) === '[object RegExp]') {
      validator = (function (validator) {
        return function (value, callback) {
          callback(validator.test(value));
        }
      })(validator);
    }

    if (typeof validator == 'function') {

      value = Handsontable.hooks.execute(instance, "beforeValidate", value, cellProperties.row, cellProperties.prop, source);

      // To provide consistent behaviour, validation should be always asynchronous
      setTimeout(function () {
        validator.call(cellProperties, value, function (valid) {
          cellProperties.valid = valid;

          valid = Handsontable.hooks.execute(instance, "afterValidate", valid, value, cellProperties.row, cellProperties.prop, source);

          callback(valid);
        });
      });

    } else { //resolve callback even if validator function was not found
      cellProperties.valid = true;
      callback(true);
    }



  };

  function setDataInputToArray(row, prop_or_col, value) {
    if (typeof row === "object") { //is it an array of changes
      return row;
    }
    else if ($.isPlainObject(value)) { //backwards compatibility
      return value;
    }
    else {
      return [
        [row, prop_or_col, value]
      ];
    }
  }

  /**
   * Set data at given cell
   * @public
   * @param {Number|Array} row or array of changes in format [[row, col, value], ...]
   * @param {Number|String} col or source String
   * @param {String} value
   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
   */
  this.setDataAtCell = function (row, col, value, source) {
    var input = setDataInputToArray(row, col, value)
      , i
      , ilen
      , changes = []
      , prop;

    for (i = 0, ilen = input.length; i < ilen; i++) {
      if (typeof input[i] !== 'object') {
        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');
      }
      if (typeof input[i][1] !== 'number') {
        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');
      }
      prop = datamap.colToProp(input[i][1]);
      changes.push([
        input[i][0],
        prop,
        datamap.get(input[i][0], prop),
        input[i][2]
      ]);
    }

    if (!source && typeof row === "object") {
      source = col;
    }

    validateChanges(changes, source, function () {
      applyChanges(changes, source);
    });
  };


  /**
   * Set data at given row property
   * @public
   * @param {Number|Array} row or array of changes in format [[row, prop, value], ...]
   * @param {String} prop or source String
   * @param {String} value
   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
   */
  this.setDataAtRowProp = function (row, prop, value, source) {
    var input = setDataInputToArray(row, prop, value)
      , i
      , ilen
      , changes = [];

    for (i = 0, ilen = input.length; i < ilen; i++) {
      changes.push([
        input[i][0],
        input[i][1],
        datamap.get(input[i][0], input[i][1]),
        input[i][2]
      ]);
    }

    if (!source && typeof row === "object") {
      source = prop;
    }

    validateChanges(changes, source, function () {
      applyChanges(changes, source);
    });
  };

  /**
   * Listen to document body keyboard input
   */
  this.listen = function () {
    Handsontable.activeGuid = instance.guid;

    if (document.activeElement && document.activeElement !== document.body) {
      document.activeElement.blur();
    }
    else if (!document.activeElement) { //IE
      document.body.focus();
    }
  };

  /**
   * Stop listening to document body keyboard input
   */
  this.unlisten = function () {
    Handsontable.activeGuid = null;
  };

  /**
   * Returns true if current Handsontable instance is listening on document body keyboard input
   */
  this.isListening = function () {
    return Handsontable.activeGuid === instance.guid;
  };

  /**
   * Destroys current editor, renders and selects current cell. If revertOriginal != true, edited data is saved
   * @param {Boolean} revertOriginal
   */
  this.destroyEditor = function (revertOriginal) {
    selection.refreshBorders(revertOriginal);
  };

  /**
   * Populate cells at position with 2d array
   * @param {Number} row Start row
   * @param {Number} col Start column
   * @param {Array} input 2d array
   * @param {Number=} endRow End row (use when you want to cut input when certain row is reached)
   * @param {Number=} endCol End column (use when you want to cut input when certain column is reached)
   * @param {String=} [source="populateFromArray"]
   * @param {String=} [method="overwrite"]
   * @return {Object|undefined} ending td in pasted area (only if any cell was changed)
   */
  this.populateFromArray = function (row, col, input, endRow, endCol, source, method) {
    if (!(typeof input === 'object' && typeof input[0] === 'object')) {
      throw new Error("populateFromArray parameter `input` must be an array of arrays"); //API changed in 0.9-beta2, let's check if you use it correctly
    }
    return grid.populateFromArray(new WalkontableCellCoords(row, col), input, typeof endRow === 'number' ? new WalkontableCellCoords(endRow, endCol) : null, source, method);
  };

  /**
   * Adds/removes data from the column
   * @param {Number} col Index of column in which do you want to do splice.
   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
   */
  this.spliceCol = function (col, index, amount/*, elements... */) {
    return datamap.spliceCol.apply(datamap, arguments);
  };

  /**
   * Adds/removes data from the row
   * @param {Number} row Index of column in which do you want to do splice.
   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
   */
  this.spliceRow = function (row, index, amount/*, elements... */) {
    return datamap.spliceRow.apply(datamap, arguments);
  };

  /**
   * Returns current selection. Returns undefined if there is no selection.
   * @public
   * @return {Array} [`startRow`, `startCol`, `endRow`, `endCol`]
   */
  this.getSelected = function () { //https://github.com/handsontable/jquery-handsontable/issues/44  //cjl
    if (selection.isSelected()) {
      return [priv.selRange.from.row, priv.selRange.from.col, priv.selRange.to.row, priv.selRange.to.col];
    }
  };

  /**
   * Returns current selection as a WalkontableCellRange object. Returns undefined if there is no selection.
   * @public
   * @return {WalkontableCellRange}
   */
  this.getSelectedRange = function () { //https://github.com/handsontable/jquery-handsontable/issues/44  //cjl
    if (selection.isSelected()) {
      return priv.selRange;
    }
  };


  /**
   * Render visible data
   * @public
   */
  this.render = function () {
    if (instance.view) {
      instance.forceFullRender = true; //used when data was changed
      selection.refreshBorders(null, true);
    }
  };

  /**
   * Load data from array
   * @public
   * @param {Array} data
   */
  this.loadData = function (data) {
    if (typeof data === 'object' && data !== null) {
      if (!(data.push && data.splice)) { //check if data is array. Must use duck-type check so Backbone Collections also pass it
        //when data is not an array, attempt to make a single-row array of it
        data = [data];
      }
    }
    else if(data === null) {
      data = [];
      var row;
      for (var r = 0, rlen = priv.settings.startRows; r < rlen; r++) {
        row = [];
        for (var c = 0, clen = priv.settings.startCols; c < clen; c++) {
          row.push(null);
        }
        data.push(row);
      }
    }
    else {
      throw new Error("loadData only accepts array of objects or array of arrays (" + typeof data + " given)");
    }

    priv.isPopulated = false;
    GridSettings.prototype.data = data;

    if (priv.settings.dataSchema instanceof Array || data[0]  instanceof Array) {
      instance.dataType = 'array';
    }
    else if (typeof priv.settings.dataSchema === 'function') {
      instance.dataType = 'function';
    }
    else {
      instance.dataType = 'object';
    }

    datamap = new Handsontable.DataMap(instance, priv, GridSettings);

    clearCellSettingCache();

    grid.adjustRowsAndCols();
    Handsontable.hooks.run(instance, 'afterLoadData');

    if (priv.firstRun) {
      priv.firstRun = [null, 'loadData'];
    }
    else {
      Handsontable.hooks.run(instance, 'afterChange', null, 'loadData');
      instance.render();
    }

    priv.isPopulated = true;



    function clearCellSettingCache() {
      priv.cellSettings.length = 0;
    }
  };

  /**
   * Return the current data object (the same that was passed by `data` configuration option or `loadData` method). Optionally you can provide cell range `r`, `c`, `r2`, `c2` to get only a fragment of grid data
   * @public
   * @param {Number} r (Optional) From row
   * @param {Number} c (Optional) From col
   * @param {Number} r2 (Optional) To row
   * @param {Number} c2 (Optional) To col
   * @return {Array|Object}
   */
  this.getData = function (r, c, r2, c2) {
    if (typeof r === 'undefined') {
      return datamap.getAll();
    } else {
      return datamap.getRange(new WalkontableCellCoords(r, c), new WalkontableCellCoords(r2, c2), datamap.DESTINATION_RENDERER);
    }
  };

  this.getCopyableData = function (startRow, startCol, endRow, endCol) {
    return datamap.getCopyableText(new WalkontableCellCoords(startRow, startCol), new WalkontableCellCoords(endRow, endCol));
  };

  /**
   * Update settings
   * @public
   */
  this.updateSettings = function (settings, init) {
    var i, clen;

    if (typeof settings.rows !== "undefined") {
      throw new Error("'rows' setting is no longer supported. do you mean startRows, minRows or maxRows?");
    }
    if (typeof settings.cols !== "undefined") {
      throw new Error("'cols' setting is no longer supported. do you mean startCols, minCols or maxCols?");
    }

    for (i in settings) {
      if (i === 'data') {
        continue; //loadData will be triggered later
      }
      else {
        if (Handsontable.hooks.hooks[i] !== void 0 || Handsontable.hooks.legacy[i] !== void 0) {
          if (typeof settings[i] === 'function' || Handsontable.helper.isArray(settings[i])) {
            instance.addHook(i, settings[i]);
          }
        }
        else {
          // Update settings
          if (!init && settings.hasOwnProperty(i)) {
            GridSettings.prototype[i] = settings[i];
          }
        }
      }
    }

    // Load data or create data map
    if (settings.data === void 0 && priv.settings.data === void 0) {
      instance.loadData(null); //data source created just now
    }
    else if (settings.data !== void 0) {
      instance.loadData(settings.data); //data source given as option
    }
    else if (settings.columns !== void 0) {
      datamap.createMap();
    }

    // Init columns constructors configuration
    clen = instance.countCols();

    //Clear cellSettings cache
    priv.cellSettings.length = 0;

    if (clen > 0) {
      var proto, column;

      for (i = 0; i < clen; i++) {
        priv.columnSettings[i] = Handsontable.helper.columnFactory(GridSettings, priv.columnsSettingConflicts);

        // shortcut for prototype
        proto = priv.columnSettings[i].prototype;

        // Use settings provided by user
        if (GridSettings.prototype.columns) {
          column = GridSettings.prototype.columns[i];
          Handsontable.helper.extend(proto, column);
          Handsontable.helper.extend(proto, expandType(column));
        }
      }
    }

    if (typeof settings.cell !== 'undefined') {
      for(i in settings.cell) {
        var cell = settings.cell[i];
        instance.setCellMetaObject(cell.row, cell.col, cell);
      }
    }

    Handsontable.hooks.run(instance, 'afterCellMetaReset');

    if (typeof settings.className !== "undefined") {
      if (GridSettings.prototype.className) {
        instance.rootElement.removeClass(GridSettings.prototype.className);
      }
      if (settings.className) {
        instance.rootElement.addClass(settings.className);
      }
    }

    if (typeof settings.height != 'undefined'){
      var height = settings.height;

      if (typeof height == 'function'){
        height = height();
      }

      instance.rootElement[0].style.height = height + 'px';
    }

    if (typeof settings.width != 'undefined'){
      var width = settings.width;

      if (typeof width == 'function'){
        width = width();
      }

      instance.rootElement[0].style.width = width + 'px';
    }

    if (height){
      instance.rootElement[0].style.overflow = 'auto';
    }

    if (!init) {
      Handsontable.hooks.run(instance, 'afterUpdateSettings');
    }

    grid.adjustRowsAndCols();
    if (instance.view && !priv.firstRun) {
      instance.forceFullRender = true; //used when data was changed
      selection.refreshBorders(null, true);
    }
  };

  this.getValue = function () {
    var sel = instance.getSelected();
    if (GridSettings.prototype.getValue) {
      if (typeof GridSettings.prototype.getValue === 'function') {
        return GridSettings.prototype.getValue.call(instance);
      }
      else if (sel) {
        return instance.getData()[sel[0]][GridSettings.prototype.getValue];
      }
    }
    else if (sel) {
      return instance.getDataAtCell(sel[0], sel[1]);
    }
  };

  function expandType(obj) {
    if (!obj.hasOwnProperty('type')) return; //ignore obj.prototype.type


    var type, expandedType = {};

    if (typeof obj.type === 'object') {
      type = obj.type;
    }
    else if (typeof obj.type === 'string') {
      type = Handsontable.cellTypes[obj.type];
      if (type === void 0) {
        throw new Error('You declared cell type "' + obj.type + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
      }
    }


    for (var i in type) {
      if (type.hasOwnProperty(i) && !obj.hasOwnProperty(i)) {
        expandedType[i] = type[i];
      }
    }

    return expandedType;

  };

  /**
   * Returns current settings object
   * @return {Object}
   */
  this.getSettings = function () {
    return priv.settings;
  };

  /**
   * Clears grid
   * @public
   */
  this.clear = function () {
    selection.selectAll();
    selection.empty();
  };

  /**
   * Inserts or removes rows and columns
   * @param {String} action See grid.alter for possible values
   * @param {Number} index
   * @param {Number} amount
   * @param {String} [source] Optional. Source of hook runner.
   * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
   * @public
   */
  this.alter = function (action, index, amount, source, keepEmptyRows) {
    grid.alter(action, index, amount, source, keepEmptyRows);
  };

  /**
   * Returns <td> element corresponding to params row, col
   * @param {Number} row
   * @param {Number} col
   * @public
   * @return {Element}
   */
  this.getCell = function (row, col) {
    return instance.view.getCellAtCoords(new WalkontableCellCoords(row, col));
  };

  /**
   * Returns property name associated with column number
   * @param {Number} col
   * @public
   * @return {String}
   */
  this.colToProp = function (col) {
    return datamap.colToProp(col);
  };

  /**
   * Returns column number associated with property name
   * @param {String} prop
   * @public
   * @return {Number}
   */
  this.propToCol = function (prop) {
    return datamap.propToCol(prop);
  };

  /**
   * Return value at `row`, `col`
   * @param {Number} row
   * @param {Number} col
   * @public
   * @return value (mixed data type)
   */
  this.getDataAtCell = function (row, col) {
    return datamap.get(row, datamap.colToProp(col));
  };

  /**
   * Return value at `row`, `prop`
   * @param {Number} row
   * @param {String} prop
   * @public
   * @return value (mixed data type)
   */
  this.getDataAtRowProp = function (row, prop) {
    return datamap.get(row, prop);
  };

  /**
   * Return value at `col`, where `col` is the visible index of the column
   * @param {Number} col
   * @public
   * @return {Array} value (mixed data type)
   */
  this.getDataAtCol = function (col) {
    var out = [];
    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, col), new WalkontableCellCoords(priv.settings.data.length - 1, col), datamap.DESTINATION_RENDERER));
  };

  /**
   * Return value at `prop`
   * @param {String} prop
   * @public
   * @return {Array} value (mixed data type)
   */
  this.getDataAtProp = function (prop) {
    var out = [];
    return out.concat.apply(out, datamap.getRange(new WalkontableCellCoords(0, datamap.propToCol(prop)), new WalkontableCellCoords(priv.settings.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER));
  };

  /**
   * Return original source values at 'col'
   * @param {Number} col
   * @public
   * @returns value (mixed data type)
   */
  this.getSourceDataAtCol = function (col) {
    var out = [],
        data = priv.settings.data;

    for (var i = 0; i < data.length; i++) {
      out.push(data[i][col]);
    }

    return out;
  };

  /**
   * Return original source values at 'row'
   * @param {Number} row
   * @public
   * @returns value {mixed data type}
   */
  this.getSourceDataAtRow = function (row) {
    return priv.settings.data[row];
  };

  /**
   * Return value at `row`
   * @param {Number} row
   * @public
   * @return value (mixed data type)
   */
  this.getDataAtRow = function (row) {
    var data = datamap.getRange(new WalkontableCellCoords(row, 0), new WalkontableCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
    return data[0];
  };

  /***
   *  Remove "key" property object from cell meta data corresponding to params row,col
   * @param {Number} row
   * @param {Number} col
   * @param {String} key
   */
  this.removeCellMeta = function(row, col, key) {
    var cellMeta = instance.getCellMeta(row, col);
    if(cellMeta[key] != undefined){
      delete priv.cellSettings[row][col][key];
    }
  };

  /**
   * Set cell meta data object to corresponding params row, col
   * @param {Number} row
   * @param {Number} col
   * @param {Object} prop
   */
  this.setCellMetaObject = function (row, col, prop) {
    if (typeof prop === 'object') {
      for (var i in prop) {
        var key = i,
            value = prop[i];

        this.setCellMeta(row, col, key, value);
      }
    }
  };

  /**
   * Sets cell meta data object "key" corresponding to params row, col
   * @param {Number} row
   * @param {Number} col
   * @param {String} key
   * @param {String} val
   *
   */
  this.setCellMeta = function (row, col, key, val) {
    if (!priv.cellSettings[row]) {
      priv.cellSettings[row] = [];
    }
    if (!priv.cellSettings[row][col]) {
      priv.cellSettings[row][col] = new priv.columnSettings[col]();
    }
    priv.cellSettings[row][col][key] = val;
    Handsontable.hooks.run(instance, 'afterSetCellMeta', row, col, key, val);
  };

  /**
   * Returns cell meta data object corresponding to params row, col
   * @param {Number} row
   * @param {Number} col
   * @public
   * @return {Object}
   */
  this.getCellMeta = function (row, col) {
    var prop = datamap.colToProp(col)
      , cellProperties;

    row = translateRowIndex(row);
    col = translateColIndex(col);

    if (!priv.columnSettings[col]) {
      priv.columnSettings[col] = Handsontable.helper.columnFactory(GridSettings, priv.columnsSettingConflicts);
    }

    if (!priv.cellSettings[row]) {
      priv.cellSettings[row] = [];
    }
    if (!priv.cellSettings[row][col]) {
      priv.cellSettings[row][col] = new priv.columnSettings[col]();
    }

    cellProperties = priv.cellSettings[row][col]; //retrieve cellProperties from cache

    cellProperties.row = row;
    cellProperties.col = col;
    cellProperties.prop = prop;
    cellProperties.instance = instance;

    Handsontable.hooks.run(instance, 'beforeGetCellMeta', row, col, cellProperties);
    Handsontable.helper.extend(cellProperties, expandType(cellProperties)); //for `type` added in beforeGetCellMeta

    if (cellProperties.cells) {
      var settings = cellProperties.cells.call(cellProperties, row, col, prop);

      if (settings) {
        Handsontable.helper.extend(cellProperties, settings);
        Handsontable.helper.extend(cellProperties, expandType(settings)); //for `type` added in cells
      }
    }

    Handsontable.hooks.run(instance, 'afterGetCellMeta', row, col, cellProperties);

    return cellProperties;
  };

  /**
   * If displayed rows order is different than the order of rows stored in memory (i.e. sorting is applied)
   * we need to translate logical (stored) row index to physical (displayed) index.
   * @param row - original row index
   * @returns {int} translated row index
   */
  function translateRowIndex(row){
    return Handsontable.hooks.execute(instance, 'modifyRow', row);
  }

  /**
   * If displayed columns order is different than the order of columns stored in memory (i.e. column were moved using manualColumnMove plugin)
   * we need to translate logical (stored) column index to physical (displayed) index.
   * @param col - original column index
   * @returns {int} - translated column index
   */
  function translateColIndex(col){
    return Handsontable.hooks.execute(instance, 'modifyCol', col); // warning: this must be done after datamap.colToProp
  }

  var rendererLookup = Handsontable.helper.cellMethodLookupFactory('renderer');
  this.getCellRenderer = function (row, col) {
    var renderer = rendererLookup.call(this, row, col);
    return Handsontable.renderers.getRenderer(renderer);

  };

  this.getCellEditor = Handsontable.helper.cellMethodLookupFactory('editor');

  this.getCellValidator = Handsontable.helper.cellMethodLookupFactory('validator');


  /**
   * Validates all cells using their validator functions and calls callback when finished. Does not render the view
   * @param callback
   */
  this.validateCells = function (callback) {
    var waitingForValidator = new ValidatorsQueue();
    waitingForValidator.onQueueEmpty = callback;

    var i = instance.countRows() - 1;
    while (i >= 0) {
      var j = instance.countCols() - 1;
      while (j >= 0) {
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function () {
          waitingForValidator.removeValidatorFormQueue();
        }, 'validateCells');
        j--;
      }
      i--;
    }
    waitingForValidator.checkIfQueueIsEmpty();
  };

  /**
   * Return array of row headers (if they are enabled). If param `row` given, return header at given row as string
   * @param {Number} row (Optional)
   * @return {Array|String}
   */
  this.getRowHeader = function (row) {
    if (row === void 0) {
      var out = [];
      for (var i = 0, ilen = instance.countRows(); i < ilen; i++) {
        out.push(instance.getRowHeader(i));
      }
      return out;
    }
    else if (Object.prototype.toString.call(priv.settings.rowHeaders) === '[object Array]' && priv.settings.rowHeaders[row] !== void 0) {
      return priv.settings.rowHeaders[row];
    }
    else if (typeof priv.settings.rowHeaders === 'function') {
      return priv.settings.rowHeaders(row);
    }
    else if (priv.settings.rowHeaders && typeof priv.settings.rowHeaders !== 'string' && typeof priv.settings.rowHeaders !== 'number') {
      return row + 1;
    }
    else {
      return priv.settings.rowHeaders;
    }
  };

  /**
   * Returns information of this table is configured to display row headers
   * @returns {boolean}
   */
  this.hasRowHeaders = function () {
    return !!priv.settings.rowHeaders;
  };

  /**
   * Returns information of this table is configured to display column headers
   * @returns {boolean}
   */
  this.hasColHeaders = function () {
    if (priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null) { //Polymer has empty value = null
      return !!priv.settings.colHeaders;
    }
    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
      if (instance.getColHeader(i)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Return array of column headers (if they are enabled). If param `col` given, return header at given column as string
   * @param {Number} col (Optional)
   * @return {Array|String}
   */
  this.getColHeader = function (col) {
    if (col === void 0) {
      var out = [];
      for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {
        out.push(instance.getColHeader(i));
      }
      return out;
    }
    else {
      var baseCol = col;
      col = Handsontable.hooks.execute(instance, 'modifyCol', col);

      if (priv.settings.columns && priv.settings.columns[col] && priv.settings.columns[col].title) {
        return priv.settings.columns[col].title;
      }
      else if (Object.prototype.toString.call(priv.settings.colHeaders) === '[object Array]' && priv.settings.colHeaders[col] !== void 0) {
        return priv.settings.colHeaders[col];
      }
      else if (typeof priv.settings.colHeaders === 'function') {
        return priv.settings.colHeaders(col);
      }
      else if (priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number') {
        return Handsontable.helper.spreadsheetColumnLabel(baseCol); //see #1458
      }
      else {
        return priv.settings.colHeaders;
      }
    }
  };

  /**
   * Return column width from settings (no guessing). Private use intended
   * @param {Number} col
   * @return {Number}
   */
  this._getColWidthFromSettings = function (col) {
    var cellProperties = instance.getCellMeta(0, col);
    var width = cellProperties.width;
    if (width === void 0 || width === priv.settings.width) {
      width = cellProperties.colWidths;
    }
    if (width !== void 0 && width !== null) {
      switch (typeof width) {
        case 'object': //array
          width = width[col];
          break;

        case 'function':
          width = width(col);
          break;
      }
      if (typeof width === 'string') {
        width = parseInt(width, 10);
      }
    }
    return width;
  };

  /**
   * Return column width
   * @param {Number} col
   * @return {Number}
   */
  this.getColWidth = function (col) {
    var width = instance._getColWidthFromSettings(col);
    if (!width) {
      width = 50;
    }
    width = Handsontable.hooks.execute(instance, 'modifyColWidth', width, col);
    return width;
  };

  /**
   * Return row height from settings (no guessing). Private use intended
   * @param {Number} row
   * @return {Number}
   */
  this._getRowHeightFromSettings= function (row) {
    /* inefficient
    var cellProperties = instance.getCellMeta(0, row);
    var height = cellProperties.height;
    if (height === void 0 || height === priv.settings.height) {
      height = cellProperties.rowHeights;
    }
    */
    var height = priv.settings.rowHeights; //only uses grid settings
    if (height !== void 0 && height !== null) {
      switch (typeof height) {
        case 'object': //array
          height = height[row];
          break;

        case 'function':
          height = height(row);
          break;
      }
      if (typeof height === 'string') {
        height = parseInt(height, 10);
      }
    }
    return height;
  };

  /**
   * Return row height
   * @param {Number} row
   * @return {Number}
   */
  this.getRowHeight = function (row) {
    var height = instance._getRowHeightFromSettings(row);

    height = Handsontable.hooks.execute(instance, 'modifyRowHeight', height, row);
    return height;
  };

  /**
   * Return total number of rows in grid
   * @return {Number}
   */
  this.countRows = function () {
    return priv.settings.data.length;
  };

  /**
   * Return total number of columns in grid
   * @return {Number}
   */
  this.countCols = function () {
    if (instance.dataType === 'object' || instance.dataType === 'function') {
      if (priv.settings.columns && priv.settings.columns.length) {
        return priv.settings.columns.length;
      }
      else {
        return datamap.colToPropCache.length;
      }
    }
    else if (instance.dataType === 'array') {
      if (priv.settings.columns && priv.settings.columns.length) {
        return priv.settings.columns.length;
      }
      else if (priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length) {
        return priv.settings.data[0].length;
      }
      else {
        return 0;
      }
    }
  };

  /**
   * Return index of first visible row
   * @return {Number}
   */
  this.rowOffset = function () {
    return instance.view.wt.getSetting('offsetRow'); //actually offsetRow is the first rendered row, not neccessarily first visible
  };

  /**
   * Return index of first visible column
   * @return {Number}
   */
  this.colOffset = function () {
    return 0; //all columns are always rendered
  };

  /**
   * Return number of visible rows. Returns -1 if table is not visible
   * @return {Number}
   */
  this.countVisibleRows = function () {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.rowStrategy.countVisible() : -1;
  };

  /**
   * Return number of visible columns. Returns -1 if table is not visible
   * @return {Number}
   */
  this.countVisibleCols = function () {
    return instance.view.wt.drawn ? instance.view.wt.wtTable.columnStrategy.countVisible() : -1;
  };

  /**
   * Return number of empty rows
   * @return {Boolean} ending If true, will only count empty rows at the end of the data source
   */
  this.countEmptyRows = function (ending) {
    var i = instance.countRows() - 1
      , empty = 0
      , row;
    while (i >= 0) {
      row = Handsontable.hooks.execute(this, 'modifyRow', i);
      if (instance.isEmptyRow(row)) {
        empty++;
      }
      else if (ending) {
        break;
      }
      i--;
    }
    return empty;
  };

  /**
   * Return number of empty columns
   * @return {Boolean} ending If true, will only count empty columns at the end of the data source row
   */
  this.countEmptyCols = function (ending) {
    if (instance.countRows() < 1) {
      return 0;
    }

    var i = instance.countCols() - 1
      , empty = 0;
    while (i >= 0) {
      if (instance.isEmptyCol(i)) {
        empty++;
      }
      else if (ending) {
        break;
      }
      i--;
    }
    return empty;
  };

  /**
   * Return true if the row at the given index is empty, false otherwise
   * @param {Number} r Row index
   * @return {Boolean}
   */
  this.isEmptyRow = function (r) {
    return priv.settings.isEmptyRow.call(instance, r);
  };

  /**
   * Return true if the column at the given index is empty, false otherwise
   * @param {Number} c Column index
   * @return {Boolean}
   */
  this.isEmptyCol = function (c) {
    return priv.settings.isEmptyCol.call(instance, c);
  };

  /**
   * Selects cell on grid. Optionally selects range to another cell
   * @param {Number} row
   * @param {Number} col
   * @param {Number} [endRow]
   * @param {Number} [endCol]
   * @param {Boolean} [scrollToCell=true] If true, viewport will be scrolled to the selection
   * @public
   * @return {Boolean}
   */
  this.selectCell = function (row, col, endRow, endCol, scrollToCell) {
    if (typeof row !== 'number' || row < 0 || row >= instance.countRows()) {
      return false;
    }
    if (typeof col !== 'number' || col < 0 || col >= instance.countCols()) {
      return false;
    }
    if (typeof endRow !== "undefined") {
      if (typeof endRow !== 'number' || endRow < 0 || endRow >= instance.countRows()) {
        return false;
      }
      if (typeof endCol !== 'number' || endCol < 0 || endCol >= instance.countCols()) {
        return false;
      }
    }
    var coords = new WalkontableCellCoords(row, col);
    priv.selRange = new WalkontableCellRange(coords, coords, coords);
    if (document.activeElement && document.activeElement !== document.documentElement && document.activeElement !== document.body) {
      document.activeElement.blur(); //needed or otherwise prepare won't focus the cell. selectionSpec tests this (should move focus to selected cell)
    }
    instance.listen();
    if (typeof endRow === "undefined") {
      selection.setRangeEnd(priv.selRange.from, scrollToCell);
    }
    else {
      selection.setRangeEnd(new WalkontableCellCoords(endRow, endCol), scrollToCell);
    }

    instance.selection.finish();
    return true;
  };

  this.selectCellByProp = function (row, prop, endRow, endProp, scrollToCell) {
    arguments[1] = datamap.propToCol(arguments[1]);
    if (typeof arguments[3] !== "undefined") {
      arguments[3] = datamap.propToCol(arguments[3]);
    }
    return instance.selectCell.apply(instance, arguments);
  };

  /**
   * Deselects current sell selection on grid
   * @public
   */
  this.deselectCell = function () {
    selection.deselect();
  };

  /**
   * Remove grid from DOM
   * @public
   */
  this.destroy = function () {
    instance._clearTimeouts();
    if (instance.view) { //in case HT is destroyed before initialization has finished
      instance.view.wt.destroy();
    }
    instance.rootElement.empty();
    instance.rootElement.removeData('handsontable');
    instance.rootElement.off('.handsontable');
    $(window).off('.' + instance.guid);
    $document.off('.' + instance.guid);
    $body.off('.' + instance.guid);
    Handsontable.hooks.run(instance, 'afterDestroy');
  };

  /**
   * Returns active editor object
   * @returns {Object}
   */
  this.getActiveEditor = function(){
    return editorManager.getActiveEditor();
  };

  /**
   * Return Handsontable instance
   * @public
   * @return {Object}
   */
  this.getInstance = function () {
    return instance;
  };

  this.addHook = function (key, fn) {
    Handsontable.hooks.add(key, fn, instance);
  };

  this.addHookOnce = function (key, fn) {
    Handsontable.hooks.once(key, fn, instance);
  };

  this.removeHook = function (key, fn) {
    Handsontable.hooks.remove(key, fn, instance);
  };

  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {
    Handsontable.hooks.run(instance, key, p1, p2, p3, p4, p5, p6);
  };

  this.runHooksAndReturn = function (key, p1, p2, p3, p4, p5, p6) {
    return Handsontable.hooks.execute(instance, key, p1, p2, p3, p4, p5, p6);
  };

  this.timeouts = {};

  /**
   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called
   * @public
   */
  this._registerTimeout = function (key, handle, ms) {
    clearTimeout(this.timeouts[key]);
    this.timeouts[key] = setTimeout(handle, ms || 0);
  };

  /**
   * Clears all known timeouts
   * @public
   */
  this._clearTimeouts = function () {
    for (var key in this.timeouts) {
      if (this.timeouts.hasOwnProperty(key)) {
        clearTimeout(this.timeouts[key]);
      }
    }
  };

  /**
   * Handsontable version
   */
  this.version = '0.11.0-beta3'; //inserted by grunt from package.json
};

var DefaultSettings = function () {};

DefaultSettings.prototype = {
  data: void 0,
  width: void 0,
  height: void 0,
  startRows: 5,
  startCols: 5,
  rowHeaders: null,
  colHeaders: null,
  cell: [],
  minRows: 0,
  minCols: 0,
  maxRows: Infinity,
  maxCols: Infinity,
  minSpareRows: 0,
  minSpareCols: 0,
  multiSelect: true,
  fillHandle: true,
  fixedRowsTop: 0,
  fixedColumnsLeft: 0,
  outsideClickDeselects: true,
  enterBeginsEditing: true,
  enterMoves: {row: 1, col: 0},
  tabMoves: {row: 0, col: 1},
  autoWrapRow: false,
  autoWrapCol: false,
  copyRowsLimit: 1000,
  copyColsLimit: 1000,
  pasteMode: 'overwrite',
  currentRowClassName: void 0,
  currentColClassName: void 0,
  stretchH: 'hybrid',
  isEmptyRow: function (r) {
    var val;
    for (var c = 0, clen = this.countCols(); c < clen; c++) {
      val = this.getDataAtCell(r, c);
      if (val !== '' && val !== null && typeof val !== 'undefined') {
        return false;
      }
    }
    return true;
  },
  isEmptyCol: function (c) {
    var val;
    for (var r = 0, rlen = this.countRows(); r < rlen; r++) {
      val = this.getDataAtCell(r, c);
      if (val !== '' && val !== null && typeof val !== 'undefined') {
        return false;
      }
    }
    return true;
  },
  observeDOMVisibility: true,
  allowInvalid: true,
  invalidCellClassName: 'htInvalid',
  placeholder: false,
  placeholderCellClassName: 'htPlaceholder',
  readOnlyCellClassName: 'htDimmed',
  commentedCellClassName: 'htCommentCell',
  fragmentSelection: false,
  readOnly: false,
  type: 'text',
  copyable: true,
  debug: false, //shows debug overlays in Walkontable
  wordWrap: true,
  noWordWrapClassName: 'htNoWrap'
};
Handsontable.DefaultSettings = DefaultSettings;

$.fn.handsontable = function (action) {
  var i
    , ilen
    , args
    , output
    , userSettings
    , $this = this.first() // Use only first element from list
    , instance = $this.data('handsontable');

  // Init case
  if (typeof action !== 'string') {
    userSettings = action || {};
    if (instance) {
      instance.updateSettings(userSettings);
    }
    else {
      instance = new Handsontable.Core($this, userSettings);
      $this.data('handsontable', instance);
      instance.init();
    }

    return $this;
  }
  // Action case
  else {
    args = [];
    if (arguments.length > 1) {
      for (i = 1, ilen = arguments.length; i < ilen; i++) {
        args.push(arguments[i]);
      }
    }

    if (instance) {
      if (typeof instance[action] !== 'undefined') {
        output = instance[action].apply(instance, args);
      }
      else {
        throw new Error('Handsontable do not provide action: ' + action);
      }
    }

    return output;
  }
};

(function (window) {
  'use strict';

  function MultiMap() {
    var map = {
      arrayMap: [],
      weakMap: new WeakMap()
    };

    return {
      'get': function (key) {
        if (canBeAnArrayMapKey(key)) {
          return map.arrayMap[key];
        } else if (canBeAWeakMapKey(key)) {
          return map.weakMap.get(key);
        }
      },

      'set': function (key, value) {
        if (canBeAnArrayMapKey(key)) {
          map.arrayMap[key] = value;
        } else if (canBeAWeakMapKey(key)) {
          map.weakMap.set(key, value);
        } else {
          throw new Error('Invalid key type');
        }


      },

      'delete': function (key) {
        if (canBeAnArrayMapKey(key)) {
          delete map.arrayMap[key];
        } else if (canBeAWeakMapKey(key)) {
          map.weakMap['delete'](key);  //Delete must be called using square bracket notation, because IE8 does not handle using `delete` with dot notation
        }
      }
    };



    function canBeAnArrayMapKey(obj){
      return obj !== null && !isNaNSymbol(obj) && (typeof obj == 'string' || typeof obj == 'number');
    }

    function canBeAWeakMapKey(obj){
      return obj !== null && (typeof obj == 'object' || typeof obj == 'function');
    }

    function isNaNSymbol(obj){
      return obj !== obj; // NaN === NaN is always false
    }

  }

  if (!window.MultiMap){
    window.MultiMap = MultiMap;
  }

})(window);
/**
 * DOM helper optimized for maximum performance
 * It is recommended for Handsontable plugins and renderers, because it is much faster than jQuery
 * @type {Object}
 */
if(!window.Handsontable) {
  var Handsontable = {}; //required because Walkontable test suite uses this class directly
}
Handsontable.Dom = {};

//goes up the DOM tree (including given element) until it finds an element that matches the nodeName
Handsontable.Dom.closest = function (elem, nodeNames, until) {
  while (elem != null && elem !== until) {
    if (elem.nodeType === 1 && nodeNames.indexOf(elem.nodeName) > -1) {
      return elem;
    }
    elem = elem.parentNode;
  }
  return null;
};

//goes up the DOM tree and checks if element is child of another element
Handsontable.Dom.isChildOf = function (child, parent) {
  var node = child.parentNode;
  while (node != null) {
    if (node == parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};

/**
 * Counts index of element within its parent
 * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true for Walkotnable
 * Otherwise would need to check for nodeType or use previousElementSibling
 * @see http://jsperf.com/sibling-index/10
 * @param {Element} elem
 * @return {Number}
 */
Handsontable.Dom.index = function (elem) {
  var i = 0;
  while (elem = elem.previousSibling) {
    ++i
  }
  return i;
};

if (document.documentElement.classList) {
  // HTML5 classList API
  Handsontable.Dom.hasClass = function (ele, cls) {
    return ele.classList.contains(cls);
  };

  Handsontable.Dom.addClass = function (ele, cls) {
    ele.classList.add(cls);
  };

  Handsontable.Dom.removeClass = function (ele, cls) {
    ele.classList.remove(cls);
  };
}
else {
  //http://snipplr.com/view/3561/addclass-removeclass-hasclass/
  Handsontable.Dom.hasClass = function (ele, cls) {
    return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
  };

  Handsontable.Dom.addClass = function (ele, cls) {
    if(ele.className == "") ele.className = cls;
    else if (!this.hasClass(ele, cls)) ele.className += " " + cls;
  };

  Handsontable.Dom.removeClass = function (ele, cls) {
    if (this.hasClass(ele, cls)) { //is this really needed?
      var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
      ele.className = ele.className.replace(reg, ' ').trim(); //String.prototype.trim is defined in polyfill.js
    }
  };
}

/*//http://net.tutsplus.com/tutorials/javascript-ajax/javascript-from-null-cross-browser-event-binding/
 Handsontable.Dom.addEvent = (function () {
 var that = this;
 if (document.addEventListener) {
 return function (elem, type, cb) {
 if ((elem && !elem.length) || elem === window) {
 elem.addEventListener(type, cb, false);
 }
 else if (elem && elem.length) {
 var len = elem.length;
 for (var i = 0; i < len; i++) {
 that.addEvent(elem[i], type, cb);
 }
 }
 };
 }
 else {
 return function (elem, type, cb) {
 if ((elem && !elem.length) || elem === window) {
 elem.attachEvent('on' + type, function () {

 //normalize
 //http://stackoverflow.com/questions/4643249/cross-browser-event-object-normalization
 var e = window['event'];
 e.target = e.srcElement;
 //e.offsetX = e.layerX;
 //e.offsetY = e.layerY;
 e.relatedTarget = e.relatedTarget || e.type == 'mouseover' ? e.fromElement : e.toElement;
 if (e.target.nodeType === 3) e.target = e.target.parentNode; //Safari bug

 return cb.call(elem, e)
 });
 }
 else if (elem.length) {
 var len = elem.length;
 for (var i = 0; i < len; i++) {
 that.addEvent(elem[i], type, cb);
 }
 }
 };
 }
 })();

 Handsontable.Dom.triggerEvent = function (element, eventName, target) {
 var event;
 if (document.createEvent) {
 event = document.createEvent("MouseEvents");
 event.initEvent(eventName, true, true);
 } else {
 event = document.createEventObject();
 event.eventType = eventName;
 }

 event.eventName = eventName;
 event.target = target;

 if (document.createEvent) {
 target.dispatchEvent(event);
 } else {
 target.fireEvent("on" + event.eventType, event);
 }
 };*/

Handsontable.Dom.removeTextNodes = function (elem, parent) {
  if (elem.nodeType === 3) {
    parent.removeChild(elem); //bye text nodes!
  }
  else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(elem.nodeName) > -1) {
    var childs = elem.childNodes;
    for (var i = childs.length - 1; i >= 0; i--) {
      this.removeTextNodes(childs[i], elem);
    }
  }
};

/**
 * Remove childs function
 * WARNING - this doesn't unload events and data attached by jQuery
 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9
 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method
 * @param element
 * @returns {void}
 */
//
Handsontable.Dom.empty = function (element) {
  var child;
  while (child = element.lastChild) {
    element.removeChild(child);
  }
};

Handsontable.Dom.HTML_CHARACTERS = /(<(.*)>|&(.*);)/;

/**
 * Insert content into element trying avoid innerHTML method.
 * @return {void}
 */
Handsontable.Dom.fastInnerHTML = function (element, content) {
  if (this.HTML_CHARACTERS.test(content)) {
    element.innerHTML = content;
  }
  else {
    this.fastInnerText(element, content);
  }
};

/**
 * Insert text content into element
 * @return {void}
 */
if (document.createTextNode('test').textContent) { //STANDARDS
  Handsontable.Dom.fastInnerText = function (element, content) {
    var child = element.firstChild;
    if (child && child.nodeType === 3 && child.nextSibling === null) {
      //fast lane - replace existing text node
      //http://jsperf.com/replace-text-vs-reuse
      child.textContent = content;
    }
    else {
      //slow lane - empty element and insert a text node
      this.empty(element);
      element.appendChild(document.createTextNode(content));
    }
  };
}
else { //IE8
  Handsontable.Dom.fastInnerText = function (element, content) {
    var child = element.firstChild;
    if (child && child.nodeType === 3 && child.nextSibling === null) {
      //fast lane - replace existing text node
      //http://jsperf.com/replace-text-vs-reuse
      child.data = content;
    }
    else {
      //slow lane - empty element and insert a text node
      this.empty(element);
      element.appendChild(document.createTextNode(content));
    }
  };
}

/**
 * Returns true/false depending if element has offset parent
 * @param elem
 * @returns {boolean}
 */
/*if (document.createTextNode('test').textContent) { //STANDARDS
  Handsontable.Dom.hasOffsetParent = function (elem) {
    return !!elem.offsetParent;
  }
}
else {
  Handsontable.Dom.hasOffsetParent = function (elem) {
    try {
      if (!elem.offsetParent) {
        return false;
      }
    }
    catch (e) {
      return false; //IE8 throws "Unspecified error" when offsetParent is not found - we catch it here
    }
    return true;
  }
}*/

/**
 * Returns true if element is attached to the DOM and visible, false otherwise
 * @param elem
 * @returns {boolean}
 */
Handsontable.Dom.isVisible = function (elem) {
  //fast method according to benchmarks, but requires layout so slow in our case
  /*
  if (!Handsontable.Dom.hasOffsetParent(elem)) {
    return false; //fixes problem with UI Bootstrap <tabs> directive
  }

//  if (elem.offsetWidth > 0 || (elem.parentNode && elem.parentNode.offsetWidth > 0)) { //IE10 was mistaken here
  if (elem.offsetWidth > 0) {
    return true;
  }
  */

  //slow method
  var next = elem;
  while (next !== document.documentElement) { //until <html> reached
    if (next === null) { //parent detached from DOM
      return false;
    }
    else if (next.nodeType === 11) {  //nodeType == 1 -> DOCUMENT_FRAGMENT_NODE
      if (next.host) { //this is Web Components Shadow DOM
        //see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation
        //according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet
        if (next.host.impl) { //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled
          return Handsontable.Dom.isVisible(next.host.impl);
        }
        else if (next.host) { //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled
          return Handsontable.Dom.isVisible(next.host);
        }
        else {
          throw new Error("Lost in Web Components world");
        }
      }
      else {
        return false; //this is a node detached from document in IE8
      }
    }
    else if (next.style.display === 'none') {
      return false;
    }
    next = next.parentNode;
  }
  return true;
};

/**
 * Returns elements top and left offset relative to the document. In our usage case compatible with jQuery but 2x faster
 * @param {HTMLElement} elem
 * @return {Object}
 */
Handsontable.Dom.offset = function (elem) {
  if (this.hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
    //fixes problem with Firefox ignoring <caption> in TABLE offset (see also Handsontable.Dom.outerHeight)
    //http://jsperf.com/offset-vs-getboundingclientrect/8
    var box = elem.getBoundingClientRect();
    return {
      top: box.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0),
      left: box.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0)
    };
  }

  var offsetLeft = elem.offsetLeft
    , offsetTop = elem.offsetTop
    , lastElem = elem;

  while (elem = elem.offsetParent) {
    if (elem === document.body) { //from my observation, document.body always has scrollLeft/scrollTop == 0
      break;
    }
    offsetLeft += elem.offsetLeft;
    offsetTop += elem.offsetTop;
    lastElem = elem;
  }

  if (lastElem && lastElem.style.position === 'fixed') { //slow - http://jsperf.com/offset-vs-getboundingclientrect/6
    //if(lastElem !== document.body) { //faster but does gives false positive in Firefox
    offsetLeft += window.pageXOffset || document.documentElement.scrollLeft;
    offsetTop += window.pageYOffset || document.documentElement.scrollTop;
  }

  return {
    left: offsetLeft,
    top: offsetTop
  };
};

Handsontable.Dom.getWindowScrollTop = function () {
  var res = window.scrollY;
  if (res == void 0) { //IE8-11
    res = document.documentElement.scrollTop;
  }
  return res;
};

Handsontable.Dom.getWindowScrollLeft = function () {
  var res = window.scrollX;
  if (res == void 0) { //IE8-11
    res = document.documentElement.scrollLeft;
  }
  return res;
};

Handsontable.Dom.getScrollTop = function (elem) {
  if (elem === window) {
    return Handsontable.Dom.getWindowScrollTop(elem);
  }
  else {
    return elem.scrollTop;
  }
};

Handsontable.Dom.getScrollLeft = function (elem) {
  if (elem === window) {
    return Handsontable.Dom.getWindowScrollLeft(elem);
  }
  else {
    return elem.scrollLeft;
  }
};

Handsontable.Dom.getComputedStyle = function (elem) {
  return elem.currentStyle || document.defaultView.getComputedStyle(elem);
};

Handsontable.Dom.outerWidth = function (elem) {
  return elem.offsetWidth;
};

Handsontable.Dom.outerHeight = function (elem) {
  if (this.hasCaptionProblem() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
    //fixes problem with Firefox ignoring <caption> in TABLE.offsetHeight
    //jQuery (1.10.1) still has this unsolved
    //may be better to just switch to getBoundingClientRect
    //http://bililite.com/blog/2009/03/27/finding-the-size-of-a-table/
    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0089.html
    //http://bugs.jquery.com/ticket/2196
    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0140.html#start140
    return elem.offsetHeight + elem.firstChild.offsetHeight;
  }
  else {
    return elem.offsetHeight;
  }
};

(function () {
  var hasCaptionProblem;

  function detectCaptionProblem() {
    var TABLE = document.createElement('TABLE');
    TABLE.style.borderSpacing = 0;
    TABLE.style.borderWidth = 0;
    TABLE.style.padding = 0;
    var TBODY = document.createElement('TBODY');
    TABLE.appendChild(TBODY);
    TBODY.appendChild(document.createElement('TR'));
    TBODY.firstChild.appendChild(document.createElement('TD'));
    TBODY.firstChild.firstChild.innerHTML = '<tr><td>t<br>t</td></tr>';

    var CAPTION = document.createElement('CAPTION');
    CAPTION.innerHTML = 'c<br>c<br>c<br>c';
    CAPTION.style.padding = 0;
    CAPTION.style.margin = 0;
    TABLE.insertBefore(CAPTION, TBODY);

    document.body.appendChild(TABLE);
    hasCaptionProblem = (TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight); //boolean
    document.body.removeChild(TABLE);
  }

  Handsontable.Dom.hasCaptionProblem = function () {
    if (hasCaptionProblem === void 0) {
      detectCaptionProblem();
    }
    return hasCaptionProblem;
  };

  /**
   * Returns caret position in text input
   * @author http://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea
   * @return {Number}
   */
  Handsontable.Dom.getCaretPosition = function (el) {
    if (el.selectionStart) {
      return el.selectionStart;
    }
    else if (document.selection) { //IE8
      el.focus();
      var r = document.selection.createRange();
      if (r == null) {
        return 0;
      }
      var re = el.createTextRange(),
        rc = re.duplicate();
      re.moveToBookmark(r.getBookmark());
      rc.setEndPoint('EndToStart', re);
      return rc.text.length;
    }
    return 0;
  };

  /**
   * Sets caret position in text input
   * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/
   * @param {Element} el
   * @param {Number} pos
   * @param {Number} endPos
   */
  Handsontable.Dom.setCaretPosition = function (el, pos, endPos) {
    if (endPos === void 0) {
      endPos = pos;
    }
    if (el.setSelectionRange) {
      el.focus();
      el.setSelectionRange(pos, endPos);
    }
    else if (el.createTextRange) { //IE8
      var range = el.createTextRange();
      range.collapse(true);
      range.moveEnd('character', endPos);
      range.moveStart('character', pos);
      range.select();
    }
  };

  var cachedScrollbarWidth;
  //http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes
  function walkontableCalculateScrollbarWidth() {
    var inner = document.createElement('p');
    inner.style.width = "100%";
    inner.style.height = "200px";

    var outer = document.createElement('div');
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "200px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild(inner);

    (document.body || document.documentElement).appendChild(outer);
    var w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var w2 = inner.offsetWidth;
    if (w1 == w2) w2 = outer.clientWidth;

    (document.body || document.documentElement).removeChild(outer);

    return (w1 - w2);
  }

  /**
   * Returns the computed width of the native browser scroll bar
   * @return {Number} width
   */
  Handsontable.Dom.getScrollbarWidth = function () {
    if (cachedScrollbarWidth === void 0) {
      cachedScrollbarWidth = walkontableCalculateScrollbarWidth();
    }
    return cachedScrollbarWidth;
  }
})();

/**
 * Handsontable TableView constructor
 * @param {Object} instance
 */
Handsontable.TableView = function (instance) {
  var that = this
    , $window = $(window)
    , $documentElement = $(document.documentElement);

  this.instance = instance;
  this.settings = instance.getSettings();

  instance.rootElement.data('originalStyle', instance.rootElement[0].getAttribute('style')); //needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions
  // in IE7 getAttribute('style') returns an object instead of a string, but we only support IE8+

  instance.rootElement.addClass('handsontable');

  var table = document.createElement('TABLE');
  table.className = 'htCore';
  this.THEAD = document.createElement('THEAD');
  table.appendChild(this.THEAD);
  this.TBODY = document.createElement('TBODY');
  table.appendChild(this.TBODY);

  instance.$table = $(table);
  instance.container.prepend(instance.$table);

  instance.rootElement.on('mousedown.handsontable', function (event) {
    if (!that.isTextSelectionAllowed(event.target)) {
      clearTextSelection();
      event.preventDefault();
      window.focus(); //make sure that window that contains HOT is active. Important when HOT is in iframe.
    }
  });

  $documentElement.on('keyup.' + instance.guid, function (event) {
    if (instance.selection.isInProgress() && !event.shiftKey) {
      instance.selection.finish();
    }
  });

  var isMouseDown;
  this.isMouseDown = function() {
    return isMouseDown;
  }

  $documentElement.on('mouseup.' + instance.guid, function (event) {
    if (instance.selection.isInProgress() && event.which === 1) { //is left mouse button
      instance.selection.finish();
    }

    isMouseDown = false;

    if (Handsontable.helper.isOutsideInput(document.activeElement)) {
      instance.unlisten();
    }
  });

  $documentElement.on('mousedown.' + instance.guid, function (event) {
    var next = event.target;

    if (next.shadowRoot) {
      return; //click inside Web Component
    }

    if (next !== that.wt.wtTable.spreader) { //immediate click on "spreader" means click on the right side of vertical scrollbar
      while (next !== document.documentElement) {
        if (next === null) {
          return; //click on something that was a row but now is detached (possibly because your click triggered a rerender)
        }
        if (next === instance.rootElement[0]) {
          return; //click inside container
        }
        next = next.parentNode;
      }
    }

    //function did not return until here, we have an outside click!

    if (that.settings.outsideClickDeselects) {
      instance.deselectCell();
    }
    else {
      instance.destroyEditor();
    }
  });

  instance.$table.on('selectstart', function (event) {
    if (that.settings.fragmentSelection) {
      return;
    }

    //https://github.com/handsontable/jquery-handsontable/issues/160
    //selectstart is IE only event. Prevent text from being selected when performing drag down in IE8
    event.preventDefault();
  });

  var clearTextSelection = function () {
    //http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript
    if (window.getSelection) {
      if (window.getSelection().empty) {  // Chrome
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {  // Firefox
        window.getSelection().removeAllRanges();
      }
    } else if (document.selection) {  // IE?
      document.selection.empty();
    }
  };

  var walkontableConfig = {
    debug: function () {
      return that.settings.debug;
    },
    table: table,
    stretchH: this.settings.stretchH,
    data: instance.getDataAtCell,
    totalRows: instance.countRows,
    totalColumns: instance.countCols,
    offsetRow: 0,
    fixedColumnsLeft: function () {
      return that.settings.fixedColumnsLeft;
    },
    fixedRowsTop: function () {
      return that.settings.fixedRowsTop;
    },
    renderAllRows: that.settings.renderAllRows,
    rowHeaders: function () {
      return instance.hasRowHeaders() ? [function (index, TH) {
        that.appendRowHeader(index, TH);
      }] : []
    },
    columnHeaders: function () {
      return instance.hasColHeaders() ? [function (index, TH) {
        that.appendColHeader(index, TH);
      }] : []
    },
    columnWidth: instance.getColWidth,
    rowHeight: instance.getRowHeight,
    cellRenderer: function (row, col, TD) {

      var prop = that.instance.colToProp(col)
        , cellProperties = that.instance.getCellMeta(row, col)
        , renderer = that.instance.getCellRenderer(cellProperties);

      var value = that.instance.getDataAtRowProp(row, prop);

      renderer(that.instance, TD, row, col, prop, value, cellProperties);
      Handsontable.hooks.run(that.instance, 'afterRenderer', TD, row, col, prop, value, cellProperties);

    },
    selections: [
      {
        className: 'current',
        border: {
          width: 2,
          color: '#5292F7',
          //style: 'solid', //not used
          cornerVisible: function () {
            return that.settings.fillHandle && !that.isCellEdited() && !instance.selection.isMultiple()
          }
        }
      },
      {
        className: 'area',
        border: {
          width: 1,
          color: '#89AFF9',
          //style: 'solid', // not used
          cornerVisible: function () {
            return that.settings.fillHandle && !that.isCellEdited() && instance.selection.isMultiple()
          }
        }
      },
      {
        className: 'highlight',
        highlightRowClassName: that.settings.currentRowClassName,
        highlightColumnClassName: that.settings.currentColClassName
      },
      {
        className: 'fill',
        border: {
          width: 1,
          color: 'red'
          //style: 'solid' // not used
        }
      }
    ],
    hideBorderOnMouseDownOver: function () {
      return that.settings.fragmentSelection;
    },
    onCellMouseDown: function (event, coords, TD, wt) {
      instance.listen();
      that.activeWt = wt;

      isMouseDown = true;

      if (event.button === 2 && instance.selection.inInSelection(coords)) { //right mouse button
        //do nothing
      }
      else if (event.shiftKey) {
        if (coords.row >= 0 && coords.col >= 0) {
          instance.selection.setRangeEnd(coords);
        }
      }
      else {
        if (coords.row < 0 || coords.col < 0) {
          if (coords.row < 0) {
            instance.selectCell(0, coords.col, instance.countRows() - 1, coords.col);
          }
          if (coords.col < 0) {
            instance.selectCell(coords.row, 0, coords.row, instance.countCols() - 1);
          }
        }
        else {
          instance.selection.setRangeStart(coords);
        }
      }

      Handsontable.hooks.run(instance, 'afterOnCellMouseDown', event, coords, TD);

      that.activeWt = that.wt;
    },
    /*onCellMouseOut: function (/*event, coords, TD* /) {
     if (isMouseDown && that.settings.fragmentSelection === 'single') {
     clearTextSelection(); //otherwise text selection blinks during multiple cells selection
     }
     },*/
    onCellMouseOver: function (event, coords, TD, wt) {
      that.activeWt = wt;
      if (coords.row >= 0 && coords.col >= 0) { //is not a header
        if (isMouseDown) {
          /*if (that.settings.fragmentSelection === 'single') {
           clearTextSelection(); //otherwise text selection blinks during multiple cells selection
           }*/
          instance.selection.setRangeEnd(coords);
        }
      }
      Handsontable.hooks.run(instance, 'afterOnCellMouseOver', event, coords, TD);
      that.activeWt = that.wt;
    },
    onCellCornerMouseDown: function (event) {
      event.preventDefault();
      Handsontable.hooks.run(instance, 'afterOnCellCornerMouseDown', event);
    },
    beforeDraw: function (force) {
      that.beforeRender(force);
    },
    onDraw: function(force){
      that.onDraw(force);
    },
    onScrollVertically: function () {
      instance.runHooks('afterScrollVertically');
    },
    onScrollHorizontally: function () {
      instance.runHooks('afterScrollHorizontally');
    }
  };

  Handsontable.hooks.run(instance, 'beforeInitWalkontable', walkontableConfig);

  this.wt = new Walkontable(walkontableConfig);
  this.activeWt = this.wt;

  /*$window.on('resize.' + instance.guid, function () {
    instance._registerTimeout('resizeTimeout', function () {
      instance.forceFullRender = true;
      that.render();
    }, 60);
  });*/

  $(that.wt.wtTable.spreader).on('mousedown.handsontable, contextmenu.handsontable', function (event) {
    if (event.target === that.wt.wtTable.spreader && event.which === 3) { //right mouse button exactly on spreader means right clickon the right hand side of vertical scrollbar
      event.stopPropagation();
    }
  });

  $documentElement.on('click.' + instance.guid, function () {
    if (that.settings.observeDOMVisibility) {
      if (that.wt.drawInterrupted) {
        that.instance.forceFullRender = true;
        that.render();
      }
    }
  });
};

Handsontable.TableView.prototype.isTextSelectionAllowed = function (el) {
  if ( Handsontable.helper.isInput(el) ) {
    return (true);
  }
  if (this.settings.fragmentSelection && Handsontable.Dom.isChildOf(el, this.TBODY)) {
    return (true);
  }
  return false;
};

Handsontable.TableView.prototype.isCellEdited = function () {
  var activeEditor = this.instance.getActiveEditor();
  return activeEditor && activeEditor.isOpened();
};

Handsontable.TableView.prototype.getWidth = function () {
  return this.wt.wtViewport.getWorkspaceActualWidth();
};

Handsontable.TableView.prototype.getHeight = function () {
  return this.wt.wtViewport.getWorkspaceActualHeight();
};

Handsontable.TableView.prototype.beforeRender = function (force) {
  if (force) { //force = did Walkontable decide to do full render
    Handsontable.hooks.run(this.instance, 'beforeRender', this.instance.forceFullRender); //this.instance.forceFullRender = did Handsontable request full render?
  }
};

Handsontable.TableView.prototype.onDraw = function(force){
  if (force) { //force = did Walkontable decide to do full render
    Handsontable.hooks.run(this.instance, 'afterRender', this.instance.forceFullRender); //this.instance.forceFullRender = did Handsontable request full render?
  }
};

Handsontable.TableView.prototype.render = function () {
  this.wt.draw(!this.instance.forceFullRender);
  this.instance.forceFullRender = false;
  this.instance.rootElement.triggerHandler('render.handsontable');
};

/**
 * Returns td object given coordinates
 * @param {WalkontableCellCoords} coords
 */
Handsontable.TableView.prototype.getCellAtCoords = function (coords) {
  var td = this.wt.wtTable.getCell(coords);
  if (td < 0) { //there was an exit code (cell is out of bounds)
    return null;
  }
  else {
    return td;
  }
};

/**
 * Scroll viewport to selection
 * @param {WalkontableCellCoords} coords
 */
Handsontable.TableView.prototype.scrollViewport = function (coords) {
  this.wt.scrollViewport(coords);
};

/**
 * Append row header to a TH element
 * @param row
 * @param TH
 */
Handsontable.TableView.prototype.appendRowHeader = function (row, TH) {
  var DIV = document.createElement('DIV'),
      SPAN = document.createElement('SPAN');

  DIV.className = 'relative';
  SPAN.className = 'rowHeader';

  if (row > -1) {
    Handsontable.Dom.fastInnerHTML(SPAN, this.instance.getRowHeader(row));
  } else {
    Handsontable.Dom.fastInnerText(SPAN, '\u00A0');
  }

  DIV.appendChild(SPAN);
  Handsontable.Dom.empty(TH);

  TH.appendChild(DIV);

  Handsontable.hooks.run(this.instance, 'afterGetRowHeader', row, TH);
};

/**
 * Append column header to a TH element
 * @param col
 * @param TH
 */
Handsontable.TableView.prototype.appendColHeader = function (col, TH) {
  var DIV = document.createElement('DIV')
    , SPAN = document.createElement('SPAN');

  DIV.className = 'relative';
  SPAN.className = 'colHeader';

  Handsontable.Dom.fastInnerHTML(SPAN, this.instance.getColHeader(col));
  DIV.appendChild(SPAN);

  Handsontable.Dom.empty(TH);
  TH.appendChild(DIV);
  Handsontable.hooks.run(this.instance, 'afterGetColHeader', col, TH);
};

/**
 * Given a element's left position relative to the viewport, returns maximum element width until the right edge of the viewport (before scrollbar)
 * @param {Number} left
 * @return {Number}
 */
Handsontable.TableView.prototype.maximumVisibleElementWidth = function (leftOffset) {
  this.wt.wtScrollbars.horizontal.readWindowSize();
  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
  var maxWidth = workspaceWidth - leftOffset;
  return maxWidth > 0 ? maxWidth : 0;
};

/**
 * Given a element's top position relative to the viewport, returns maximum element height until the bottom edge of the viewport (before scrollbar)
 * @param {Number} topOffset
 * @return {Number}
 */
Handsontable.TableView.prototype.maximumVisibleElementHeight = function (topOffset) {
  this.wt.wtScrollbars.vertical.readWindowSize();
  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
  var maxHeight = workspaceHeight - topOffset;
  return maxHeight > 0 ? maxHeight : 0;
};

Handsontable.TableView.prototype.mainViewIsActive = function () {
  return this.wt === this.activeWt;
};

/**
 * Utility to register editors and common namespace for keeping reference to all editor classes
 */
(function (Handsontable) {
  'use strict';

  function RegisteredEditor(editorClass) {
    var clazz, instances;

    instances = {};
    clazz = editorClass;

    this.getInstance = function (hotInstance) {
      if (!(hotInstance.guid in instances)) {
        instances[hotInstance.guid] = new clazz(hotInstance);
      }

      return instances[hotInstance.guid];
    }

  }

  var registeredEditorNames = {};
  var registeredEditorClasses = new WeakMap();

  Handsontable.editors = {

    /**
     * Registers editor under given name
     * @param {String} editorName
     * @param {Function} editorClass
     */
    registerEditor: function (editorName, editorClass) {
      var editor = new RegisteredEditor(editorClass);
      if (typeof editorName === "string") {
        registeredEditorNames[editorName] = editor;
      }
      registeredEditorClasses.set(editorClass, editor);
    },

    /**
     * Returns instance (singleton) of editor class
     * @param {String|Function} editorName/editorClass
     * @returns {Function} editorClass
     */
    getEditor: function (editorName, hotInstance) {
      var editor;
      if (typeof editorName == 'function') {
        if (!(registeredEditorClasses.get(editorName))) {
          this.registerEditor(null, editorName);
        }
        editor = registeredEditorClasses.get(editorName);
      }
      else if (typeof editorName == 'string') {
        editor = registeredEditorNames[editorName];
      }
      else {
        throw Error('Only strings and functions can be passed as "editor" parameter ');
      }

      if (!editor) {
        throw Error('No editor registered under name "' + editorName + '"');
      }

      return editor.getInstance(hotInstance);
    }

  };


})(Handsontable);

(function(Handsontable){
  'use strict';

  Handsontable.EditorManager = function(instance, priv, selection){
    var that = this;
    var $document = $(document);
    var keyCodes = Handsontable.helper.keyCode;

    var activeEditor;

    var init = function () {

      function onKeyDown(event) {

        if (!instance.isListening()) {
          return;
        }

        if (priv.settings.beforeOnKeyDown) { // HOT in HOT Plugin
          priv.settings.beforeOnKeyDown.call(instance, event);
        }

        Handsontable.hooks.run(instance, 'beforeKeyDown', event);

        if (!event.isImmediatePropagationStopped()) {

          priv.lastKeyCode = event.keyCode;
          if (selection.isSelected()) {
            var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)

            if (!activeEditor.isWaiting()) {
              if (!Handsontable.helper.isMetaKey(event.keyCode) && !ctrlDown && !that.isEditorOpened()) {
                that.openEditor('');
                event.stopPropagation(); //required by HandsontableEditor
                return;
              }
            }

            var rangeModifier = event.shiftKey ? selection.setRangeEnd : selection.setRangeStart;

              switch (event.keyCode) {

                case keyCodes.A:
                  if (ctrlDown) {
                    selection.selectAll(); //select all cells

                    event.preventDefault();
                    event.stopPropagation();
                    break;
                  }

                case keyCodes.ARROW_UP:

                  if (that.isEditorOpened() && !activeEditor.isWaiting()){
                    that.closeEditorAndSaveChanges(ctrlDown);
                  }

                  moveSelectionUp(event.shiftKey);

                  event.preventDefault();
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.ARROW_DOWN:
                  if (that.isEditorOpened() && !activeEditor.isWaiting()){
                    that.closeEditorAndSaveChanges(ctrlDown);
                  }

                  moveSelectionDown(event.shiftKey);

                  event.preventDefault();
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.ARROW_RIGHT:
                  if(that.isEditorOpened()  && !activeEditor.isWaiting()){
                    that.closeEditorAndSaveChanges(ctrlDown);
                  }

                  moveSelectionRight(event.shiftKey);

                  event.preventDefault();
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.ARROW_LEFT:
                  if(that.isEditorOpened() && !activeEditor.isWaiting()){
                    that.closeEditorAndSaveChanges(ctrlDown);
                  }

                  moveSelectionLeft(event.shiftKey);

                  event.preventDefault();
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.TAB:
                  var tabMoves = typeof priv.settings.tabMoves === 'function' ? priv.settings.tabMoves(event) : priv.settings.tabMoves;
                  if (event.shiftKey) {
                    selection.transformStart(-tabMoves.row, -tabMoves.col); //move selection left
                  }
                  else {
                    selection.transformStart(tabMoves.row, tabMoves.col, true); //move selection right (add a new column if needed)
                  }
                  event.preventDefault();
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.BACKSPACE:
                case keyCodes.DELETE:
                  selection.empty(event);
                  that.prepareEditor();
                  event.preventDefault();
                  break;

                case keyCodes.F2: /* F2 */
                  that.openEditor();
                  event.preventDefault(); //prevent Opera from opening Go to Page dialog
                  break;

                case keyCodes.ENTER: /* return/enter */
                  if(that.isEditorOpened()){

                    if (activeEditor.state !== Handsontable.EditorState.WAITING){
                      that.closeEditorAndSaveChanges(ctrlDown);
                    }

                    moveSelectionAfterEnter(event.shiftKey);

                  } else {

                    if (instance.getSettings().enterBeginsEditing){
                      that.openEditor();
                    } else {
                      moveSelectionAfterEnter(event.shiftKey);
                    }

                  }

                  event.preventDefault(); //don't add newline to field
                  event.stopImmediatePropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.ESCAPE:
                  if(that.isEditorOpened()){
                    that.closeEditorAndRestoreOriginalValue(ctrlDown);
                  }
                  event.preventDefault();
                  break;

                case keyCodes.HOME:
                  if (event.ctrlKey || event.metaKey) {
                    rangeModifier(new WalkontableCellCoords(0, priv.selRange.from.col));
                  }
                  else {
                    rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, 0));
                  }
                  event.preventDefault(); //don't scroll the window
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.END:
                  if (event.ctrlKey || event.metaKey) {
                    rangeModifier(new WalkontableCellCoords(instance.countRows() - 1, priv.selRange.from.col));
                  }
                  else {
                    rangeModifier(new WalkontableCellCoords(priv.selRange.from.row, instance.countCols() - 1));
                  }
                  event.preventDefault(); //don't scroll the window
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.PAGE_UP:
                  selection.transformStart(-instance.countVisibleRows(), 0);
                  instance.view.wt.scrollVertical(-instance.countVisibleRows());
                  instance.view.render();
                  event.preventDefault(); //don't page up the window
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                case keyCodes.PAGE_DOWN:
                  selection.transformStart(instance.countVisibleRows(), 0);
                  instance.view.wt.scrollVertical(instance.countVisibleRows());
                  instance.view.render();
                  event.preventDefault(); //don't page down the window
                  event.stopPropagation(); //required by HandsontableEditor
                  break;

                default:
                  break;
              }

          }
        }
      }
      $document.on('keydown.handsontable.' + instance.guid, onKeyDown);

      function onDblClick(event, coords, elem) {
        if(elem.nodeName == "TD") { //may be TD or TH
          //that.instance.destroyEditor();
          that.openEditor();
        }
      }

      instance.view.wt.update('onCellDblClick', onDblClick);

      instance.addHook('afterDestroy', function(){
        $document.off('keydown.handsontable.' + instance.guid);
      });

      function moveSelectionAfterEnter(shiftKey){
        var enterMoves = typeof priv.settings.enterMoves === 'function' ? priv.settings.enterMoves(event) : priv.settings.enterMoves;

        if (shiftKey) {
          selection.transformStart(-enterMoves.row, -enterMoves.col); //move selection up
        }
        else {
          selection.transformStart(enterMoves.row, enterMoves.col, true); //move selection down (add a new row if needed)
        }
      }

      function moveSelectionUp(shiftKey){
        if (shiftKey) {
          selection.transformEnd(-1, 0);
        }
        else {
          selection.transformStart(-1, 0);
        }
      }

      function moveSelectionDown(shiftKey){
        if (shiftKey) {
          selection.transformEnd(1, 0); //expanding selection down with shift
        }
        else {
          selection.transformStart(1, 0); //move selection down
        }
      }

      function moveSelectionRight(shiftKey){
        if (shiftKey) {
          selection.transformEnd(0, 1);
        }
        else {
          selection.transformStart(0, 1);
        }
      }

      function moveSelectionLeft(shiftKey){
        if (shiftKey) {
          selection.transformEnd(0, -1);
        }
        else {
          selection.transformStart(0, -1);
        }
      }
    };

    /**
     * Destroy current editor, if exists
     * @param {Boolean} revertOriginal
     */
    this.destroyEditor = function (revertOriginal) {
      this.closeEditor(revertOriginal);
    };

    this.getActiveEditor = function () {
      return activeEditor;
    };

    /**
     * Prepare text input to be displayed at given grid cell
     */
    this.prepareEditor = function () {

      if (activeEditor && activeEditor.isWaiting()){

        this.closeEditor(false, false, function(dataSaved){
          if(dataSaved){
            that.prepareEditor();
          }
        });

        return;
      }

      var row = priv.selRange.highlight.row;
      var col = priv.selRange.highlight.col;
      var prop = instance.colToProp(col);
      var td = instance.getCell(row, col);
      var originalValue = instance.getDataAtCell(row, col);
      var cellProperties = instance.getCellMeta(row, col);

      var editorClass = instance.getCellEditor(cellProperties);
      activeEditor = Handsontable.editors.getEditor(editorClass, instance);

      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);

    };

    this.isEditorOpened = function () {
      return activeEditor.isOpened();
    };

    this.openEditor = function (initialValue) {
      if (!activeEditor.cellProperties.readOnly){
        activeEditor.beginEditing(initialValue);
      }
    };

    this.closeEditor = function (restoreOriginalValue, ctrlDown, callback) {

      if (!activeEditor){
        if(callback) {
          callback(false);
        }
      }
      else {
        activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);
      }
    };

    this.closeEditorAndSaveChanges = function(ctrlDown){
      return this.closeEditor(false, ctrlDown);
    };

    this.closeEditorAndRestoreOriginalValue = function(ctrlDown){
      return this.closeEditor(true, ctrlDown);
    };

    init();
  };

})(Handsontable);

/**
 * Utility to register renderers and common namespace for keeping reference to all renderers classes
 */
(function (Handsontable) {
  'use strict';

  var registeredRenderers = {};

  Handsontable.renderers = {

    /**
     * Registers renderer under given name
     * @param {String} rendererName
     * @param {Function} rendererFunction
     */
    registerRenderer: function (rendererName, rendererFunction) {
      registeredRenderers[rendererName] = rendererFunction
    },

    /**
     * @param {String|Function} rendererName/rendererFunction
     * @returns {Function} rendererFunction
     */
    getRenderer: function (rendererName) {
      if (typeof rendererName == 'function'){
        return rendererName;
      }

      if (typeof rendererName != 'string'){
        throw Error('Only strings and functions can be passed as "renderer" parameter ');
      }

      if (!(rendererName in registeredRenderers)) {
        throw Error('No editor registered under name "' + rendererName + '"');
      }

      return registeredRenderers[rendererName];
    }

  };


})(Handsontable);

/**
 * Returns true if keyCode represents a printable character
 * @param {Number} keyCode
 * @return {Boolean}
 */
Handsontable.helper.isPrintableChar = function (keyCode) {
  return ((keyCode == 32) || //space
    (keyCode >= 48 && keyCode <= 57) || //0-9
    (keyCode >= 96 && keyCode <= 111) || //numpad
    (keyCode >= 186 && keyCode <= 192) || //;=,-./`
    (keyCode >= 219 && keyCode <= 222) || //[]{}\|"'
    keyCode >= 226 || //special chars (229 for Asian chars)
    (keyCode >= 65 && keyCode <= 90)); //a-z
};

Handsontable.helper.isMetaKey = function (keyCode) {
  var keyCodes = Handsontable.helper.keyCode;
  var metaKeys = [
    keyCodes.ARROW_DOWN,
    keyCodes.ARROW_UP,
    keyCodes.ARROW_LEFT,
    keyCodes.ARROW_RIGHT,
    keyCodes.HOME,
    keyCodes.END,
    keyCodes.DELETE,
    keyCodes.BACKSPACE,
    keyCodes.F1,
    keyCodes.F2,
    keyCodes.F3,
    keyCodes.F4,
    keyCodes.F5,
    keyCodes.F6,
    keyCodes.F7,
    keyCodes.F8,
    keyCodes.F9,
    keyCodes.F10,
    keyCodes.F11,
    keyCodes.F12,
    keyCodes.TAB,
    keyCodes.PAGE_DOWN,
    keyCodes.PAGE_UP,
    keyCodes.ENTER,
    keyCodes.ESCAPE,
    keyCodes.SHIFT,
    keyCodes.CAPS_LOCK,
    keyCodes.ALT
  ];

  return metaKeys.indexOf(keyCode) != -1;
};

Handsontable.helper.isCtrlKey = function (keyCode) {

  var keys = Handsontable.helper.keyCode;

  return [keys.CONTROL_LEFT, 224, keys.COMMAND_LEFT, keys.COMMAND_RIGHT].indexOf(keyCode) != -1;
};

/**
 * Converts a value to string
 * @param value
 * @return {String}
 */
Handsontable.helper.stringify = function (value) {
  switch (typeof value) {
    case 'string':
    case 'number':
      return value + '';
      break;

    case 'object':
      if (value === null) {
        return '';
      }
      else {
        return value.toString();
      }
      break;

    case 'undefined':
      return '';
      break;

    default:
      return value.toString();
  }
};

/**
 * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc
 * @param index
 * @returns {String}
 */
Handsontable.helper.spreadsheetColumnLabel = function (index) {
  var dividend = index + 1;
  var columnLabel = '';
  var modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % 26;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / 26, 10);
  }
  return columnLabel;
};

/**
 * Checks if value of n is a numeric one
 * http://jsperf.com/isnan-vs-isnumeric/4
 * @param n
 * @returns {boolean}
 */
Handsontable.helper.isNumeric = function (n) {
    var t = typeof n;
    return t == 'number' ? !isNaN(n) && isFinite(n) :
           t == 'string' ? !n.length ? false :
           n.length == 1 ? /\d/.test(n) :
           /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(n) :
           t == 'object' ? !!n && typeof n.valueOf() == "number" && !(n instanceof Date) : false;
};

Handsontable.helper.isArray = function (obj) {
  return Object.prototype.toString.call(obj).match(/array/i) !== null;
};

/**
 * Checks if child is a descendant of given parent node
 * http://stackoverflow.com/questions/2234979/how-to-check-in-javascript-if-one-element-is-a-child-of-another
 * @param parent
 * @param child
 * @returns {boolean}
 */
Handsontable.helper.isDescendant = function (parent, child) {
  var node = child.parentNode;
  while (node != null) {
    if (node == parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};

/**
 * Generates a random hex string. Used as namespace for Handsontable instance events.
 * @return {String} - 16 character random string: "92b1bfc74ec4"
 */
Handsontable.helper.randomString = function () {
  return walkontableRandomString();
};

/**
 * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.
 * Creates temporary dummy function to call it as constructor.
 * Described in ticket: https://github.com/handsontable/jquery-handsontable/pull/516
 * @param  {Object} Child  child class
 * @param  {Object} Parent parent class
 * @return {Object}        extended Child
 */
Handsontable.helper.inherit = function (Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  return Child;
};

/**
 * Perform shallow extend of a target object with extension's own properties
 * @param {Object} target An object that will receive the new properties
 * @param {Object} extension An object containing additional properties to merge into the target
 */
Handsontable.helper.extend = function (target, extension) {
  for (var i in extension) {
    if (extension.hasOwnProperty(i)) {
      target[i] = extension[i];
    }
  }
};

Handsontable.helper.getPrototypeOf = function (obj) {
  var prototype;

  if(typeof obj.__proto__ == "object"){
    prototype = obj.__proto__;
  } else {
    var oldConstructor,
        constructor = obj.constructor;

    if (typeof obj.constructor == "function") {
      oldConstructor = constructor;

      if (delete obj.constructor){
        constructor = obj.constructor; // get real constructor
        obj.constructor = oldConstructor; // restore constructor
      }


    }

    prototype = constructor ? constructor.prototype : null; // needed for IE

  }

  return prototype;
};

/**
 * Factory for columns constructors.
 * @param {Object} GridSettings
 * @param {Array} conflictList
 * @return {Object} ColumnSettings
 */
Handsontable.helper.columnFactory = function (GridSettings, conflictList) {
  function ColumnSettings () {}

  Handsontable.helper.inherit(ColumnSettings, GridSettings);

  // Clear conflict settings
  for (var i = 0, len = conflictList.length; i < len; i++) {
    ColumnSettings.prototype[conflictList[i]] = void 0;
  }

  return ColumnSettings;
};

Handsontable.helper.translateRowsToColumns = function (input) {
  var i
    , ilen
    , j
    , jlen
    , output = []
    , olen = 0;

  for (i = 0, ilen = input.length; i < ilen; i++) {
    for (j = 0, jlen = input[i].length; j < jlen; j++) {
      if (j == olen) {
        output.push([]);
        olen++;
      }
      output[j].push(input[i][j])
    }
  }
  return output;
};

Handsontable.helper.to2dArray = function (arr) {
  var i = 0
    , ilen = arr.length;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i++;
  }
};

Handsontable.helper.extendArray = function (arr, extension) {
  var i = 0
    , ilen = extension.length;
  while (i < ilen) {
    arr.push(extension[i]);
    i++;
  }
};

/**
 * Determines if the given DOM element is an input field.
 * Notice: By 'input' we mean input, textarea and select nodes
 * @param element - DOM element
 * @returns {boolean}
 */
Handsontable.helper.isInput = function (element) {
  var inputs = ['INPUT', 'SELECT', 'TEXTAREA'];

  return inputs.indexOf(element.nodeName) > -1;
}

/**
 * Determines if the given DOM element is an input field placed OUTSIDE of HOT.
 * Notice: By 'input' we mean input, textarea and select nodes
 * @param element - DOM element
 * @returns {boolean}
 */
Handsontable.helper.isOutsideInput = function (element) {
  return Handsontable.helper.isInput(element) && element.className.indexOf('handsontableInput') == -1;
};

Handsontable.helper.keyCode = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  MOUSE_MIDDLE: 2,
  BACKSPACE: 8,
  COMMA: 188,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  CONTROL_LEFT: 91,
  COMMAND_LEFT: 17,
  COMMAND_RIGHT: 93,
  ALT: 18,
  HOME: 36,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PERIOD: 190,
  SPACE: 32,
  SHIFT: 16,
  CAPS_LOCK: 20,
  TAB: 9,
  ARROW_RIGHT: 39,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_DOWN: 40,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  A: 65,
  X: 88,
  C: 67,
  V: 86
};

/**
 * Determines whether given object is a plain Object.
 * Note: String and Array are not plain Objects
 * @param {*} obj
 * @returns {boolean}
 */
Handsontable.helper.isObject = function (obj) {
  return Object.prototype.toString.call(obj) == '[object Object]';
};

/**
 * Determines whether given object is an Array.
 * Note: String is not an Array
 * @param {*} obj
 * @returns {boolean}
 */
Handsontable.helper.isArray = function(obj){
  return Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) == '[object Array]';
};

Handsontable.helper.pivot = function (arr) {
  var pivotedArr = [];

  if(!arr || arr.length == 0 || !arr[0] || arr[0].length == 0){
    return pivotedArr;
  }

  var rowCount = arr.length;
  var colCount = arr[0].length;

  for(var i = 0; i < rowCount; i++){
    for(var j = 0; j < colCount; j++){
      if(!pivotedArr[j]){
        pivotedArr[j] = [];
      }

      pivotedArr[j][i] = arr[i][j];
    }
  }

  return pivotedArr;

};

Handsontable.helper.proxy = function (fun, context) {
  return function () {
    return fun.apply(context, arguments);
  };
};

/**
 * Factory that produces a function for searching methods (or any properties) which could be defined directly in
 * table configuration or implicitly, within cell type definition.
 *
 * For example: renderer can be defined explicitly using "renderer" property in column configuration or it can be
 * defined implicitly using "type" property.
 *
 * Methods/properties defined explicitly always takes precedence over those defined through "type".
 *
 * If the method/property is not found in an object, searching is continued recursively through prototype chain, until
 * it reaches the Object.prototype.
 *
 *
 * @param methodName {String} name of the method/property to search (i.e. 'renderer', 'validator', 'copyable')
 * @param allowUndefined {Boolean} [optional] if false, the search is continued if methodName has not been found in cell "type"
 * @returns {Function}
 */
Handsontable.helper.cellMethodLookupFactory = function (methodName, allowUndefined) {

  allowUndefined = typeof allowUndefined == 'undefined' ? true : allowUndefined;

  return function cellMethodLookup (row, col) {

    return (function getMethodFromProperties(properties) {

      if (!properties){

        return;                       //method not found

      }
      else if (properties.hasOwnProperty(methodName) && properties[methodName] !== void 0) { //check if it is own and is not empty

        return properties[methodName];  //method defined directly

      } else if (properties.hasOwnProperty('type') && properties.type) { //check if it is own and is not empty

        var type;

        if(typeof properties.type != 'string' ){
          throw new Error('Cell type must be a string ');
        }

        type = translateTypeNameToObject(properties.type);

        if (type.hasOwnProperty(methodName)) {
          return type[methodName]; //method defined in type.
        } else if (allowUndefined) {
          return; //method does not defined in type (eg. validator), returns undefined
        }

      }

      return getMethodFromProperties(Handsontable.helper.getPrototypeOf(properties));

    })(typeof row == 'number' ? this.getCellMeta(row, col) : row);

  };

  function translateTypeNameToObject(typeName) {
    var type = Handsontable.cellTypes[typeName];

    if(typeof type == 'undefined'){
      throw new Error('You declared cell type "' + typeName + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
    }

    return type;
  }

};

Handsontable.helper.toString = function (obj) {
  return '' + obj;
};
(function (Handsontable) {
  'use strict';

  /**
   * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names
   * TODO refactor arguments of methods getRange, getText to be numbers (not objects)
   * TODO remove priv, GridSettings from object constructor
   *
   * @param instance
   * @param priv
   * @param GridSettings
   * @constructor
   */
  Handsontable.DataMap = function (instance, priv, GridSettings) {
    this.instance = instance;
    this.priv = priv;
    this.GridSettings = GridSettings;
    this.dataSource = this.instance.getSettings().data;

    if (this.dataSource[0]) {
      this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);
    }
    else {
      this.duckSchema = {};
    }
    this.createMap();
  };

  Handsontable.DataMap.prototype.DESTINATION_RENDERER = 1;
  Handsontable.DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;

  Handsontable.DataMap.prototype.recursiveDuckSchema = function (obj) {
    var schema;
    if ($.isPlainObject(obj)) {
      schema = {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if ($.isPlainObject(obj[i])) {
            schema[i] = this.recursiveDuckSchema(obj[i]);
          }
          else {
            schema[i] = null;
          }
        }
      }
    }
    else {
      schema = [];
    }
    return schema;
  };

  Handsontable.DataMap.prototype.recursiveDuckColumns = function (schema, lastCol, parent) {
    var prop, i;
    if (typeof lastCol === 'undefined') {
      lastCol = 0;
      parent = '';
    }
    if ($.isPlainObject(schema)) {
      for (i in schema) {
        if (schema.hasOwnProperty(i)) {
          if (schema[i] === null) {
            prop = parent + i;
            this.colToPropCache.push(prop);
            this.propToColCache.set(prop, lastCol);

            lastCol++;
          }
          else {
            lastCol = this.recursiveDuckColumns(schema[i], lastCol, i + '.');
          }
        }
      }
    }
    return lastCol;
  };

  Handsontable.DataMap.prototype.createMap = function () {
    if (typeof this.getSchema() === "undefined") {
      throw new Error("trying to create `columns` definition but you didnt' provide `schema` nor `data`");
    }
    var i, ilen, schema = this.getSchema();
    this.colToPropCache = [];
    this.propToColCache = new MultiMap();
    var columns = this.instance.getSettings().columns;
    if (columns) {
      for (i = 0, ilen = columns.length; i < ilen; i++) {

        if (typeof columns[i].data != 'undefined'){
          this.colToPropCache[i] = columns[i].data;
          this.propToColCache.set(columns[i].data, i);
        }

      }
    }
    else {
      this.recursiveDuckColumns(schema);
    }
  };

  Handsontable.DataMap.prototype.colToProp = function (col) {
    col = Handsontable.hooks.execute(this.instance, 'modifyCol', col);
    if (this.colToPropCache && typeof this.colToPropCache[col] !== 'undefined') {
      return this.colToPropCache[col];
    }
    else {
      return col;
    }
  };

  Handsontable.DataMap.prototype.propToCol = function (prop) {
    var col;
    if (typeof this.propToColCache.get(prop) !== 'undefined') {
      col = this.propToColCache.get(prop);
    } else {
      col = prop;
    }
    col = Handsontable.hooks.execute(this.instance, 'modifyCol', col);
    return col;
  };

  Handsontable.DataMap.prototype.getSchema = function () {
    var schema = this.instance.getSettings().dataSchema;
    if (schema) {
      if (typeof schema === 'function') {
        return schema();
      }
      return schema;
    }
    return this.duckSchema;
  };

  /**
   * Creates row at the bottom of the data array
   * @param {Number} [index] Optional. Index of the row before which the new row will be inserted
   */
  Handsontable.DataMap.prototype.createRow = function (index, amount, createdAutomatically) {
    var row
      , colCount = this.instance.countCols()
      , numberOfCreatedRows = 0
      , currentIndex;

    if (!amount) {
      amount = 1;
    }

    if (typeof index !== 'number' || index >= this.instance.countRows()) {
      index = this.instance.countRows();
    }

    currentIndex = index;
    var maxRows = this.instance.getSettings().maxRows;
    while (numberOfCreatedRows < amount && this.instance.countRows() < maxRows) {

      if (this.instance.dataType === 'array') {
        row = [];
        for (var c = 0; c < colCount; c++) {
          row.push(null);
        }
      }
      else if (this.instance.dataType === 'function') {
        row = this.instance.getSettings().dataSchema(index);
      }
      else {
        row = $.extend(true, {}, this.getSchema());
      }

      if (index === this.instance.countRows()) {
        this.dataSource.push(row);
      }
      else {
        this.dataSource.splice(index, 0, row);
      }

      numberOfCreatedRows++;
      currentIndex++;
    }


    Handsontable.hooks.run(this.instance, 'afterCreateRow', index, numberOfCreatedRows, createdAutomatically);
    this.instance.forceFullRender = true; //used when data was changed

    return numberOfCreatedRows;
  };

  /**
   * Creates col at the right of the data array
   * @param {Number} [index] Optional. Index of the column before which the new column will be inserted
   *   * @param {Number} [amount] Optional.
   */
  Handsontable.DataMap.prototype.createCol = function (index, amount, createdAutomatically) {
    if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
      throw new Error("Cannot create new column. When data source in an object, " +
        "you can only have as much columns as defined in first data row, data schema or in the 'columns' setting." +
        "If you want to be able to add new columns, you have to use array datasource.");
    }
    var rlen = this.instance.countRows()
      , data = this.dataSource
      , constructor
      , numberOfCreatedCols = 0
      , currentIndex;

    if (!amount) {
      amount = 1;
    }

    currentIndex = index;

    var maxCols = this.instance.getSettings().maxCols;
    while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {
      constructor = Handsontable.helper.columnFactory(this.GridSettings, this.priv.columnsSettingConflicts);
      if (typeof index !== 'number' || index >= this.instance.countCols()) {
        for (var r = 0; r < rlen; r++) {
          if (typeof data[r] === 'undefined') {
            data[r] = [];
          }
          data[r].push(null);
        }
        // Add new column constructor
        this.priv.columnSettings.push(constructor);
      }
      else {
        for (var r = 0; r < rlen; r++) {
          data[r].splice(currentIndex, 0, null);
        }
        // Add new column constructor at given index
        this.priv.columnSettings.splice(currentIndex, 0, constructor);
      }

      numberOfCreatedCols++;
      currentIndex++;
    }

    Handsontable.hooks.run(this.instance, 'afterCreateCol', index, numberOfCreatedCols, createdAutomatically);
    this.instance.forceFullRender = true; //used when data was changed

    return numberOfCreatedCols;
  };

  /**
   * Removes row from the data array
   * @param {Number} [index] Optional. Index of the row to be removed. If not provided, the last row will be removed
   * @param {Number} [amount] Optional. Amount of the rows to be removed. If not provided, one row will be removed
   */
  Handsontable.DataMap.prototype.removeRow = function (index, amount) {
    if (!amount) {
      amount = 1;
    }
    if (typeof index !== 'number') {
      index = -amount;
    }

    index = (this.instance.countRows() + index) % this.instance.countRows();

    // We have to map the physical row ids to logical and than perform removing with (possibly) new row id
    var logicRows = this.physicalRowsToLogical(index, amount);

    var actionWasNotCancelled = Handsontable.hooks.execute(this.instance, 'beforeRemoveRow', index, amount);

    if (actionWasNotCancelled === false) {
      return;
    }

    var data = this.dataSource;
    var newData = data.filter(function (row, index) {
      return logicRows.indexOf(index) == -1;
    });

    data.length = 0;
    Array.prototype.push.apply(data, newData);

    Handsontable.hooks.run(this.instance, 'afterRemoveRow', index, amount);

    this.instance.forceFullRender = true; //used when data was changed
  };

  /**
   * Removes column from the data array
   * @param {Number} [index] Optional. Index of the column to be removed. If not provided, the last column will be removed
   * @param {Number} [amount] Optional. Amount of the columns to be removed. If not provided, one column will be removed
   */
  Handsontable.DataMap.prototype.removeCol = function (index, amount) {
    if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
      throw new Error("cannot remove column with object data source or columns option specified");
    }
    if (!amount) {
      amount = 1;
    }
    if (typeof index !== 'number') {
      index = -amount;
    }

    index = (this.instance.countCols() + index) % this.instance.countCols();

    var actionWasNotCancelled = Handsontable.hooks.execute(this.instance, 'beforeRemoveCol', index, amount);

    if (actionWasNotCancelled === false) {
      return;
    }

    var data = this.dataSource;
    for (var r = 0, rlen = this.instance.countRows(); r < rlen; r++) {
      data[r].splice(index, amount);
    }
    this.priv.columnSettings.splice(index, amount);

    Handsontable.hooks.run(this.instance, 'afterRemoveCol', index, amount);
    this.instance.forceFullRender = true; //used when data was changed
  };

  /**
   * Add / removes data from the column
   * @param {Number} col Index of column in which do you want to do splice.
   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
   */
  Handsontable.DataMap.prototype.spliceCol = function (col, index, amount/*, elements...*/) {
    var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];

    var colData = this.instance.getDataAtCol(col);
    var removed = colData.slice(index, index + amount);
    var after = colData.slice(index + amount);

    Handsontable.helper.extendArray(elements, after);
    var i = 0;
    while (i < amount) {
      elements.push(null); //add null in place of removed elements
      i++;
    }
    Handsontable.helper.to2dArray(elements);
    this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');

    return removed;
  };

  /**
   * Add / removes data from the row
   * @param {Number} row Index of row in which do you want to do splice.
   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
   * param {...*} elements Optional. The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
   */
  Handsontable.DataMap.prototype.spliceRow = function (row, index, amount/*, elements...*/) {
    var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];

    var rowData = this.instance.getSourceDataAtRow(row);
    var removed = rowData.slice(index, index + amount);
    var after = rowData.slice(index + amount);

    Handsontable.helper.extendArray(elements, after);
    var i = 0;
    while (i < amount) {
      elements.push(null); //add null in place of removed elements
      i++;
    }
    this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');

    return removed;
  };

  /**
   * Returns single value from the data array
   * @param {Number} row
   * @param {Number} prop
   */
  Handsontable.DataMap.prototype.get = function (row, prop) {
    row = Handsontable.hooks.execute(this.instance, 'modifyRow', row);
    if (typeof prop === 'string' && prop.indexOf('.') > -1) {
      var sliced = prop.split(".");
      var out = this.dataSource[row];
      if (!out) {
        return null;
      }
      for (var i = 0, ilen = sliced.length; i < ilen; i++) {
        out = out[sliced[i]];
        if (typeof out === 'undefined') {
          return null;
        }
      }
      return out;
    }
    else if (typeof prop === 'function') {
      /**
       *  allows for interacting with complex structures, for example
       *  d3/jQuery getter/setter properties:
       *
       *    {columns: [{
         *      data: function(row, value){
         *        if(arguments.length === 1){
         *          return row.property();
         *        }
         *        row.property(value);
         *      }
         *    }]}
       */
      return prop(this.dataSource.slice(
        row,
        row + 1
      )[0]);
    }
    else {
      return this.dataSource[row] ? this.dataSource[row][prop] : null;
    }
  };

  var copyableLookup = Handsontable.helper.cellMethodLookupFactory('copyable', false);

  /**
   * Returns single value from the data array (intended for clipboard copy to an external application)
   * @param {Number} row
   * @param {Number} prop
   * @return {String}
   */
  Handsontable.DataMap.prototype.getCopyable = function (row, prop) {
    if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
      return this.get(row, prop);
    }
    return '';
  };

  /**
   * Saves single value to the data array
   * @param {Number} row
   * @param {Number} prop
   * @param {String} value
   * @param {String} [source] Optional. Source of hook runner.
   */
  Handsontable.DataMap.prototype.set = function (row, prop, value, source) {
    row = Handsontable.hooks.execute(this.instance, 'modifyRow', row, source || "datamapGet");
    if (typeof prop === 'string' && prop.indexOf('.') > -1) {
      var sliced = prop.split(".");
      var out = this.dataSource[row];
      for (var i = 0, ilen = sliced.length - 1; i < ilen; i++) {
        out = out[sliced[i]];
      }
      out[sliced[i]] = value;
    }
    else if (typeof prop === 'function') {
      /* see the `function` handler in `get` */
      prop(this.dataSource.slice(
        row,
        row + 1
      )[0], value);
    }
    else {
      this.dataSource[row][prop] = value;
    }
  };

  /**
   * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.
   * The trick is, the physical row id (stored in settings.data) is not necessary the same
   * as the logical (displayed) row id (e.g. when sorting is applied).
   */
  Handsontable.DataMap.prototype.physicalRowsToLogical = function (index, amount) {
    var totalRows = this.instance.countRows();
    var physicRow = (totalRows + index) % totalRows;
    var logicRows = [];
    var rowsToRemove = amount;
    var row;

    while (physicRow < totalRows && rowsToRemove) {
      row = Handsontable.hooks.execute(this.instance, 'modifyRow', physicRow);
      logicRows.push(row);

      rowsToRemove--;
      physicRow++;
    }

    return logicRows;
  };

  /**
   * Clears the data array
   */
  Handsontable.DataMap.prototype.clear = function () {
    for (var r = 0; r < this.instance.countRows(); r++) {
      for (var c = 0; c < this.instance.countCols(); c++) {
        this.set(r, this.colToProp(c), '');
      }
    }
  };

  /**
   * Returns the data array
   * @return {Array}
   */
  Handsontable.DataMap.prototype.getAll = function () {
    return this.dataSource;
  };

  /**
   * Returns data range as array
   * @param {Object} start Start selection position
   * @param {Object} end End selection position
   * @param {Number} destination Destination of datamap.get
   * @return {Array}
   */
  Handsontable.DataMap.prototype.getRange = function (start, end, destination) {
    var r, rlen, c, clen, output = [], row;
    var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
    rlen = Math.max(start.row, end.row);
    clen = Math.max(start.col, end.col);
    for (r = Math.min(start.row, end.row); r <= rlen; r++) {
      row = [];
      for (c = Math.min(start.col, end.col); c <= clen; c++) {
        row.push(getFn.call(this, r, this.colToProp(c)));
      }
      output.push(row);
    }
    return output;
  };

  /**
   * Return data as text (tab separated columns)
   * @param {Object} start (Optional) Start selection position
   * @param {Object} end (Optional) End selection position
   * @return {String}
   */
  Handsontable.DataMap.prototype.getText = function (start, end) {
    return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_RENDERER));
  };

  /**
   * Return data as copyable text (tab separated columns intended for clipboard copy to an external application)
   * @param {Object} start (Optional) Start selection position
   * @param {Object} end (Optional) End selection position
   * @return {String}
   */
  Handsontable.DataMap.prototype.getCopyableText = function (start, end) {
    return SheetClip.stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));
  };

})(Handsontable);

(function (Handsontable) {
  'use strict';

  /*
    Adds appropriate CSS class to table cell, based on cellProperties
   */
  Handsontable.renderers.cellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {
    if (cellProperties.className) {
      if(TD.className) {
        TD.className = TD.className + " " + cellProperties.className;
      } else {
        TD.className = cellProperties.className;
      }

    }

    if (cellProperties.readOnly) {
      Handsontable.Dom.addClass(TD, cellProperties.readOnlyCellClassName);
    }

    if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
      Handsontable.Dom.addClass(TD, cellProperties.invalidCellClassName);
    }

    if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
      Handsontable.Dom.addClass(TD, cellProperties.noWordWrapClassName);
    }

    if (!value && cellProperties.placeholder) {
      Handsontable.Dom.addClass(TD, cellProperties.placeholderCellClassName);
    }
  }

})(Handsontable);
/**
 * Default text renderer
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
 */
(function (Handsontable) {
  'use strict';

  var TextRenderer = function (instance, TD, row, col, prop, value, cellProperties) {

    Handsontable.renderers.cellDecorator.apply(this, arguments);

    if (!value && cellProperties.placeholder) {
      value = cellProperties.placeholder;
    }

    var escaped = Handsontable.helper.stringify(value);

    if (cellProperties.rendererTemplate) {
      Handsontable.Dom.empty(TD);
      var TEMPLATE = document.createElement('TEMPLATE');
      TEMPLATE.setAttribute('bind', '{{}}');
      TEMPLATE.innerHTML = cellProperties.rendererTemplate;
      HTMLTemplateElement.decorate(TEMPLATE);
      TEMPLATE.model = instance.getSourceDataAtRow(row);
      TD.appendChild(TEMPLATE);
    }
    else {
      Handsontable.Dom.fastInnerText(TD, escaped); //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
    }

  };

  //Handsontable.TextRenderer = TextRenderer; //Left for backward compatibility
  Handsontable.renderers.TextRenderer = TextRenderer;
  Handsontable.renderers.registerRenderer('text', TextRenderer);

})(Handsontable);

(function (Handsontable) {

  var clonableWRAPPER = document.createElement('DIV');
  clonableWRAPPER.className = 'htAutocompleteWrapper';

  var clonableARROW = document.createElement('DIV');
  clonableARROW.className = 'htAutocompleteArrow';
  clonableARROW.appendChild(document.createTextNode('\u25BC'));
//this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips

  var wrapTdContentWithWrapper = function(TD, WRAPPER){
    WRAPPER.innerHTML = TD.innerHTML;
    Handsontable.Dom.empty(TD);
    TD.appendChild(WRAPPER);
  };

  /**
   * Autocomplete renderer
   * @param {Object} instance Handsontable instance
   * @param {Element} TD Table cell where to render
   * @param {Number} row
   * @param {Number} col
   * @param {String|Number} prop Row object property name
   * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
   * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
   */
  var AutocompleteRenderer = function (instance, TD, row, col, prop, value, cellProperties) {

    var WRAPPER = clonableWRAPPER.cloneNode(true); //this is faster than createElement
    var ARROW = clonableARROW.cloneNode(true); //this is faster than createElement

    Handsontable.renderers.TextRenderer(instance, TD, row, col, prop, value, cellProperties);

    TD.appendChild(ARROW);
    Handsontable.Dom.addClass(TD, 'htAutocomplete');


    if (!TD.firstChild) { //http://jsperf.com/empty-node-if-needed
      //otherwise empty fields appear borderless in demo/renderers.html (IE)
      TD.appendChild(document.createTextNode('\u00A0')); //\u00A0 equals &nbsp; for a text node
      //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
    }

    if (!instance.acArrowListener) {
      //not very elegant but easy and fast
      instance.acArrowListener = function () {
        instance.view.wt.getSetting('onCellDblClick', null, new WalkontableCellCoords(row, col), TD);
      };

      instance.rootElement.on('mousedown.htAutocompleteArrow', '.htAutocompleteArrow', instance.acArrowListener); //this way we don't bind event listener to each arrow. We rely on propagation instead

      //We need to unbind the listener after the table has been destroyed
      instance.addHookOnce('afterDestroy', function () {
        this.rootElement.off('mousedown.htAutocompleteArrow');
      });

    }
  };

  Handsontable.AutocompleteRenderer = AutocompleteRenderer;
  Handsontable.renderers.AutocompleteRenderer = AutocompleteRenderer;
  Handsontable.renderers.registerRenderer('autocomplete', AutocompleteRenderer);
})(Handsontable);
/**
 * Checkbox renderer
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
 */
(function (Handsontable) {

  'use strict';

  var clonableINPUT = document.createElement('INPUT');
  clonableINPUT.className = 'htCheckboxRendererInput';
  clonableINPUT.type = 'checkbox';
  clonableINPUT.setAttribute('autocomplete', 'off');

  var CheckboxRenderer = function (instance, TD, row, col, prop, value, cellProperties) {

    if (typeof cellProperties.checkedTemplate === "undefined") {
      cellProperties.checkedTemplate = true;
    }
    if (typeof cellProperties.uncheckedTemplate === "undefined") {
      cellProperties.uncheckedTemplate = false;
    }

    Handsontable.Dom.empty(TD); //TODO identify under what circumstances this line can be removed

    var INPUT = clonableINPUT.cloneNode(false); //this is faster than createElement

    if (value === cellProperties.checkedTemplate || value === Handsontable.helper.stringify(cellProperties.checkedTemplate)) {
      INPUT.checked = true;
      TD.appendChild(INPUT);
    }
    else if (value === cellProperties.uncheckedTemplate || value === Handsontable.helper.stringify(cellProperties.uncheckedTemplate)) {
      TD.appendChild(INPUT);
    }
    else if (value === null) { //default value
      INPUT.className += ' noValue';
      TD.appendChild(INPUT);
    }
    else {
      Handsontable.Dom.fastInnerText(TD, '#bad value#'); //this is faster than innerHTML. See: https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
    }

    var $input = $(INPUT);

    if (cellProperties.readOnly) {
      $input.on('click', function (event) {
        event.preventDefault();
      });
    }
    else {
      $input.on('mousedown', function (event) {
        event.stopPropagation(); //otherwise can confuse cell mousedown handler
      });

      $input.on('mouseup', function (event) {
        event.stopPropagation(); //otherwise can confuse cell dblclick handler
      });

      $input.on('change', function(){
        if (this.checked) {
          instance.setDataAtRowProp(row, prop, cellProperties.checkedTemplate);
        }
        else {
          instance.setDataAtRowProp(row, prop, cellProperties.uncheckedTemplate);
        }
      });
    }

    if(!instance.CheckboxRenderer || !instance.CheckboxRenderer.beforeKeyDownHookBound){
      instance.CheckboxRenderer = {
        beforeKeyDownHookBound : true
      };

      instance.addHook('beforeKeyDown', function(event){
        if(event.keyCode == Handsontable.helper.keyCode.SPACE){

          var cell, checkbox, cellProperties;

          var selRange = instance.getSelectedRange();
          var topLeft = selRange.getTopLeftCorner();
          var bottomRight = selRange.getBottomRightCorner();

          for(var row = topLeft.row; row <= bottomRight.row; row++ ){
            for(var col = topLeft.col; col <= bottomRight.col; col++){
              cell = instance.getCell(row, col);
              cellProperties = instance.getCellMeta(row, col);

              checkbox = cell.querySelectorAll('input[type=checkbox]');

              if(checkbox.length > 0 && !cellProperties.readOnly){

                if(!event.isImmediatePropagationStopped()){
                  event.stopImmediatePropagation();
                  event.preventDefault();
                }

                for(var i = 0, len = checkbox.length; i < len; i++){
                  checkbox[i].checked = !checkbox[i].checked;
                  $(checkbox[i]).trigger('change');
                }

              }

            }
          }
        }
      });
    }

  };

  Handsontable.CheckboxRenderer = CheckboxRenderer;
  Handsontable.renderers.CheckboxRenderer = CheckboxRenderer;
  Handsontable.renderers.registerRenderer('checkbox', CheckboxRenderer);

})(Handsontable);
/**
 * Numeric cell renderer
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
 */
(function (Handsontable) {

  'use strict';

  var NumericRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
    if (Handsontable.helper.isNumeric(value)) {
      if (typeof cellProperties.language !== 'undefined') {
        numeral.language(cellProperties.language)
      }
      value = numeral(value).format(cellProperties.format || '0'); //docs: http://numeraljs.com/
      Handsontable.Dom.addClass(TD, 'htNumeric');
    }
    Handsontable.renderers.TextRenderer(instance, TD, row, col, prop, value, cellProperties);
  };

  Handsontable.NumericRenderer = NumericRenderer; //Left for backward compatibility with versions prior 0.10.0
  Handsontable.renderers.NumericRenderer = NumericRenderer;
  Handsontable.renderers.registerRenderer('numeric', NumericRenderer);

})(Handsontable);
(function(Handosntable){

  'use strict';

  var PasswordRenderer = function (instance, TD, row, col, prop, value, cellProperties) {
    Handsontable.renderers.TextRenderer.apply(this, arguments);

    value = TD.innerHTML;

    var hash;
    var hashLength = cellProperties.hashLength || value.length;
    var hashSymbol = cellProperties.hashSymbol || '*';

    for( hash = ''; hash.split(hashSymbol).length - 1 < hashLength; hash += hashSymbol);

    Handsontable.Dom.fastInnerHTML(TD, hash);

  };

  Handosntable.PasswordRenderer = PasswordRenderer;
  Handosntable.renderers.PasswordRenderer = PasswordRenderer;
  Handosntable.renderers.registerRenderer('password', PasswordRenderer);

})(Handsontable);
(function (Handsontable) {

  function HtmlRenderer(instance, TD, row, col, prop, value, cellProperties){

    Handsontable.renderers.cellDecorator.apply(this, arguments);

    Handsontable.Dom.fastInnerHTML(TD, value);
  }

  Handsontable.renderers.registerRenderer('html', HtmlRenderer);
  Handsontable.renderers.HtmlRenderer = HtmlRenderer;

})(Handsontable);

(function (Handsontable) {
  'use strict';

  Handsontable.EditorState = {
    VIRGIN: 'STATE_VIRGIN', //before editing
    EDITING: 'STATE_EDITING',
    WAITING: 'STATE_WAITING', //waiting for async validation
    FINISHED: 'STATE_FINISHED'
  };

  function BaseEditor(instance) {
    this.instance = instance;
    this.state = Handsontable.EditorState.VIRGIN;

    this._opened = false;
    this._closeCallback = null;

    this.init();
  }

  BaseEditor.prototype._fireCallbacks = function(result) {
    if(this._closeCallback){
      this._closeCallback(result);
      this._closeCallback = null;
    }

  }

  BaseEditor.prototype.init = function(){};

  BaseEditor.prototype.getValue = function(){
    throw Error('Editor getValue() method unimplemented');
  };

  BaseEditor.prototype.setValue = function(newValue){
    throw Error('Editor setValue() method unimplemented');
  };

  BaseEditor.prototype.open = function(){
    throw Error('Editor open() method unimplemented');
  };

  BaseEditor.prototype.close = function(){
    throw Error('Editor close() method unimplemented');
  };

  BaseEditor.prototype.prepare = function(row, col, prop, td, originalValue, cellProperties){
    this.TD = td;
    this.row = row;
    this.col = col;
    this.prop = prop;
    this.originalValue = originalValue;
    this.cellProperties = cellProperties;

    this.state = Handsontable.EditorState.VIRGIN;
  };

  BaseEditor.prototype.extend = function(){
    var baseClass = this.constructor;
    function Editor(){
      baseClass.apply(this, arguments);
    }

    function inherit(Child, Parent){
      function Bridge() {
      }

      Bridge.prototype = Parent.prototype;
      Child.prototype = new Bridge();
      Child.prototype.constructor = Child;
      return Child;
    }

    return inherit(Editor, baseClass);
  };

  BaseEditor.prototype.saveValue = function (val, ctrlDown) {
    if (ctrlDown) { //if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)
      var sel = this.instance.getSelected();
      this.instance.populateFromArray(sel[0], sel[1], val, sel[2], sel[3], 'edit');
    }
    else {
      this.instance.populateFromArray(this.row, this.col, val, null, null, 'edit');
    }
  };

  BaseEditor.prototype.beginEditing = function(initialValue){
    if (this.state != Handsontable.EditorState.VIRGIN) {
      return;
    }

    this.instance.view.scrollViewport(new WalkontableCellCoords(this.row, this.col));
    this.instance.view.render();

    this.state = Handsontable.EditorState.EDITING;

    initialValue = typeof initialValue == 'string' ? initialValue : this.originalValue;

    this.setValue(Handsontable.helper.stringify(initialValue));

    this.open();
    this._opened = true;
    this.focus();

    this.instance.view.render(); //only rerender the selections (FillHandle should disappear when beginediting is triggered)
  };

  BaseEditor.prototype.finishEditing = function (restoreOriginalValue, ctrlDown, callback) {

    if (callback) {
      var previousCloseCallback = this._closeCallback;
      this._closeCallback = function (result) {
        if(previousCloseCallback){
          previousCloseCallback(result);
        }

        callback(result);
      };
    }

    if (this.isWaiting()) {
      return;
    }

    if (this.state == Handsontable.EditorState.VIRGIN) {
      var that = this;
      setTimeout(function () {
        that._fireCallbacks(true);
      });
      return;
    }

    if (this.state == Handsontable.EditorState.EDITING) {

      if (restoreOriginalValue) {

        this.cancelChanges();
        return;

      }


      var val = [
        [String.prototype.trim.call(this.getValue())] //String.prototype.trim is defined in Walkontable polyfill.js
      ];

      this.state = Handsontable.EditorState.WAITING;

      this.saveValue(val, ctrlDown);

      if(this.instance.getCellValidator(this.cellProperties)){
        var that = this;
        this.instance.addHookOnce('afterValidate', function (result) {
          that.state = Handsontable.EditorState.FINISHED;
          that.discardEditor(result);
        });
      } else {
        this.state = Handsontable.EditorState.FINISHED;
        this.discardEditor(true);
      }

    }
  };

  BaseEditor.prototype.cancelChanges = function () {
    this.state = Handsontable.EditorState.FINISHED;
    this.discardEditor();
  };

  BaseEditor.prototype.discardEditor = function (result) {
    if (this.state !== Handsontable.EditorState.FINISHED) {
      return;
    }

    if (result === false && this.cellProperties.allowInvalid !== true) { //validator was defined and failed

      this.instance.selectCell(this.row, this.col);
      this.focus();

      this.state = Handsontable.EditorState.EDITING;

      this._fireCallbacks(false);
    }
    else {
      this.close();
      this._opened = false;

      this.state = Handsontable.EditorState.VIRGIN;

      this._fireCallbacks(true);
    }

  };

  BaseEditor.prototype.isOpened = function(){
    return this._opened;
  };

  BaseEditor.prototype.isWaiting = function () {
    return this.state === Handsontable.EditorState.WAITING;
  };

  Handsontable.editors.BaseEditor = BaseEditor;

})(Handsontable);

(function(Handsontable){
  var TextEditor = Handsontable.editors.BaseEditor.prototype.extend();

  TextEditor.prototype.init = function(){
    this.createElements();
    this.bindEvents();
  };

  TextEditor.prototype.getValue = function(){
    return this.TEXTAREA.value
  };

  TextEditor.prototype.setValue = function(newValue){
    this.TEXTAREA.value = newValue;
  };

  var onBeforeKeyDown =  function onBeforeKeyDown(event){

    var instance = this;
    var that = instance.getActiveEditor();

    var keyCodes = Handsontable.helper.keyCode;
    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)


    //Process only events that have been fired in the editor
    if (event.target !== that.TEXTAREA || event.isImmediatePropagationStopped()){
      return;
    }

    if (event.keyCode === 17 || event.keyCode === 224 || event.keyCode === 91 || event.keyCode === 93) {
      //when CTRL or its equivalent is pressed and cell is edited, don't prepare selectable text in textarea
      event.stopImmediatePropagation();
      return;
    }

    switch (event.keyCode) {
      case keyCodes.ARROW_RIGHT:
        if (Handsontable.Dom.getCaretPosition(that.TEXTAREA) !== that.TEXTAREA.value.length) {
          event.stopImmediatePropagation();
        }
        break;

      case keyCodes.ARROW_LEFT: /* arrow left */
        if (Handsontable.Dom.getCaretPosition(that.TEXTAREA) !== 0) {
          event.stopImmediatePropagation();
        }
        break;

      case keyCodes.ENTER:
        var selected = that.instance.getSelected();
        var isMultipleSelection = !(selected[0] === selected[2] && selected[1] === selected[3]);
        if ((ctrlDown && !isMultipleSelection) || event.altKey) { //if ctrl+enter or alt+enter, add new line
          if(that.isOpened()){
            that.setValue(that.getValue() + '\n');
            that.focus();
          } else {
            that.beginEditing(that.originalValue + '\n')
          }
          event.stopImmediatePropagation();
        }
        event.preventDefault(); //don't add newline to field
        break;

      case keyCodes.A:
      case keyCodes.X:
      case keyCodes.C:
      case keyCodes.V:
        if(ctrlDown){
          event.stopImmediatePropagation(); //CTRL+A, CTRL+C, CTRL+V, CTRL+X should only work locally when cell is edited (not in table context)
          break;
        }
      case keyCodes.BACKSPACE:
      case keyCodes.DELETE:
      case keyCodes.HOME:
      case keyCodes.END:
        event.stopImmediatePropagation(); //backspace, delete, home, end should only work locally when cell is edited (not in table context)
        break;
    }

  };

  TextEditor.prototype.open = function(){
    this.refreshDimensions(); //need it instantly, to prevent https://github.com/handsontable/jquery-handsontable/issues/348

    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
  };

  TextEditor.prototype.close = function(){
    this.textareaParentStyle.display = 'none';

    if (document.activeElement === this.TEXTAREA) {
      this.instance.listen(); //don't refocus the table if user focused some cell outside of HT on purpose
    }

    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
  };

  TextEditor.prototype.focus = function(){
    this.TEXTAREA.focus();
    Handsontable.Dom.setCaretPosition(this.TEXTAREA, this.TEXTAREA.value.length);
  };

  TextEditor.prototype.createElements = function () {
    this.$body = $(document.body);

    this.TEXTAREA = document.createElement('TEXTAREA');
    this.$textarea = $(this.TEXTAREA);

    Handsontable.Dom.addClass(this.TEXTAREA, 'handsontableInput');

    this.textareaStyle = this.TEXTAREA.style;
    this.textareaStyle.width = 0;
    this.textareaStyle.height = 0;

    this.TEXTAREA_PARENT = document.createElement('DIV');
    Handsontable.Dom.addClass(this.TEXTAREA_PARENT, 'handsontableInputHolder');

    this.textareaParentStyle = this.TEXTAREA_PARENT.style;
    this.textareaParentStyle.top = 0;
    this.textareaParentStyle.left = 0;
    this.textareaParentStyle.display = 'none';

    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);

    this.instance.rootElement[0].appendChild(this.TEXTAREA_PARENT);

    var that = this;
    Handsontable.hooks.add('afterRender', function () {
      that.instance._registerTimeout('refresh_editor_dimensions', function () {
        that.refreshDimensions();
      }, 0);
    });
  };

  TextEditor.prototype.refreshDimensions = function () {
    if (this.state !== Handsontable.EditorState.EDITING) {
      return;
    }

    ///start prepare textarea position
    this.TD = this.instance.getCell(this.row, this.col);
    if (!this.TD) {
      //TD is outside of the viewport. Otherwise throws exception when scrolling the table while a cell is edited
      return;
    }
    var $td = $(this.TD); //because old td may have been scrolled out with scrollViewport
    var currentOffset = Handsontable.Dom.offset(this.TD);
    var containerOffset = Handsontable.Dom.offset(this.instance.rootElement[0]);
    var editTop = currentOffset.top - containerOffset.top - 1;
    var editLeft = currentOffset.left - containerOffset.left - 1;

    var settings = this.instance.getSettings();
    var rowHeadersCount = settings.rowHeaders === false ? 0 : 1;
    var colHeadersCount = settings.colHeaders === false ? 0 : 1;

    if (editTop < 0) {
      editTop = 0;
    }
    if (editLeft < 0) {
      editLeft = 0;
    }

    if (rowHeadersCount > 0 && parseInt($td.css('border-top-width'), 10) > 0) {
      editTop += 1;
    }
    if (colHeadersCount > 0 && parseInt($td.css('border-left-width'), 10) > 0) {
      editLeft += 1;
    }

    this.textareaParentStyle.top = editTop + 'px';
    this.textareaParentStyle.left = editLeft + 'px';
    ///end prepare textarea position


    var cellTopOffset = this.TD.offsetTop,
      cellLeftOffset = this.TD.offsetLeft - this.instance.view.wt.wtScrollbars.horizontal.getScrollPosition();

    var width = $td.width()
      , maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 10 //10 is TEXTAREAs border and padding
      , height = $td.outerHeight() - 4
      , maxHeight = this.instance.view.maximumVisibleElementHeight(cellTopOffset)-2; //10 is TEXTAREAs border and padding

    if (parseInt($td.css('border-top-width'), 10) > 0) {
      height -= 1;
    }
    if (parseInt($td.css('border-left-width'), 10) > 0) {
      if (rowHeadersCount > 0) {
        width -= 1;
      }
    }


    //in future may change to pure JS http://stackoverflow.com/questions/454202/creating-a-textarea-with-auto-resize
    this.$textarea.autoResize({
      minHeight: Math.min(height, maxHeight),
      maxHeight: maxHeight, //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
      minWidth: Math.min(width, maxWidth),
      maxWidth: maxWidth, //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
      animate: false,
      extraSpace: 0
    });

    this.textareaParentStyle.display = 'block';
  };

  TextEditor.prototype.bindEvents = function () {
    this.$textarea.on('cut.editor', function (event) {
      event.stopPropagation();
    });

    this.$textarea.on('paste.editor', function (event) {
      event.stopPropagation();
    });
  };

  Handsontable.editors.TextEditor = TextEditor;
  Handsontable.editors.registerEditor('text', Handsontable.editors.TextEditor);

})(Handsontable);

(function(Handsontable){

  //Blank editor, because all the work is done by renderer
  var CheckboxEditor = Handsontable.editors.BaseEditor.prototype.extend();

  CheckboxEditor.prototype.beginEditing = function () {
    var checkbox = this.TD.querySelector('input[type="checkbox"]');

    if (checkbox) {
      $(checkbox).trigger('click');
    }

  };

  CheckboxEditor.prototype.finishEditing = function () {};

  CheckboxEditor.prototype.init = function () {};
  CheckboxEditor.prototype.open = function () {};
  CheckboxEditor.prototype.close = function () {};
  CheckboxEditor.prototype.getValue = function () {};
  CheckboxEditor.prototype.setValue = function () {};
  CheckboxEditor.prototype.focus = function () {};

  Handsontable.editors.CheckboxEditor = CheckboxEditor;
  Handsontable.editors.registerEditor('checkbox', CheckboxEditor);

})(Handsontable);


(function (Handsontable) {
  var DateEditor = Handsontable.editors.TextEditor.prototype.extend();

  DateEditor.prototype.init = function () {
    if (!$.datepicker) {
      throw new Error("jQuery UI Datepicker dependency not found. Did you forget to include jquery-ui.custom.js or its substitute?");
    }

    Handsontable.editors.TextEditor.prototype.init.apply(this, arguments);

    this.isCellEdited = false;
    var that = this;

    this.instance.addHook('afterDestroy', function () {
      that.destroyElements();
    })

  };

  DateEditor.prototype.createElements = function () {
    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);

    this.datePicker = document.createElement('DIV');
    Handsontable.Dom.addClass(this.datePicker, 'htDatepickerHolder');
    this.datePickerStyle = this.datePicker.style;
    this.datePickerStyle.position = 'absolute';
    this.datePickerStyle.top = 0;
    this.datePickerStyle.left = 0;
    this.datePickerStyle.zIndex = 99;
    document.body.appendChild(this.datePicker);
    this.$datePicker = $(this.datePicker);

    var that = this;
    var defaultOptions = {
      dateFormat: "yy-mm-dd",
      showButtonPanel: true,
      changeMonth: true,
      changeYear: true,
      onSelect: function (dateStr) {
        that.setValue(dateStr);
        that.finishEditing(false);
      }
    };
    this.$datePicker.datepicker(defaultOptions);

    /**
     * Prevent recognizing clicking on jQuery Datepicker as clicking outside of table
     */
    this.$datePicker.on('mousedown', function (event) {
      event.stopPropagation();
    });

    this.hideDatepicker();
  };

  DateEditor.prototype.destroyElements = function () {
    this.$datePicker.datepicker('destroy');
    this.$datePicker.remove();
  };

  DateEditor.prototype.open = function () {
    Handsontable.editors.TextEditor.prototype.open.call(this);
    this.showDatepicker();
  };

  DateEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {
    this.hideDatepicker();
    Handsontable.editors.TextEditor.prototype.finishEditing.apply(this, arguments);
  };

  DateEditor.prototype.showDatepicker = function () {
    var $td = $(this.TD);
    var offset = $td.offset();
    this.datePickerStyle.top = (offset.top + $td.height()) + 'px';
    this.datePickerStyle.left = offset.left + 'px';

    var dateOptions = {
      defaultDate: this.originalValue || void 0
    };
    $.extend(dateOptions, this.cellProperties);
    this.$datePicker.datepicker("option", dateOptions);
    if (this.originalValue) {
      this.$datePicker.datepicker("setDate", this.originalValue);
    }
    this.datePickerStyle.display = 'block';
  };

  DateEditor.prototype.hideDatepicker = function () {
    this.datePickerStyle.display = 'none';
  };


  Handsontable.editors.DateEditor = DateEditor;
  Handsontable.editors.registerEditor('date', DateEditor);
})(Handsontable);
/**
 * This is inception. Using Handsontable as Handsontable editor
 */
(function (Handsontable) {
  "use strict";

  var HandsontableEditor = Handsontable.editors.TextEditor.prototype.extend();

  HandsontableEditor.prototype.createElements = function () {
    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);

    var DIV = document.createElement('DIV');
    DIV.className = 'handsontableEditor';
    this.TEXTAREA_PARENT.appendChild(DIV);

    this.$htContainer = $(DIV);
    this.$htContainer.handsontable();
  };

  HandsontableEditor.prototype.prepare = function (td, row, col, prop, value, cellProperties) {

    Handsontable.editors.TextEditor.prototype.prepare.apply(this, arguments);

    var parent = this;

    var options = {
      startRows: 0,
      startCols: 0,
      minRows: 0,
      minCols: 0,
      className: 'listbox',
      copyPaste: false,
      cells: function () {
        return {
          readOnly: true
        }
      },
      fillHandle: false,
      afterOnCellMouseDown: function () {
        var value = this.getValue();
        if (value !== void 0) { //if the value is undefined then it means we don't want to set the value
          parent.setValue(value);
        }
        parent.instance.destroyEditor();
      },
      beforeOnKeyDown: function (event) {
        var instance = this;

        switch (event.keyCode) {
          case Handsontable.helper.keyCode.ESCAPE:
            parent.instance.destroyEditor(true);
            event.stopImmediatePropagation();
            event.preventDefault();
            break;

          case Handsontable.helper.keyCode.ENTER: //enter
            var sel = instance.getSelected();
            var value = this.getDataAtCell(sel[0], sel[1]);
            if (value !== void 0) { //if the value is undefined then it means we don't want to set the value
              parent.setValue(value);
            }
            parent.instance.destroyEditor();
            break;

          case Handsontable.helper.keyCode.ARROW_UP:
            if (instance.getSelected() && instance.getSelected()[0] == 0 && !parent.cellProperties.strict){
              instance.deselectCell();
              parent.instance.listen();
              parent.focus();
              event.preventDefault();
              event.stopImmediatePropagation();
            }
            break;
        }
      }
    };

    if (this.cellProperties.handsontable) {
      options = $.extend(options, cellProperties.handsontable);
    }
    this.$htContainer.handsontable('destroy');
    this.$htContainer.handsontable(options);
  };

  var onBeforeKeyDown = function (event) {

    if (event.isImmediatePropagationStopped()) {
      return;
    }

    var editor = this.getActiveEditor();
    var innerHOT = editor.$htContainer.handsontable('getInstance');

    if (event.keyCode == Handsontable.helper.keyCode.ARROW_DOWN) {

      if (!innerHOT.getSelected()){
        innerHOT.selectCell(0, 0);
      } else {
        var selectedRow = innerHOT.getSelected()[0];
        var rowToSelect = selectedRow < innerHOT.countRows() - 1 ? selectedRow + 1 : selectedRow;

        innerHOT.selectCell(rowToSelect, 0);
      }

      event.preventDefault();
      event.stopImmediatePropagation();
    }

  };

  HandsontableEditor.prototype.open = function () {

    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);

    Handsontable.editors.TextEditor.prototype.open.apply(this, arguments);

    this.$htContainer.handsontable('render');

    if (this.cellProperties.strict) {
      this.$htContainer.handsontable('selectCell', 0, 0);
      this.$textarea[0].style.visibility = 'hidden';
    } else {
      this.$htContainer.handsontable('deselectCell');
      this.$textarea[0].style.visibility = 'visible';
    }

    Handsontable.Dom.setCaretPosition(this.$textarea[0], 0, this.$textarea[0].value.length);

  };

  HandsontableEditor.prototype.close = function () {

    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
    this.instance.listen();

    Handsontable.editors.TextEditor.prototype.close.apply(this, arguments);
  };

  HandsontableEditor.prototype.focus = function () {

    this.instance.listen();

    Handsontable.editors.TextEditor.prototype.focus.apply(this, arguments);
  };

  HandsontableEditor.prototype.beginEditing = function (initialValue) {
    var onBeginEditing = this.instance.getSettings().onBeginEditing;
    if (onBeginEditing && onBeginEditing() === false) {
      return;
    }

    Handsontable.editors.TextEditor.prototype.beginEditing.apply(this, arguments);

  };

  HandsontableEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {
    if (this.$htContainer.handsontable('isListening')) { //if focus is still in the HOT editor
      this.instance.listen(); //return the focus to the parent HOT instance
    }

    if (this.$htContainer.handsontable('getSelected')) {
      var value = this.$htContainer.handsontable('getInstance').getValue();
      if (value !== void 0) { //if the value is undefined then it means we don't want to set the value
        this.setValue(value);
      }
    }

    return Handsontable.editors.TextEditor.prototype.finishEditing.apply(this, arguments);
  };

  Handsontable.editors.HandsontableEditor = HandsontableEditor;
  Handsontable.editors.registerEditor('handsontable', HandsontableEditor);

})(Handsontable);






(function (Handsontable) {
  var AutocompleteEditor = Handsontable.editors.HandsontableEditor.prototype.extend();

  AutocompleteEditor.prototype.init = function () {
    Handsontable.editors.HandsontableEditor.prototype.init.apply(this, arguments);
    this.$htContainer.handsontable('updateSettings', {height: this.getDropdownHeight()});

    this.query = null;
    this.choices = [];
  };

  AutocompleteEditor.prototype.createElements = function(){
    Handsontable.editors.HandsontableEditor.prototype.createElements.apply(this, arguments);

    this.$htContainer.addClass('autocompleteEditor');

  };

  AutocompleteEditor.prototype.bindEvents = function(){

    var that = this;
    this.$textarea.on('keydown.autocompleteEditor', function(event){
      if(!Handsontable.helper.isMetaKey(event.keyCode) || [Handsontable.helper.keyCode.BACKSPACE, Handsontable.helper.keyCode.DELETE].indexOf(event.keyCode) != -1){
        setTimeout(function () {
          that.queryChoices(that.$textarea.val());
        });
      } else if (event.keyCode == Handsontable.helper.keyCode.ENTER && that.cellProperties.strict !== true){
        that.$htContainer.handsontable('deselectCell');
      }

    });

    this.$htContainer.on('mouseenter', function () {
      that.$htContainer.handsontable('deselectCell');
    });

    Handsontable.editors.HandsontableEditor.prototype.bindEvents.apply(this, arguments);

  };

  var onBeforeKeyDownInner;

  AutocompleteEditor.prototype.open = function () {

    Handsontable.editors.HandsontableEditor.prototype.open.apply(this, arguments);

    this.$textarea[0].style.visibility = 'visible';
    this.focus();

    var choicesListHot =  this.$htContainer.handsontable('getInstance');
    var that = this;
    choicesListHot.updateSettings({
      'colWidths': [Handsontable.Dom.outerWidth(this.TEXTAREA) - 2],
      afterRenderer: function (TD, row, col, prop, value) {
        var caseSensitive = this.getCellMeta(row, col).filteringCaseSensitive === true;
        var indexOfMatch =  caseSensitive ? value.indexOf(this.query) : value.toLowerCase().indexOf(that.query.toLowerCase());

        if(indexOfMatch != -1){
          var match = value.substr(indexOfMatch, that.query.length);
          TD.innerHTML = value.replace(match, '<strong>' + match + '</strong>');
        }
      }
    });

    onBeforeKeyDownInner = function (event) {
      var instance = this;

      if (event.keyCode == Handsontable.helper.keyCode.ARROW_UP){
        if (instance.getSelected() && instance.getSelected()[0] == 0){

          if(!parent.cellProperties.strict){
            instance.deselectCell();
          }

          parent.instance.listen();
          parent.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      }

    };

    choicesListHot.addHook('beforeKeyDown', onBeforeKeyDownInner);

    this.queryChoices(this.TEXTAREA.value);

  };

  AutocompleteEditor.prototype.close = function () {

    this.$htContainer.handsontable('getInstance').removeHook('beforeKeyDown', onBeforeKeyDownInner);

    Handsontable.editors.HandsontableEditor.prototype.close.apply(this, arguments);
  };

  AutocompleteEditor.prototype.queryChoices = function(query){

    this.query = query;

    if (typeof this.cellProperties.source == 'function'){
      var that = this;

      this.cellProperties.source(query, function(choices){
        that.updateChoicesList(choices)
      });

    } else if (Handsontable.helper.isArray(this.cellProperties.source)) {

      var choices;

      if(!query || this.cellProperties.filter === false){
        choices = this.cellProperties.source;
      } else {

        var filteringCaseSensitive = this.cellProperties.filteringCaseSensitive === true;
        var lowerCaseQuery = query.toLowerCase();

        choices = this.cellProperties.source.filter(function(choice){

          if (filteringCaseSensitive) {
            return choice.indexOf(query) != -1;
          } else {
            return choice.toLowerCase().indexOf(lowerCaseQuery) != -1;
          }

        });
      }

      this.updateChoicesList(choices)

    } else {
      this.updateChoicesList([]);
    }

  };

  AutocompleteEditor.prototype.updateChoicesList = function (choices) {

     this.choices = choices;

    this.$htContainer.handsontable('loadData', Handsontable.helper.pivot([choices]));

    if(this.cellProperties.strict === true){
      this.highlightBestMatchingChoice();
    }

    this.focus();
  };

  AutocompleteEditor.prototype.highlightBestMatchingChoice = function () {
    var bestMatchingChoice = this.findBestMatchingChoice();

    if ( typeof bestMatchingChoice == 'undefined' && this.cellProperties.allowInvalid === false){
      bestMatchingChoice = 0;
    }

    if(typeof bestMatchingChoice == 'undefined'){
      this.$htContainer.handsontable('deselectCell');
    } else {
      this.$htContainer.handsontable('selectCell', bestMatchingChoice, 0);
    }

  };

  AutocompleteEditor.prototype.findBestMatchingChoice = function(){
    var bestMatch = {};
    var valueLength = this.getValue().length;
    var currentItem;
    var indexOfValue;
    var charsLeft;


    for(var i = 0, len = this.choices.length; i < len; i++){
      currentItem = this.choices[i];

      if(valueLength > 0){
        indexOfValue = currentItem.indexOf(this.getValue())
      } else {
        indexOfValue = currentItem === this.getValue() ? 0 : -1;
      }

      if(indexOfValue == -1) continue;

      charsLeft =  currentItem.length - indexOfValue - valueLength;

      if( typeof bestMatch.indexOfValue == 'undefined'
        || bestMatch.indexOfValue > indexOfValue
        || ( bestMatch.indexOfValue == indexOfValue && bestMatch.charsLeft > charsLeft ) ){

        bestMatch.indexOfValue = indexOfValue;
        bestMatch.charsLeft = charsLeft;
        bestMatch.index = i;

      }

    }


    return bestMatch.index;
  };

  AutocompleteEditor.prototype.getDropdownHeight = function(){
    //return 10 * this.$htContainer.handsontable('getInstance').getRowHeight(0);
    //sorry, we can't measure row height before it was rendered. Let's use fixed height for now
    return 230;
  };


  Handsontable.editors.AutocompleteEditor = AutocompleteEditor;
  Handsontable.editors.registerEditor('autocomplete', AutocompleteEditor);

})(Handsontable);

(function(Handsontable){

  var PasswordEditor = Handsontable.editors.TextEditor.prototype.extend();

  PasswordEditor.prototype.createElements = function () {
    Handsontable.editors.TextEditor.prototype.createElements.apply(this, arguments);

    this.TEXTAREA = document.createElement('input');
    this.TEXTAREA.setAttribute('type', 'password');
    this.TEXTAREA.className = 'handsontableInput';
    this.textareaStyle = this.TEXTAREA.style;
    this.textareaStyle.width = 0;
    this.textareaStyle.height = 0;
    this.$textarea = $(this.TEXTAREA);

    Handsontable.Dom.empty(this.TEXTAREA_PARENT);
    this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);

  };

  Handsontable.editors.PasswordEditor = PasswordEditor;
  Handsontable.editors.registerEditor('password', PasswordEditor);

})(Handsontable);

(function (Handsontable) {

  var SelectEditor = Handsontable.editors.BaseEditor.prototype.extend();

  SelectEditor.prototype.init = function(){
    this.select = document.createElement('SELECT');
    Handsontable.Dom.addClass(this.select, 'htSelectEditor');
    this.select.style.display = 'none';
    this.instance.rootElement[0].appendChild(this.select);
  };

  SelectEditor.prototype.prepare = function(){
    Handsontable.editors.BaseEditor.prototype.prepare.apply(this, arguments);


    var selectOptions = this.cellProperties.selectOptions;
    var options;

    if (typeof selectOptions == 'function'){
      options =  this.prepareOptions(selectOptions(this.row, this.col, this.prop))
    } else {
      options =  this.prepareOptions(selectOptions);
    }

    Handsontable.Dom.empty(this.select);

    for (var option in options){
      if (options.hasOwnProperty(option)){
        var optionElement = document.createElement('OPTION');
        optionElement.value = option;
        Handsontable.Dom.fastInnerHTML(optionElement, options[option]);
        this.select.appendChild(optionElement);
      }
    }
  };

  SelectEditor.prototype.prepareOptions = function(optionsToPrepare){

    var preparedOptions = {};

    if (Handsontable.helper.isArray(optionsToPrepare)){
      for(var i = 0, len = optionsToPrepare.length; i < len; i++){
        preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
      }
    }
    else if (typeof optionsToPrepare == 'object') {
      preparedOptions = optionsToPrepare;
    }

    return preparedOptions;

  };

  SelectEditor.prototype.getValue = function () {
    return this.select.value;
  };

  SelectEditor.prototype.setValue = function (value) {
    this.select.value = value;
  };

  var onBeforeKeyDown = function (event) {
    var instance = this;
    var editor = instance.getActiveEditor();

    switch (event.keyCode){
      case Handsontable.helper.keyCode.ARROW_UP:

        var previousOption = editor.select.find('option:selected').prev();

        if (previousOption.length == 1){
          previousOption.prop('selected', true);
        }

        event.stopImmediatePropagation();
        event.preventDefault();
        break;

      case Handsontable.helper.keyCode.ARROW_DOWN:

        var nextOption = editor.select.find('option:selected').next();

        if (nextOption.length == 1){
          nextOption.prop('selected', true);
        }

        event.stopImmediatePropagation();
        event.preventDefault();
        break;
    }
  };

  SelectEditor.prototype.open = function () {
    var width = Handsontable.Dom.outerWidth(this.TD); //important - group layout reads together for better performance
    var height = Handsontable.Dom.outerHeight(this.TD);
    var rootOffset = Handsontable.Dom.offset(this.instance.rootElement[0]);
    var tdOffset = Handsontable.Dom.offset(this.TD);

    this.select.style.height = height + 'px';
    this.select.style.minWidth = width + 'px';
    this.select.style.top = tdOffset.top - rootOffset.top + 'px';
    this.select.style.left = tdOffset.left - rootOffset.left + 'px';
    this.select.style.margin = '0px';
    this.select.style.display = '';

    this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
  };

  SelectEditor.prototype.close = function () {
    this.select.style.display = 'none';
    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
  };

  SelectEditor.prototype.focus = function () {
    this.select.focus();
  };

  Handsontable.editors.SelectEditor = SelectEditor;
  Handsontable.editors.registerEditor('select', SelectEditor);

})(Handsontable);

(function (Handsontable) {

  var DropdownEditor = Handsontable.editors.AutocompleteEditor.prototype.extend();

  DropdownEditor.prototype.prepare = function () {
    Handsontable.editors.AutocompleteEditor.prototype.prepare.apply(this, arguments);

    this.cellProperties.filter = false;
    this.cellProperties.strict = true;

  };


  Handsontable.editors.DropdownEditor = DropdownEditor;
  Handsontable.editors.registerEditor('dropdown', DropdownEditor);


})(Handsontable);
/**
 * Numeric cell validator
 * @param {*} value - Value of edited cell
 * @param {*} callback - Callback called with validation result
 */
Handsontable.NumericValidator = function (value, callback) {
  if (value === null) {
    value = '';
  }
  callback(/^-?\d*(\.|\,)?\d*$/.test(value));
};
/**
 * Function responsible for validation of autocomplete value
 * @param {*} value - Value of edited cell
 * @param {*} calback - Callback called with validation result
 */
var process = function (value, callback) {

  var originalVal  = value;
  var lowercaseVal = typeof originalVal === 'string' ? originalVal.toLowerCase() : null;

  return function (source) {
    var found = false;
    for (var s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true; //perfect match
        break;
      }
      else if (lowercaseVal === source[s].toLowerCase()) {
        // changes[i][3] = source[s]; //good match, fix the case << TODO?
        found = true;
        break;
      }
    }

    callback(found);
  }
};

/**
 * Autocomplete cell validator
 * @param {*} value - Value of edited cell
 * @param {*} calback - Callback called with validation result
 */
Handsontable.AutocompleteValidator = function (value, callback) {
  if (this.strict && this.source) {
    typeof this.source === 'function' ? this.source(value, process(value, callback)) : process(value, callback)(this.source);
  } else {
    callback(true);
  }
};

/**
 * Cell type is just a shortcut for setting bunch of cellProperties (used in getCellMeta)
 */

Handsontable.AutocompleteCell = {
  editor: Handsontable.editors.AutocompleteEditor,
  renderer: Handsontable.renderers.AutocompleteRenderer,
  validator: Handsontable.AutocompleteValidator
};

Handsontable.CheckboxCell = {
  editor: Handsontable.editors.CheckboxEditor,
  renderer: Handsontable.renderers.CheckboxRenderer
};

Handsontable.TextCell = {
  editor: Handsontable.editors.TextEditor,
  renderer: Handsontable.renderers.TextRenderer
};

Handsontable.NumericCell = {
  editor: Handsontable.editors.TextEditor,
  renderer: Handsontable.renderers.NumericRenderer,
  validator: Handsontable.NumericValidator,
  dataType: 'number'
};

Handsontable.DateCell = {
  editor: Handsontable.editors.DateEditor,
  renderer: Handsontable.renderers.AutocompleteRenderer //displays small gray arrow on right side of the cell
};

Handsontable.HandsontableCell = {
  editor: Handsontable.editors.HandsontableEditor,
  renderer: Handsontable.renderers.AutocompleteRenderer //displays small gray arrow on right side of the cell
};

Handsontable.PasswordCell = {
  editor: Handsontable.editors.PasswordEditor,
  renderer: Handsontable.renderers.PasswordRenderer,
  copyable: false
};

Handsontable.DropdownCell = {
  editor: Handsontable.editors.DropdownEditor,
  renderer: Handsontable.renderers.AutocompleteRenderer, //displays small gray arrow on right side of the cell
  validator: Handsontable.AutocompleteValidator
};

//here setup the friendly aliases that are used by cellProperties.type
Handsontable.cellTypes = {
  text: Handsontable.TextCell,
  date: Handsontable.DateCell,
  numeric: Handsontable.NumericCell,
  checkbox: Handsontable.CheckboxCell,
  autocomplete: Handsontable.AutocompleteCell,
  handsontable: Handsontable.HandsontableCell,
  password: Handsontable.PasswordCell,
  dropdown: Handsontable.DropdownCell
};

//here setup the friendly aliases that are used by cellProperties.renderer and cellProperties.editor
Handsontable.cellLookup = {
  validator: {
    numeric: Handsontable.NumericValidator,
    autocomplete: Handsontable.AutocompleteValidator
  }
};
/*
 * jQuery.fn.autoResize 1.1+
 * --
 * https://github.com/warpech/jQuery.fn.autoResize
 *
 * This fork differs from others in a way that it autoresizes textarea in 2-dimensions (horizontally and vertically).
 * It was originally forked from alexbardas's repo but maybe should be merged with dpashkevich's repo in future.
 *
 * originally forked from:
 * https://github.com/jamespadolsey/jQuery.fn.autoResize
 * which is now located here:
 * https://github.com/alexbardas/jQuery.fn.autoResize
 * though the mostly maintained for is here:
 * https://github.com/dpashkevich/jQuery.fn.autoResize/network
 *
 * --
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. */

(function($){

  autoResize.defaults = {
    onResize: function(){},
    animate: {
      duration: 200,
      complete: function(){}
    },
    extraSpace: 50,
    minHeight: 'original',
    maxHeight: 500,
    minWidth: 'original',
    maxWidth: 500
  };

  autoResize.cloneCSSProperties = [
    'lineHeight', 'textDecoration', 'letterSpacing',
    'fontSize', 'fontFamily', 'fontStyle', 'fontWeight',
    'textTransform', 'textAlign', 'direction', 'wordSpacing', 'fontSizeAdjust',
    'padding'
  ];

  autoResize.cloneCSSValues = {
    position: 'absolute',
    top: -9999,
    left: -9999,
    opacity: 0,
    overflow: 'hidden',
    overflowX: 'hidden',
    overflowY: 'hidden',
    border: '1px solid black',
    padding: '0.49em' //this must be about the width of caps W character
  };

  autoResize.resizableFilterSelector = 'textarea,input:not(input[type]),input[type=text],input[type=password]';

  autoResize.AutoResizer = AutoResizer;

  $.fn.autoResize = autoResize;

  function autoResize(config) {
    this.filter(autoResize.resizableFilterSelector).each(function(){
      new AutoResizer( $(this), config );
    });
    return this;
  }

  function AutoResizer(el, config) {

    if(this.clones) return;

    this.config = $.extend({}, autoResize.defaults, config);

    this.el = el;

    this.nodeName = el[0].nodeName.toLowerCase();

    this.previousScrollTop = null;

    if (config.maxWidth === 'original') config.maxWidth = el.width();
    if (config.minWidth === 'original') config.minWidth = el.width();
    if (config.maxHeight === 'original') config.maxHeight = el.height();
    if (config.minHeight === 'original') config.minHeight = el.height();

    if (this.nodeName === 'textarea') {
      el.css({
        resize: 'none',
        overflowY: 'none'
      });
    }

    el.data('AutoResizer', this);

    this.createClone();
    this.injectClone();
    this.bind();

  }

  AutoResizer.prototype = {

    bind: function() {

      var check = $.proxy(function(){
        this.check();
        return true;
      }, this);

      this.unbind();

      this.el
        .bind('keyup.autoResize', check)
        //.bind('keydown.autoResize', check)
        .bind('change.autoResize', check);

      this.check(null, true);

    },

    unbind: function() {
      this.el.unbind('.autoResize');
    },

    createClone: function() {

      var el = this.el,
        self = this,
        config = this.config;

      this.clones = $();

      if (config.minHeight !== 'original' || config.maxHeight !== 'original') {
        this.hClone = el.clone().height('auto');
        this.clones = this.clones.add(this.hClone);
      }
      if (config.minWidth !== 'original' || config.maxWidth !== 'original') {
        this.wClone = $('<div/>').width('auto').css({
          whiteSpace: 'nowrap',
          'float': 'left'
        });
        this.clones = this.clones.add(this.wClone);
      }

      $.each(autoResize.cloneCSSProperties, function(i, p){
        self.clones.css(p, el.css(p));
      });

      this.clones
        .removeAttr('name')
        .removeAttr('id')
        .attr('tabIndex', -1)
        .css(autoResize.cloneCSSValues)
        .css('overflowY', 'scroll');

    },

    check: function(e, immediate) {

      var config = this.config,
        wClone = this.wClone,
        hClone = this.hClone,
        el = this.el,
        value = el.val();

      if (wClone) {

        wClone.text(value);

        // Calculate new width + whether to change
        var cloneWidth = wClone.outerWidth(),
          newWidth = (cloneWidth + config.extraSpace) >= config.minWidth ?
            cloneWidth + config.extraSpace : config.minWidth,
          currentWidth = el.width();

        newWidth = Math.min(newWidth, config.maxWidth);

        if (
          (newWidth < currentWidth && newWidth >= config.minWidth) ||
            (newWidth >= config.minWidth && newWidth <= config.maxWidth)
          ) {

          config.onResize.call(el);

          el.scrollLeft(0);

          config.animate && !immediate ?
            el.stop(1,1).animate({
              width: newWidth
            }, config.animate)
            : el.width(newWidth);

        }

      }

      if (hClone) {

        if (newWidth) {
          hClone.width(newWidth);
        }

        hClone.height(0).val(value).scrollTop(10000);

        var scrollTop = hClone[0].scrollTop + config.extraSpace;

        // Don't do anything if scrollTop hasen't changed:
        if (this.previousScrollTop === scrollTop) {
          return;
        }

        this.previousScrollTop = scrollTop;

        if (scrollTop >= config.maxHeight) {
          scrollTop = config.maxHeight;
        }

        if (scrollTop < config.minHeight) {
          scrollTop = config.minHeight;
        }

        if(scrollTop == config.maxHeight && newWidth == config.maxWidth) {
          el.css('overflowY', 'scroll');
        }
        else {
          el.css('overflowY', 'hidden');
        }

        config.onResize.call(el);

        // Either animate or directly apply height:
        config.animate && !immediate ?
          el.stop(1,1).animate({
            height: scrollTop
          }, config.animate)
          : el.height(scrollTop);
      }
    },

    destroy: function() {
      this.unbind();
      this.el.removeData('AutoResizer');
      this.clones.remove();
      delete this.el;
      delete this.hClone;
      delete this.wClone;
      delete this.clones;
    },

    injectClone: function() {
      (
        autoResize.cloneContainer ||
          (autoResize.cloneContainer = $('<arclones/>').appendTo('body'))
        ).empty().append(this.clones); //this should be refactored so that a node is never cloned more than once
    }

  };

})(jQuery);
/**
 * SheetClip - Spreadsheet Clipboard Parser
 * version 0.2
 *
 * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,
 * Google Docs and Microsoft Excel.
 *
 * Copyright 2012, Marcin Warpechowski
 * Licensed under the MIT license.
 * http://github.com/warpech/sheetclip/
 */
/*jslint white: true*/
(function (global) {
  "use strict";

  function countQuotes(str) {
    return str.split('"').length - 1;
  }

  global.SheetClip = {
    parse: function (str) {
      var r, rlen, rows, arr = [], a = 0, c, clen, multiline, last;
      rows = str.split('\n');
      if (rows.length > 1 && rows[rows.length - 1] === '') {
        rows.pop();
      }
      for (r = 0, rlen = rows.length; r < rlen; r += 1) {
        rows[r] = rows[r].split('\t');
        for (c = 0, clen = rows[r].length; c < clen; c += 1) {
          if (!arr[a]) {
            arr[a] = [];
          }
          if (multiline && c === 0) {
            last = arr[a].length - 1;
            arr[a][last] = arr[a][last] + '\n' + rows[r][0];
            if (multiline && (countQuotes(rows[r][0]) & 1)) { //& 1 is a bitwise way of performing mod 2
              multiline = false;
              arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/""/g, '"');
            }
          }
          else {
            if (c === clen - 1 && rows[r][c].indexOf('"') === 0) {
              arr[a].push(rows[r][c].substring(1).replace(/""/g, '"'));
              multiline = true;
            }
            else {
              arr[a].push(rows[r][c].replace(/""/g, '"'));
              multiline = false;
            }
          }
        }
        if (!multiline) {
          a += 1;
        }
      }
      return arr;
    },

    stringify: function (arr) {
      var r, rlen, c, clen, str = '', val;
      for (r = 0, rlen = arr.length; r < rlen; r += 1) {
        for (c = 0, clen = arr[r].length; c < clen; c += 1) {
          if (c > 0) {
            str += '\t';
          }
          val = arr[r][c];
          if (typeof val === 'string') {
            if (val.indexOf('\n') > -1) {
              str += '"' + val.replace(/"/g, '""') + '"';
            }
            else {
              str += val;
            }
          }
          else if (val === null || val === void 0) { //void 0 resolves to undefined
            str += '';
          }
          else {
            str += val;
          }
        }
        str += '\n';
      }
      return str;
    }
  };
}(window));
/**
 * CopyPaste.js
 * Creates a textarea that stays hidden on the page and gets focused when user presses CTRL while not having a form input focused
 * In future we may implement a better driver when better APIs are available
 * @constructor
 */
var CopyPaste = (function () {
  var instance;
  return {
    getInstance: function () {
      if (!instance) {
        instance = new CopyPasteClass();
      } else if (instance.hasBeenDestroyed()){
        instance.init();
      }

      instance.refCounter++;

      return instance;
    }
  };
})();

function CopyPasteClass() {
  this.refCounter = 0;
  this.init();
}

CopyPasteClass.prototype.init = function () {
  var that = this
    , style
    , parent;

  this.copyCallbacks = [];
  this.cutCallbacks = [];
  this.pasteCallbacks = [];

  this.listenerElement = document.documentElement;
  parent = document.body;

  if (document.getElementById('CopyPasteDiv')) {
    this.elDiv = document.getElementById('CopyPasteDiv');
    this.elTextarea = this.elDiv.firstChild;
  }
  else {
    this.elDiv = document.createElement('DIV');
    this.elDiv.id = 'CopyPasteDiv';
    style = this.elDiv.style;
    style.position = 'fixed';
    style.top = '-10000px';
    style.left = '-10000px';
    parent.appendChild(this.elDiv);

    this.elTextarea = document.createElement('TEXTAREA');
    this.elTextarea.className = 'copyPaste';
    style = this.elTextarea.style;
    style.width = '10000px';
    style.height = '10000px';
    style.overflow = 'hidden';
    this.elDiv.appendChild(this.elTextarea);

    if (typeof style.opacity !== 'undefined') {
      style.opacity = 0;
    }
    else {
      /*@cc_on @if (@_jscript)
       if(typeof style.filter === 'string') {
       style.filter = 'alpha(opacity=0)';
       }
       @end @*/
    }
  }

  this.keydownListener = function (event) {
    var isCtrlDown = false;
    if (event.metaKey) { //mac
      isCtrlDown = true;
    }
    else if (event.ctrlKey && navigator.userAgent.indexOf('Mac') === -1) { //pc
      isCtrlDown = true;
    }

    if (isCtrlDown) {
      if (document.activeElement !== that.elTextarea && (that.getSelectionText() != '' || ['INPUT', 'SELECT', 'TEXTAREA'].indexOf(document.activeElement.nodeName) != -1)) {
        return; //this is needed by fragmentSelection in Handsontable. Ignore copypaste.js behavior if fragment of cell text is selected
      }

      that.selectNodeText(that.elTextarea);
      setTimeout(function () {
        that.selectNodeText(that.elTextarea);
      }, 0);
    }

    /* 67 = c
     * 86 = v
     * 88 = x
     */
    if (isCtrlDown && (event.keyCode === 67 || event.keyCode === 86 || event.keyCode === 88)) {
      // that.selectNodeText(that.elTextarea);

      if (event.keyCode === 88) { //works in all browsers, incl. Opera < 12.12
        setTimeout(function () {
          that.triggerCut(event);
        }, 0);
      }
      else if (event.keyCode === 86) {
        setTimeout(function () {
          that.triggerPaste(event);
        }, 0);
      }
    }
  }

  this._bindEvent(this.listenerElement, 'keydown', this.keydownListener);
};

//http://jsperf.com/textara-selection
//http://stackoverflow.com/questions/1502385/how-can-i-make-this-code-work-in-ie
CopyPasteClass.prototype.selectNodeText = function (el) {
  el.select();
};

//http://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text
CopyPasteClass.prototype.getSelectionText = function () {
  var text = "";
  if (window.getSelection) {
    text = window.getSelection().toString();
  } else if (document.selection && document.selection.type != "Control") {
    text = document.selection.createRange().text;
  }
  return text;
};

CopyPasteClass.prototype.copyable = function (str) {
  if (typeof str !== 'string' && str.toString === void 0) {
    throw new Error('copyable requires string parameter');
  }
  this.elTextarea.value = str;
};

/*CopyPasteClass.prototype.onCopy = function (fn) {
  this.copyCallbacks.push(fn);
};*/

CopyPasteClass.prototype.onCut = function (fn) {
  this.cutCallbacks.push(fn);
};

CopyPasteClass.prototype.onPaste = function (fn) {
  this.pasteCallbacks.push(fn);
};

CopyPasteClass.prototype.removeCallback = function (fn) {
  var i, ilen;
  for (i = 0, ilen = this.copyCallbacks.length; i < ilen; i++) {
    if (this.copyCallbacks[i] === fn) {
      this.copyCallbacks.splice(i, 1);
      return true;
    }
  }
  for (i = 0, ilen = this.cutCallbacks.length; i < ilen; i++) {
    if (this.cutCallbacks[i] === fn) {
      this.cutCallbacks.splice(i, 1);
      return true;
    }
  }
  for (i = 0, ilen = this.pasteCallbacks.length; i < ilen; i++) {
    if (this.pasteCallbacks[i] === fn) {
      this.pasteCallbacks.splice(i, 1);
      return true;
    }
  }
  return false;
};

CopyPasteClass.prototype.triggerCut = function (event) {
  var that = this;
  if (that.cutCallbacks) {
    setTimeout(function () {
      for (var i = 0, ilen = that.cutCallbacks.length; i < ilen; i++) {
        that.cutCallbacks[i](event);
      }
    }, 50);
  }
};

CopyPasteClass.prototype.triggerPaste = function (event, str) {
  var that = this;
  if (that.pasteCallbacks) {
    setTimeout(function () {
      var val = (str || that.elTextarea.value).replace(/\n$/, ''); //remove trailing newline
      for (var i = 0, ilen = that.pasteCallbacks.length; i < ilen; i++) {
        that.pasteCallbacks[i](val, event);
      }
    }, 50);
  }
};

CopyPasteClass.prototype.destroy = function () {

  if(!this.hasBeenDestroyed() && --this.refCounter == 0){
    if (this.elDiv && this.elDiv.parentNode) {
      this.elDiv.parentNode.removeChild(this.elDiv);
    }

    this._unbindEvent(this.listenerElement, 'keydown', this.keydownListener);

  }

};

CopyPasteClass.prototype.hasBeenDestroyed = function () {
  return !this.refCounter;
};

//old version used this:
// - http://net.tutsplus.com/tutorials/javascript-ajax/javascript-from-null-cross-browser-event-binding/
// - http://stackoverflow.com/questions/4643249/cross-browser-event-object-normalization
//but that cannot work with jQuery.trigger
CopyPasteClass.prototype._bindEvent = (function () {
  if (window.jQuery) { //if jQuery exists, use jQuery event (for compatibility with $.trigger and $.triggerHandler, which can only trigger jQuery events - and we use that in tests)
    return function (elem, type, cb) {
      $(elem).on(type + '.copypaste', cb);
    };
  }
  else {
    return function (elem, type, cb) {
      elem.addEventListener(type, cb, false); //sorry, IE8 will only work with jQuery
    };
  }
})();

CopyPasteClass.prototype._unbindEvent = (function () {
  if (window.jQuery) { //if jQuery exists, use jQuery event (for compatibility with $.trigger and $.triggerHandler, which can only trigger jQuery events - and we use that in tests)
    return function (elem, type, cb) {
      $(elem).off(type + '.copypaste', cb);
    };
  }
  else {
    return function (elem, type, cb) {
      elem.removeEventListener(type, cb, false); //sorry, IE8 will only work with jQuery
    };
  }
})();
// json-patch-duplex.js 0.3.6
// (c) 2013 Joachim Wester
// MIT license
var jsonpatch;
(function (jsonpatch) {
    var objOps = {
        add: function (obj, key) {
            obj[key] = this.value;
            return true;
        },
        remove: function (obj, key) {
            delete obj[key];
            return true;
        },
        replace: function (obj, key) {
            obj[key] = this.value;
            return true;
        },
        move: function (obj, key, tree) {
            var temp = { op: "_get", path: this.from };
            apply(tree, [temp]);
            apply(tree, [
                { op: "remove", path: this.from }
            ]);
            apply(tree, [
                { op: "add", path: this.path, value: temp.value }
            ]);
            return true;
        },
        copy: function (obj, key, tree) {
            var temp = { op: "_get", path: this.from };
            apply(tree, [temp]);
            apply(tree, [
                { op: "add", path: this.path, value: temp.value }
            ]);
            return true;
        },
        test: function (obj, key) {
            return (JSON.stringify(obj[key]) === JSON.stringify(this.value));
        },
        _get: function (obj, key) {
            this.value = obj[key];
        }
    };

    var arrOps = {
        add: function (arr, i) {
            arr.splice(i, 0, this.value);
            return true;
        },
        remove: function (arr, i) {
            arr.splice(i, 1);
            return true;
        },
        replace: function (arr, i) {
            arr[i] = this.value;
            return true;
        },
        move: objOps.move,
        copy: objOps.copy,
        test: objOps.test,
        _get: objOps._get
    };

    var observeOps = {
        add: function (patches, path) {
            var patch = {
                op: "add",
                path: path + escapePathComponent(this.name),
                value: this.object[this.name]
            };
            patches.push(patch);
        },
        'delete': function (patches, path) {
            var patch = {
                op: "remove",
                path: path + escapePathComponent(this.name)
            };
            patches.push(patch);
        },
        update: function (patches, path) {
            var patch = {
                op: "replace",
                path: path + escapePathComponent(this.name),
                value: this.object[this.name]
            };
            patches.push(patch);
        }
    };

    function escapePathComponent(str) {
        if (str.indexOf('/') === -1 && str.indexOf('~') === -1)
            return str;
        return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }

    function _getPathRecursive(root, obj) {
        var found;
        for (var key in root) {
            if (root.hasOwnProperty(key)) {
                if (root[key] === obj) {
                    return escapePathComponent(key) + '/';
                } else if (typeof root[key] === 'object') {
                    found = _getPathRecursive(root[key], obj);
                    if (found != '') {
                        return escapePathComponent(key) + '/' + found;
                    }
                }
            }
        }
        return '';
    }

    function getPath(root, obj) {
        if (root === obj) {
            return '/';
        }
        var path = _getPathRecursive(root, obj);
        if (path === '') {
            throw new Error("Object not found in root");
        }
        return '/' + path;
    }

    var beforeDict = [];

    jsonpatch.intervals;

    var Mirror = (function () {
        function Mirror(obj) {
            this.observers = [];
            this.obj = obj;
        }
        return Mirror;
    })();

    var ObserverInfo = (function () {
        function ObserverInfo(callback, observer) {
            this.callback = callback;
            this.observer = observer;
        }
        return ObserverInfo;
    })();

    function getMirror(obj) {
        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
            if (beforeDict[i].obj === obj) {
                return beforeDict[i];
            }
        }
    }

    function getObserverFromMirror(mirror, callback) {
        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
            if (mirror.observers[j].callback === callback) {
                return mirror.observers[j].observer;
            }
        }
    }

    function removeObserverFromMirror(mirror, observer) {
        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {
            if (mirror.observers[j].observer === observer) {
                mirror.observers.splice(j, 1);
                return;
            }
        }
    }

    function unobserve(root, observer) {
        generate(observer);
        if (Object.observe) {
            _unobserve(observer, root);
        } else {
            clearTimeout(observer.next);
        }

        var mirror = getMirror(root);
        removeObserverFromMirror(mirror, observer);
    }
    jsonpatch.unobserve = unobserve;

    function observe(obj, callback) {
        var patches = [];
        var root = obj;
        var observer;
        var mirror = getMirror(obj);

        if (!mirror) {
            mirror = new Mirror(obj);
            beforeDict.push(mirror);
        } else {
            observer = getObserverFromMirror(mirror, callback);
        }

        if (observer) {
            return observer;
        }

        if (Object.observe) {
            observer = function (arr) {
                //This "refresh" is needed to begin observing new object properties
                _unobserve(observer, obj);
                _observe(observer, obj);

                var a = 0, alen = arr.length;
                while (a < alen) {
                    if (!(arr[a].name === 'length' && _isArray(arr[a].object)) && !(arr[a].name === '__Jasmine_been_here_before__')) {
                        var type = arr[a].type;

                        switch (type) {
                            case 'new':
                                type = 'add';
                                break;

                            case 'deleted':
                                type = 'delete';
                                break;

                            case 'updated':
                                type = 'update';
                                break;
                        }

                        observeOps[type].call(arr[a], patches, getPath(root, arr[a].object));
                    }
                    a++;
                }

                if (patches) {
                    if (callback) {
                        callback(patches);
                    }
                }
                observer.patches = patches;
                patches = [];
            };
        } else {
            observer = {};

            mirror.value = JSON.parse(JSON.stringify(obj));

            if (callback) {
                //callbacks.push(callback); this has no purpose
                observer.callback = callback;
                observer.next = null;
                var intervals = this.intervals || [100, 1000, 10000, 60000];
                var currentInterval = 0;

                var dirtyCheck = function () {
                    generate(observer);
                };
                var fastCheck = function () {
                    clearTimeout(observer.next);
                    observer.next = setTimeout(function () {
                        dirtyCheck();
                        currentInterval = 0;
                        observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
                    }, 0);
                };
                var slowCheck = function () {
                    dirtyCheck();
                    if (currentInterval == intervals.length)
                        currentInterval = intervals.length - 1;
                    observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
                };
                if (typeof window !== 'undefined') {
                    if (window.addEventListener) {
                        window.addEventListener('mousedown', fastCheck);
                        window.addEventListener('mouseup', fastCheck);
                        window.addEventListener('keydown', fastCheck);
                    } else {
                        window.attachEvent('onmousedown', fastCheck);
                        window.attachEvent('onmouseup', fastCheck);
                        window.attachEvent('onkeydown', fastCheck);
                    }
                }
                observer.next = setTimeout(slowCheck, intervals[currentInterval++]);
            }
        }
        observer.patches = patches;
        observer.object = obj;

        mirror.observers.push(new ObserverInfo(callback, observer));

        return _observe(observer, obj);
    }
    jsonpatch.observe = observe;

    /// Listen to changes on an object tree, accumulate patches
    function _observe(observer, obj) {
        if (Object.observe) {
            Object.observe(obj, observer);
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    var v = obj[key];
                    if (v && typeof (v) === "object") {
                        _observe(observer, v);
                    }
                }
            }
        }
        return observer;
    }

    function _unobserve(observer, obj) {
        if (Object.observe) {
            Object.unobserve(obj, observer);
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    var v = obj[key];
                    if (v && typeof (v) === "object") {
                        _unobserve(observer, v);
                    }
                }
            }
        }
        return observer;
    }

    function generate(observer) {
        if (Object.observe) {
            Object.deliverChangeRecords(observer);
        } else {
            var mirror;
            for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {
                if (beforeDict[i].obj === observer.object) {
                    mirror = beforeDict[i];
                    break;
                }
            }
            _generate(mirror.value, observer.object, observer.patches, "");
        }
        var temp = observer.patches;
        if (temp.length > 0) {
            observer.patches = [];
            if (observer.callback) {
                observer.callback(temp);
            }
        }
        return temp;
    }
    jsonpatch.generate = generate;

    var _objectKeys;
    if (Object.keys) {
        _objectKeys = Object.keys;
    } else {
        _objectKeys = function (obj) {
            var keys = [];
            for (var o in obj) {
                if (obj.hasOwnProperty(o)) {
                    keys.push(o);
                }
            }
            return keys;
        };
    }

    // Dirty check if obj is different from mirror, generate patches and update mirror
    function _generate(mirror, obj, patches, path) {
        var newKeys = _objectKeys(obj);
        var oldKeys = _objectKeys(mirror);
        var changed = false;
        var deleted = false;

        for (var t = oldKeys.length - 1; t >= 0; t--) {
            var key = oldKeys[t];
            var oldVal = mirror[key];
            if (obj.hasOwnProperty(key)) {
                var newVal = obj[key];
                if (oldVal instanceof Object) {
                    _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key));
                } else {
                    if (oldVal != newVal) {
                        changed = true;
                        patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: newVal });
                        mirror[key] = newVal;
                    }
                }
            } else {
                patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
                delete mirror[key];
                deleted = true;
            }
        }

        if (!deleted && newKeys.length == oldKeys.length) {
            return;
        }

        for (var t = 0; t < newKeys.length; t++) {
            var key = newKeys[t];
            if (!mirror.hasOwnProperty(key)) {
                patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: obj[key] });
                mirror[key] = JSON.parse(JSON.stringify(obj[key]));
            }
        }
    }

    var _isArray;
    if (Array.isArray) {
        _isArray = Array.isArray;
    } else {
        _isArray = function (obj) {
            return obj.push && typeof obj.length === 'number';
        };
    }

    /// Apply a json-patch operation on an object tree
    function apply(tree, patches) {
        var result = false, p = 0, plen = patches.length, patch;
        while (p < plen) {
            patch = patches[p];

            // Find the object
            var keys = patch.path.split('/');
            var obj = tree;
            var t = 1;
            var len = keys.length;
            while (true) {
                if (_isArray(obj)) {
                    var index = parseInt(keys[t], 10);
                    t++;
                    if (t >= len) {
                        result = arrOps[patch.op].call(patch, obj, index, tree);
                        break;
                    }
                    obj = obj[index];
                } else {
                    var key = keys[t];
                    if (key.indexOf('~') != -1)
                        key = key.replace(/~1/g, '/').replace(/~0/g, '~');
                    t++;
                    if (t >= len) {
                        result = objOps[patch.op].call(patch, obj, key, tree);
                        break;
                    }
                    obj = obj[key];
                }
            }
            p++;
        }
        return result;
    }
    jsonpatch.apply = apply;
})(jsonpatch || (jsonpatch = {}));

if (typeof exports !== "undefined") {
    exports.apply = jsonpatch.apply;
    exports.observe = jsonpatch.observe;
    exports.unobserve = jsonpatch.unobserve;
    exports.generate = jsonpatch.generate;
}

Handsontable.PluginHookClass = (function () {

  var Hooks = function () {
    return {
      // Hooks
      beforeInitWalkontable: [],

      beforeInit: [],
      beforeRender: [],
      beforeSetRangeEnd: [],
      beforeChange: [],
      beforeChangeRender: [],
      beforeRemoveCol: [],
      beforeRemoveRow: [],
      beforeValidate: [],
      beforeGetCellMeta: [],
      beforeAutofill: [],
      beforeKeyDown: [],

      afterInit : [],
      afterLoadData : [],
      afterUpdateSettings: [],
      afterRender : [],
      afterRenderer : [],
      afterChange : [],
      afterValidate: [],
      afterGetCellMeta: [],
      afterSetCellMeta: [],
      afterGetColHeader: [],
      afterGetRowHeader: [],
      afterDestroy: [],
      afterRemoveRow: [],
      afterCreateRow: [],
      afterRemoveCol: [],
      afterCreateCol: [],
      afterDeselect: [],
      afterSelection: [],
      afterSelectionByProp: [],
      afterSelectionEnd: [],
      afterSelectionEndByProp: [],
      afterOnCellMouseDown: [],
      afterOnCellMouseOver: [],
      afterOnCellCornerMouseDown: [],
      afterScrollVertically: [],
      afterScrollHorizontally: [],
	  afterCellMetaReset:[],

      // Modifiers
      modifyColWidth: [],
      modifyRowHeight: [],
      modifyRow: [],
      modifyCol: []
    }
  };

  var legacy = {
    onBeforeChange: "beforeChange",
    onChange: "afterChange",
    onCreateRow: "afterCreateRow",
    onCreateCol: "afterCreateCol",
    onSelection: "afterSelection",
    onCopyLimit: "afterCopyLimit",
    onSelectionEnd: "afterSelectionEnd",
    onSelectionByProp: "afterSelectionByProp",
    onSelectionEndByProp: "afterSelectionEndByProp"
  };

  function PluginHookClass() {

    this.hooks = Hooks();
    this.globalBucket = {};
    this.legacy = legacy;

  }

  PluginHookClass.prototype.getBucket = function (instance) {
    if(instance) {
      if(!instance.pluginHookBucket) {
        instance.pluginHookBucket = {};
      }
      return instance.pluginHookBucket;
    }
    return this.globalBucket;
  };

  PluginHookClass.prototype.add = function (key, fn, instance) {
    //if fn is array, run this for all the array items
    if (Handsontable.helper.isArray(fn)) {
      for (var i = 0, len = fn.length; i < len; i++) {
        this.add(key, fn[i]);
      }
    }
    else {
      // provide support for old versions of HOT
      if (key in legacy) {
        key = legacy[key];
      }

      var bucket = this.getBucket(instance);

      if (typeof bucket[key] === "undefined") {
        bucket[key] = [];
      }

      fn.skip = false;

      if (bucket[key].indexOf(fn) == -1) {
        bucket[key].push(fn); //only add a hook if it has not already be added (adding the same hook twice is now silently ignored)
      }
    }
    return this;
  };

  PluginHookClass.prototype.once = function(key, fn, instance){

    if(Handsontable.helper.isArray(fn)){

      for(var i = 0, len = fn.length; i < len; i++){
        fn[i].runOnce = true;
        this.add(key, fn[i], instance);
      }

    } else {
      fn.runOnce = true;
      this.add(key, fn, instance);

    }

  };

  PluginHookClass.prototype.remove = function (key, fn, instance) {
    var status = false;

    // provide support for old versions of HOT
    if (key in legacy) {
      key = legacy[key];
    }

    var bucket = this.getBucket(instance);

    if (typeof bucket[key] !== 'undefined') {

      for (var i = 0, leni = bucket[key].length; i < leni; i++) {

        if (bucket[key][i] == fn) {
          bucket[key][i].skip = true;
          status = true;
          break;
        }

      }

    }

    return status;
  };

  PluginHookClass.prototype.run = function (instance, key, p1, p2, p3, p4, p5, p6) {
    // provide support for old versions of HOT
    if (key in legacy) {
      key = legacy[key];
    }

    this._runBucket(this.globalBucket, instance, key, p1, p2, p3, p4, p5, p6);
    this._runBucket(this.getBucket(instance), instance, key, p1, p2, p3, p4, p5, p6);
  };

  PluginHookClass.prototype._runBucket = function (bucket, instance, key, p1, p2, p3, p4, p5, p6) {
    var handlers = bucket[key];
    if (handlers) {
      for (var i = 0, leni = handlers.length; i < leni; i++) {
        if (!handlers[i].skip) {
          handlers[i].call(instance, p1, p2, p3, p4, p5, p6);

          if (handlers[i].runOnce) {
            this.remove(key, handlers[i], bucket === this.globalBucket ? null : instance);
          }
        }
      }
    }
  };

  PluginHookClass.prototype.execute = function (instance, key, p1, p2, p3, p4, p5, p6) {
    // provide support for old versions of HOT
    if (key in legacy) {
      key = legacy[key];
    }

    p1 = this._executeBucket(this.globalBucket, instance, key, p1, p2, p3, p4, p5, p6);
    p1 = this._executeBucket(this.getBucket(instance), instance, key, p1, p2, p3, p4, p5, p6);
    return p1;
  };

  PluginHookClass.prototype._executeBucket = function (bucket, instance, key, p1, p2, p3, p4, p5, p6) {
    var res,
      handlers = bucket[key];

    //performance considerations - http://jsperf.com/call-vs-apply-for-a-plugin-architecture
    if (handlers) {
      for (var i = 0, leni = handlers.length; i < leni; i++) {
        if (!handlers[i].skip) {
          res = handlers[i].call(instance, p1, p2, p3, p4, p5, p6);
          if (res !== void 0) {
            p1 = res;
          }

          if (handlers[i].runOnce) {
            this.remove(key, handlers[i], bucket === this.globalBucket ? null : instance);
          }

          if (res === false) { //if any handler returned false
            return false; //event has been cancelled and further execution of handler queue is being aborted
          }
        }
      }
    }

    return p1;
  };

  /**
   * Registers a hook name (adds it to the list of the known hook names). Used by plugins. It is not neccessary to call,
   * register, but if you use it, your plugin hook will be used returned by getRegistered
   * (which itself is used in the demo http://handsontable.com/demo/callbacks.html)
   * @param key {String}
   */
  PluginHookClass.prototype.register = function (key) {
    if (!this.isRegistered(key)) {
      this.hooks[key] = [];
    }
  };

  /**
   * Deregisters a hook name (removes it from the list of known hook names)
   * @param key {String}
   */
  PluginHookClass.prototype.deregister = function (key) {
    delete this.hooks[key];
  };

  /**
   * Returns boolean information if a hook by such name has been registered
   * @param key {String}
   */
  PluginHookClass.prototype.isRegistered = function (key) {
    return (typeof this.hooks[key] !== "undefined");
  };

  /**
   * Returns an array of registered hooks
   * @returns {Array}
   */
  PluginHookClass.prototype.getRegistered = function () {
    return Object.keys(this.hooks);
  };

  return PluginHookClass;

})();

Handsontable.hooks = new Handsontable.PluginHookClass();
Handsontable.PluginHooks = Handsontable.hooks; //in future move this line to legacy.js

(function (Handsontable) {

  function HandsontableAutoColumnSize() {
    var plugin = this
      , sampleCount = 5; //number of samples to take of each value length

    this.beforeInit = function () {
      var instance = this;
      instance.autoColumnWidths = [];

      if (instance.getSettings().autoColumnSize !== false) {
        if (!instance.autoColumnSizeTmp) {
          instance.autoColumnSizeTmp = {
            table: null,
            tableStyle: null,
            theadTh: null,
            tbody: null,
            container: null,
            containerStyle: null,
            determineBeforeNextRender: true
          };

          instance.addHook('beforeRender', htAutoColumnSize.determineIfChanged);
          instance.addHook('modifyColWidth', htAutoColumnSize.modifyColWidth);
          instance.addHook('afterDestroy', htAutoColumnSize.afterDestroy);

          instance.determineColumnWidth = plugin.determineColumnWidth;
        }
      } else {
        if (instance.autoColumnSizeTmp) {
          instance.removeHook('beforeRender', htAutoColumnSize.determineIfChanged);
          instance.removeHook('modifyColWidth', htAutoColumnSize.modifyColWidth);
          instance.removeHook('afterDestroy', htAutoColumnSize.afterDestroy);

          delete instance.determineColumnWidth;

          plugin.afterDestroy.call(instance);
        }
      }
    };

    this.determineIfChanged = function (force) {
      if (force) {
        htAutoColumnSize.determineColumnsWidth.apply(this, arguments);
      }
    };

    this.determineColumnWidth = function (col) {
      var instance = this
        , tmp = instance.autoColumnSizeTmp;

      if (!tmp.container) {
        createTmpContainer.call(tmp, instance);
      }

      tmp.container.className = instance.rootElement[0].className + ' htAutoColumnSize';
      tmp.table.className = instance.$table[0].className;

      var rows = instance.countRows();
      var samples = {};
      var maxLen = 0;
      for (var r = 0; r < rows; r++) {
        var value = Handsontable.helper.stringify(instance.getDataAtCell(r, col));
        var len = value.length;
        if (len > maxLen) {
          maxLen = len;
        }
        if (!samples[len]) {
          samples[len] = {
            needed: sampleCount,
            strings: []
          };
        }
        if (samples[len].needed) {
          samples[len].strings.push({value: value, row: r});
          samples[len].needed--;
        }
      }

      var settings = instance.getSettings();
      if (settings.colHeaders) {
        instance.view.appendColHeader(col, tmp.theadTh); //TH innerHTML
      }

      Handsontable.Dom.empty(tmp.tbody);

      for (var i in samples) {
        if (samples.hasOwnProperty(i)) {
          for (var j = 0, jlen = samples[i].strings.length; j < jlen; j++) {
            var row = samples[i].strings[j].row;

            var cellProperties = instance.getCellMeta(row, col);
            cellProperties.col = col;
            cellProperties.row = row;

            var renderer = instance.getCellRenderer(cellProperties);

            var tr = document.createElement('tr');
            var td = document.createElement('td');

            renderer(instance, td, row, col, instance.colToProp(col), samples[i].strings[j].value, cellProperties);
            r++;
            tr.appendChild(td);
            tmp.tbody.appendChild(tr);
          }
        }
      }

      var parent = instance.rootElement[0].parentNode;
      parent.appendChild(tmp.container);
      var width = Handsontable.Dom.outerWidth(tmp.table);
      parent.removeChild(tmp.container);

      return width;
    };

    this.determineColumnsWidth = function () {
      var instance = this;
      var settings = this.getSettings();
      if (settings.autoColumnSize || !settings.colWidths) {
        var cols = this.countCols();
        for (var c = 0; c < cols; c++) {
          if (!instance._getColWidthFromSettings(c)) {
            this.autoColumnWidths[c] = plugin.determineColumnWidth.call(instance, c);
          }
        }
      }
    };

    this.modifyColWidth = function (width, col) {
      if (this.autoColumnWidths[col] && this.autoColumnWidths[col] > width) {
        return this.autoColumnWidths[col];
      }
      return width;
    };

    this.afterDestroy = function () {
      var instance = this;
      if (instance.autoColumnSizeTmp && instance.autoColumnSizeTmp.container && instance.autoColumnSizeTmp.container.parentNode) {
        instance.autoColumnSizeTmp.container.parentNode.removeChild(instance.autoColumnSizeTmp.container);
      }
      instance.autoColumnSizeTmp = null;
    };

    function createTmpContainer(instance) {
      var d = document
        , tmp = this;

      tmp.table = d.createElement('table');
      tmp.theadTh = d.createElement('th');
      tmp.table.appendChild(d.createElement('thead')).appendChild(d.createElement('tr')).appendChild(tmp.theadTh);

      tmp.tableStyle = tmp.table.style;
      tmp.tableStyle.tableLayout = 'auto';
      tmp.tableStyle.width = 'auto';

      tmp.tbody = d.createElement('tbody');
      tmp.table.appendChild(tmp.tbody);

      tmp.container = d.createElement('div');
      tmp.container.className = instance.rootElement[0].className + ' hidden';
      tmp.containerStyle = tmp.container.style;

      tmp.container.appendChild(tmp.table);
    }
  }

  var htAutoColumnSize = new HandsontableAutoColumnSize();

  Handsontable.hooks.add('beforeInit', htAutoColumnSize.beforeInit);
  Handsontable.hooks.add('afterUpdateSettings', htAutoColumnSize.beforeInit);

})(Handsontable);

/**
 * This plugin sorts the view by a column (but does not sort the data source!)
 * @constructor
 */
function HandsontableColumnSorting() {
  var plugin = this;

  this.init = function (source) {
    var instance = this;
    var sortingSettings = instance.getSettings().columnSorting;
    var sortingColumn, sortingOrder;

    instance.sortingEnabled = !!(sortingSettings);

    if (instance.sortingEnabled) {
      instance.sortIndex = [];

      var loadedSortingState = loadSortingState.call(instance);

      if (typeof loadedSortingState != 'undefined') {
        sortingColumn = loadedSortingState.sortColumn;
        sortingOrder = loadedSortingState.sortOrder;
      } else {
        sortingColumn = sortingSettings.column;
        sortingOrder = sortingSettings.sortOrder;
      }
      plugin.sortByColumn.call(instance, sortingColumn, sortingOrder);

      instance.sort = function(){
        var args = Array.prototype.slice.call(arguments);

        return plugin.sortByColumn.apply(instance, args)
      };

      if (typeof instance.getSettings().observeChanges == 'undefined'){
        enableObserveChangesPlugin.call(instance);
      }

      if (source == 'afterInit') {
        bindColumnSortingAfterClick.call(instance);

        instance.addHook('afterCreateRow', plugin.afterCreateRow);
        instance.addHook('afterRemoveRow', plugin.afterRemoveRow);
        instance.addHook('afterLoadData', plugin.init);
      }
    } else {
      delete instance.sort;

      instance.removeHook('afterCreateRow', plugin.afterCreateRow);
      instance.removeHook('afterRemoveRow', plugin.afterRemoveRow);
      instance.removeHook('afterLoadData', plugin.init);
    }
  };

  this.setSortingColumn = function (col, order) {
    var instance = this;

    if (typeof col == 'undefined') {
      delete instance.sortColumn;
      delete instance.sortOrder;

      return;
    } else if (instance.sortColumn === col && typeof order == 'undefined') {
      instance.sortOrder = !instance.sortOrder;
    } else {
      instance.sortOrder = typeof order != 'undefined' ? order : true;
    }

    instance.sortColumn = col;

  };

  this.sortByColumn = function (col, order) {
    var instance = this;

    plugin.setSortingColumn.call(instance, col, order);

    if(typeof instance.sortColumn == 'undefined'){
      return;
    }

    Handsontable.hooks.run(instance, 'beforeColumnSort', instance.sortColumn, instance.sortOrder);

    plugin.sort.call(instance);
    instance.render();

    saveSortingState.call(instance);

    Handsontable.hooks.run(instance, 'afterColumnSort', instance.sortColumn, instance.sortOrder);
  };

  var saveSortingState = function () {
    var instance = this;

    var sortingState = {};

    if (typeof instance.sortColumn != 'undefined') {
      sortingState.sortColumn = instance.sortColumn;
    }

    if (typeof instance.sortOrder != 'undefined') {
      sortingState.sortOrder = instance.sortOrder;
    }

    if (sortingState.hasOwnProperty('sortColumn') || sortingState.hasOwnProperty('sortOrder')) {
      Handsontable.hooks.run(instance, 'persistentStateSave', 'columnSorting', sortingState);
    }

  };

  var loadSortingState = function () {
    var instance = this;
    var storedState = {};
    Handsontable.hooks.run(instance, 'persistentStateLoad', 'columnSorting', storedState);

    return storedState.value;
  };

  var bindColumnSortingAfterClick = function () {
    var instance = this;

    instance.rootElement.on('click.handsontable', '.columnSorting', function (e) {
      if (Handsontable.Dom.hasClass(e.target, 'columnSorting')) {
        var col = getColumn(e.target);
        plugin.sortByColumn.call(instance, col);
      }
    });

    function countRowHeaders() {
      var THs = instance.view.TBODY.querySelector('tr').querySelectorAll('th');
      return THs.length;
    }

    function getColumn(target) {
      var TH = Handsontable.Dom.closest(target, 'TH');
      return Handsontable.Dom.index(TH) - countRowHeaders();
    }
  };

  function enableObserveChangesPlugin () {
    var instance = this;
    instance._registerTimeout('enableObserveChanges', function(){
      instance.updateSettings({
        observeChanges: true
      });
    }, 0);
  }

  function defaultSort(sortOrder) {
    return function (a, b) {
      if (a[1] === b[1]) {
        return 0;
      }
      if (a[1] === null) {
        return 1;
      }
      if (b[1] === null) {
        return -1;
      }
      if (a[1] < b[1]) return sortOrder ? -1 : 1;
      if (a[1] > b[1]) return sortOrder ? 1 : -1;
      return 0;
    }
  }

  function dateSort(sortOrder) {
    return function (a, b) {
      if (a[1] === b[1]) {
        return 0;
      }
      if (a[1] === null) {
        return 1;
      }
      if (b[1] === null) {
        return -1;
      }

      var aDate = new Date(a[1]);
      var bDate = new Date(b[1]);

      if (aDate < bDate) return sortOrder ? -1 : 1;
      if (aDate > bDate) return sortOrder ? 1 : -1;

      return 0;
    }
  }

  this.sort = function () {
    var instance = this;

    if (typeof instance.sortOrder == 'undefined') {
      return;
    }

    instance.sortingEnabled = false; //this is required by translateRow plugin hook
    instance.sortIndex.length = 0;

    var colOffset = this.colOffset();
    for (var i = 0, ilen = this.countRows() - instance.getSettings()['minSpareRows']; i < ilen; i++) {
      this.sortIndex.push([i, instance.getDataAtCell(i, this.sortColumn + colOffset)]);
    }

    var colMeta = instance.getCellMeta(0, instance.sortColumn);
    var sortFunction;
    switch (colMeta.type) {
      case 'date':
        sortFunction = dateSort;
        break;
      default:
        sortFunction = defaultSort;
    }

    this.sortIndex.sort(sortFunction(instance.sortOrder));

    //Append spareRows
    for(var i = this.sortIndex.length; i < instance.countRows(); i++){
      this.sortIndex.push([i, instance.getDataAtCell(i, this.sortColumn + colOffset)]);
    }

    instance.sortingEnabled = true; //this is required by translateRow plugin hook
  };

  this.translateRow = function (row) {
    var instance = this;

    if (instance.sortingEnabled && instance.sortIndex && instance.sortIndex.length && instance.sortIndex[row]) {
      return instance.sortIndex[row][0];
    }

    return row;
  };

  this.untranslateRow = function (row) {
    var instance = this;
    if (instance.sortingEnabled && instance.sortIndex && instance.sortIndex.length) {
      for (var i = 0; i < instance.sortIndex.length; i++) {
        if (instance.sortIndex[i][0] == row) {
          return i;
        }
      }
    }
  };

  this.getColHeader = function (col, TH) {
    if (this.getSettings().columnSorting) {
      Handsontable.Dom.addClass(TH.querySelector('.colHeader'), 'columnSorting');
    }
  };

  function isSorted(instance){
    return typeof instance.sortColumn != 'undefined';
  }

  this.afterCreateRow = function(index, amount){
    var instance = this;

    if(!isSorted(instance)){
      return;
    }


    for(var i = 0; i < instance.sortIndex.length; i++){
      if (instance.sortIndex[i][0] >= index){
        instance.sortIndex[i][0] += amount;
      }
    }

    for(var i=0; i < amount; i++){
      instance.sortIndex.splice(index+i, 0, [index+i, instance.getData()[index+i][instance.sortColumn + instance.colOffset()]]);
    }



    saveSortingState.call(instance);

  };

  this.afterRemoveRow = function(index, amount){
    var instance = this;

    if(!isSorted(instance)){
      return;
    }

    var physicalRemovedIndex = plugin.translateRow.call(instance, index);

    instance.sortIndex.splice(index, amount);

    for(var i = 0; i < instance.sortIndex.length; i++){

      if (instance.sortIndex[i][0] > physicalRemovedIndex){
        instance.sortIndex[i][0] -= amount;
      }
    }

    saveSortingState.call(instance);

  };

  this.afterChangeSort = function (changes/*, source*/) {
    var instance = this;
    var sortColumnChanged = false;
    var selection = {};
    if (!changes) {
      return;
    }

    for (var i = 0; i < changes.length; i++) {
      if (changes[i][1] == instance.sortColumn) {
        sortColumnChanged = true;
        selection.row = plugin.translateRow.call(instance, changes[i][0]);
        selection.col = changes[i][1];
        break;
      }
    }

    if (sortColumnChanged) {
      setTimeout(function () {
        plugin.sort.call(instance);
        instance.render();
        instance.selectCell(plugin.untranslateRow.call(instance, selection.row), selection.col);
      }, 0);
    }
  };
}
var htSortColumn = new HandsontableColumnSorting();

Handsontable.hooks.add('afterInit', function () {
  htSortColumn.init.call(this, 'afterInit')
});
Handsontable.hooks.add('afterUpdateSettings', function () {
  htSortColumn.init.call(this, 'afterUpdateSettings')
});
Handsontable.hooks.add('modifyRow', htSortColumn.translateRow);
Handsontable.hooks.add('afterGetColHeader', htSortColumn.getColHeader);

Handsontable.hooks.register('beforeColumnSort');
Handsontable.hooks.register('afterColumnSort');


(function (Handsontable) {
  'use strict';

  function prepareVerticalAlignClass (className, alignment) {
    if (className.indexOf(alignment)!= -1){
      return className;
    }

    className =  className
      .replace('htTop','')
      .replace('htMiddle','')
      .replace('htBottom','')
      .replace('  ','');

    className += " " + alignment;
    return className;
  }

  function prepareHorizontalAlignClass (className, alignment) {
    if (className.indexOf(alignment)!= -1){
      return className;
    }

    className =  className
      .replace('htLeft','')
      .replace('htCenter','')
      .replace('htRight','')
      .replace('htJustify','')
      .replace('  ','');

    className += " " + alignment;
    return className;
  }

  function doAlign (row, col, type, alignment) {
      var cellMeta = this.getCellMeta(row, col),
        className = alignment;

      if (cellMeta.className) {
        if(type === 'vertical') {
          className = prepareVerticalAlignClass(cellMeta.className, alignment);
        } else {
          className = prepareHorizontalAlignClass(cellMeta.className, alignment);
        }
      }

      this.setCellMeta(row, col, 'className',className);
      this.render();
  }

  function align (range, type, alignment) {
//    if (range.from.row < 0) {
//      range.from = new WalkontableCellCoords(0,range.from.col);
//      range.to = new WalkontableCellCoords(this.view.wt.wtTable.getRowStrategy().cellCount - 1, range.to.col);
//    }
//    if (range.from.col < 0) {
//      range.from = new WalkontableCellCoords(range.from.row, 0);
//      range.to = new WalkontableCellCoords(range.to.row, this.view.wt.wtTable.getColumnStrategy().cellCount - 1);
//    }

    if (range.from.row == range.to.row && range.from.col == range.to.col){
      doAlign.call(this,range.from.row, range.from.col, type, alignment);
    } else {
      for(var row = range.from.row; row<= range.to.row; row++) {
        for (var col = range.from.col; col <= range.to.col; col++) {
          doAlign.call(this,row, col, type, alignment);
        }
      }
    }
  }

  /***
   *
   * @param className
   * @param {String} placement [noBorders, Top, Right, Bottom, Left]
   * @param {String} type [Solid,Dotted,Dashed]
   * @returns {*}

   */
  function prepareBorderClass (className, placement, type){
    var borderedClass = 'htBordered';
    if (className.indexOf(placement)!= -1){
      return className;
    }

    if (placement == "noBorders") {
      className = className
        .replace(borderedClass,'')
        .replace('htTopBorderSolid','')
        .replace('htRightBorderSolid','')
        .replace('htBottomBorderSolid','')
        .replace('htLeftBorderSolid','');
    } else {
      if (className.indexOf(borderedClass)== -1){
        className += " " + borderedClass;
      }
      className += " ht" + placement + "Border" + type;
    }

    return className;
  }

  function setBorderStyle(row, col, place, type){
    var cellMeta = this.getCellMeta(row, col),
      currentClassName = cellMeta.className ? cellMeta.className : "",
      borderClassName = prepareBorderClass(currentClassName, place,type);

    this.setCellMeta(row, col, 'className', borderClassName);
    this.render();
  }

  function prepareBorder (range,place, type) {
    type = "Solid";

    // WHEN WE WANT TO CHANGE/ADD VIA CSS TOP BORDER THE WHOLE ROW MOVES 1PX VERTICAL
    // WHEN WE WANT TO CHANGE/ADD VIA CSS RIGHT BORDER THE WHOLE COLUMN MOVES 1PX HORIZONTAL
    if (range.from.row == range.to.row && range.from.col == range.to.col){
      switch(place){
        case "Top":
          if (range.from.row == 0){ // FIRST ROW
            setBorderStyle.call(this,range.from.row, range.from.col, place, type);
          } else{
            setBorderStyle.call(this,range.from.row-1, range.from.col, "Bottom", type);
          }
          break;
        case "Left":
          if (range.from.col == 0){ // FIRST COLUMN
            setBorderStyle.call(this,range.from.row, range.from.col, place, type);
          } else{
            setBorderStyle.call(this,range.from.row, range.from.col-1, "Right", type);
          }
          break;
        default:
          setBorderStyle.call(this,range.from.row, range.from.col, place, type);
          break;
      }
    } else {
      switch (place) {
        case "Top":
          var topCol;
          if (range.from.row == 0){ // FIRST ROW
            for(topCol = range.from.col; topCol <= range.to.col; topCol++){
              setBorderStyle.call(this, range.from.row, topCol, place, type);
            }
          } else {
            for(topCol = range.from.col; topCol <= range.to.col; topCol++){
              setBorderStyle.call(this, range.from.row-1, topCol, "Bottom", type);
            }
          }

          break;
        case "Right":
          for(var rowRight = range.from.row; rowRight <=range.to.row; rowRight++){
            setBorderStyle.call(this,rowRight, range.to.col, place, type);
          }
          break;
        case "Bottom":
          for(var bottomCol = range.from.col; bottomCol <= range.to.col; bottomCol++){
            setBorderStyle.call(this, range.to.row, bottomCol, place, type);
          }
          break;
        case "Left":
          var rowLeft;
          if (range.from.col == 0){ // FIRST COLUMN
            for(rowLeft = range.from.row; rowLeft <=range.to.row; rowLeft++){
              setBorderStyle.call(this,rowLeft, range.from.col, place, type);
            }
          } else {
            for(rowLeft = range.from.row; rowLeft <=range.to.row; rowLeft++){
              setBorderStyle.call(this,rowLeft, range.from.col-1, "Right", type);
            }
          }

          break;
      }
    }

  }

  function ContextMenu(instance, customOptions){
    this.instance = instance;
    var contextMenu = this;

    this.menu = createMenu();
    this.enabled = true;

    this.bindMouseEvents();

    this.instance.addHook('afterDestroy', function () {
       contextMenu.destroy();
    });

    this.defaultOptions = {
      items: {
        'row_above': {
          name: 'Insert row above',
          callback: function(key, selection){
            this.alter("insert_row", selection.start.row);
          },
          disabled: function () {
            var selected = this.getSelected(),
              entireColumnSelection = [0,selected[1],this.view.wt.wtTable.getRowStrategy().cellCount-1,selected[1]],
              columnSelected = entireColumnSelection.join(',') == selected.join(',');

            return selected[0] < 0 || this.countRows() >= this.getSettings().maxRows || columnSelected;
          }
        },
        'row_below': {
          name: 'Insert row below',
          callback: function(key, selection){
            this.alter("insert_row", selection.end.row + 1);
          },
          disabled: function () {
            var selected = this.getSelected(),
              entireColumnSelection = [0,selected[1],this.view.wt.wtTable.getRowStrategy().cellCount-1,selected[1]],
              columnSelected = entireColumnSelection.join(',') == selected.join(',');

            return this.getSelected()[0] < 0 || this.countRows() >= this.getSettings().maxRows || columnSelected;
          }
        },
        "hsep1": ContextMenu.SEPARATOR,
        'col_left': {
          name: 'Insert column on the left',
          callback: function(key, selection){
            this.alter("insert_col", selection.start.col);
          },
          disabled: function () {
            var selected = this.getSelected(),
              entireRowSelection = [selected[0],0, selected[0],this.view.wt.wtTable.getColumnStrategy().cellCount-1],
              rowSelected = entireRowSelection.join(',') == selected.join(',');

            return this.getSelected()[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
          }
        },
        'col_right': {
          name: 'Insert column on the right',
          callback: function(key, selection){
            this.alter("insert_col", selection.end.col + 1);
          },
          disabled: function () {
            var selected = this.getSelected(),
              entireRowSelection = [selected[0],0, selected[0],this.view.wt.wtTable.getColumnStrategy().cellCount-1],
              rowSelected = entireRowSelection.join(',') == selected.join(',');

            return selected[1] < 0 || this.countCols() >= this.getSettings().maxCols || rowSelected;
          }
        },
        "hsep2": ContextMenu.SEPARATOR,
        'remove_row': {
          name: 'Remove row',
          callback: function(key, selection){
            var amount = selection.end.row - selection.start.row + 1;
            this.alter("remove_row", selection.start.row, amount);
          },
          disabled: function () {
            var selected = this.getSelected(),
              entireColumnSelection = [0,selected[1],this.view.wt.wtTable.getRowStrategy().cellCount-1,selected[1]],
              columnSelected = entireColumnSelection.join(',') == selected.join(',');
            return (selected[0] < 0 || columnSelected);
          }
        },
        'remove_col': {
          name: 'Remove column',
          callback: function(key, selection){
            var amount = selection.end.col - selection.start.col + 1;
            this.alter("remove_col", selection.start.col, amount);
          },
          disabled: function (){
            var selected = this.getSelected(),
              entireRowSelection = [selected[0],0, selected[0],this.view.wt.wtTable.getColumnStrategy().cellCount-1],
              rowSelected = entireRowSelection.join(',') == selected.join(',');
            return (selected[1] < 0 || rowSelected);
          }
        },
        "hsep3": ContextMenu.SEPARATOR,
        'undo': {
          name: 'Undo',
          callback: function(){
            this.undo();
          },
          disabled: function () {
            return this.undoRedo && !this.undoRedo.isUndoAvailable();
          }
        },
        'redo': {
          name: 'Redo',
          callback: function(){
            this.redo();
          },
          disabled: function () {
            return this.undoRedo && !this.undoRedo.isRedoAvailable();
          }
        },
        "hsep4": ContextMenu.SEPARATOR,
        'make_read_only': {
          name: function() {
            var atLeastOneReadOnly = contextMenu.checkSelectionReadOnlyConsistency(this);

            if(!atLeastOneReadOnly) {
              return "Make read-only";
            } else {
              return "Make writable";
            }
          },
          callback: function() {
            var atLeastOneReadOnly = contextMenu.checkSelectionReadOnlyConsistency(this);

            var that = this;
            this.getSelectedRange().forAll(function(r, c) {
              that.getCellMeta(r, c).readOnly = atLeastOneReadOnly ? false : true;
            });

            this.render();
          }
        },
        "hsep5": ContextMenu.SEPARATOR,
        'horizontal_alignment': {
          name: function () {
            var div = document.createElement('div'),
              button = document.createElement('button'),
              lButton = button.cloneNode(true),
              rButton = button.cloneNode(true),
              cButton = button.cloneNode(true),
              jButton = button.cloneNode(true),
              lText = document.createTextNode('left'),
              cText = document.createTextNode('center'),
              rText = document.createTextNode('right'),
              jText = document.createTextNode('justify');

            lButton.appendChild(lText);
            cButton.appendChild(cText);
            rButton.appendChild(rText);
            jButton.appendChild(jText);

            Handsontable.Dom.addClass(lButton,'Left');
            Handsontable.Dom.addClass(cButton,'Center');
            Handsontable.Dom.addClass(rButton,'Right');
            Handsontable.Dom.addClass(jButton,'Justify');

            div.appendChild(lButton);
            div.appendChild(cButton);
            div.appendChild(rButton);
            div.appendChild(jButton);

            return div.outerHTML;
          },
          callback: function (key, selection ,event) {
            var className = event.target.className,
              type = event.target.tagName;

            if (type === "BUTTON") {
              if(className) {
                align.call(this, this.getSelectedRange(),'horizontal','ht' + className );
              }
            }

          },
          disabled: function () {
            return false;
          }
        },
        "hsep6": ContextMenu.SEPARATOR,
        'vertical_alignment': {
          name: function () {
            var div = document.createElement('div'),
              button = document.createElement('button'),
              tButton = button.cloneNode(true),
              mButton = button.cloneNode(true),
              bButton = button.cloneNode(true),
              tText = document.createTextNode('top'),
              mText = document.createTextNode('middle'),
              bText = document.createTextNode('bottom');

            tButton.appendChild(tText);
            mButton.appendChild(mText);
            bButton.appendChild(bText);

            Handsontable.Dom.addClass(tButton,'Top');
            Handsontable.Dom.addClass(mButton,'Middle');
            Handsontable.Dom.addClass(bButton,'Bottom');

            div.appendChild(tButton);
            div.appendChild(mButton);
            div.appendChild(bButton);

            return div.outerHTML;
          },
          callback: function (key, selection ,event) {
            var className = event.target.className,
              type = event.target.tagName;
            if (type === "BUTTON") {
              if(className) {
                align.call(this, this.getSelectedRange(),'vertical','ht' + className );
              }
            }
          },
          disabled: function () {
            return false;
          }
        }
//        ,
//        'hsep6': ContextMenu.SEPARATOR,
//        'borders': {
//          name: function () {
//            var div = document.createElement('div'),
//              button = document.createElement('button'),
//              xButton = button.cloneNode(true),
//              tButton = button.cloneNode(true),
//              lButton = button.cloneNode(true),
//              bButton = button.cloneNode(true),
//              rButton = button.cloneNode(true),
//
//              xText = document.createTextNode('X'),
//              tText = document.createTextNode('top'),
//              rText = document.createTextNode('right'),
//              bText = document.createTextNode('bottom'),
//              lText = document.createTextNode('left');
//
//            xButton.appendChild(xText);
//            tButton.appendChild(tText);
//            rButton.appendChild(rText);
//            bButton.appendChild(bText);
//            lButton.appendChild(lText);
//
//            Handsontable.Dom.addClass(xButton,'noBorders');
//            Handsontable.Dom.addClass(tButton,'Top');
//            Handsontable.Dom.addClass(rButton,'Right');
//            Handsontable.Dom.addClass(bButton,'Bottom');
//            Handsontable.Dom.addClass(lButton,'Left');
//
//            div.appendChild(xButton);
//            div.appendChild(tButton);
//            div.appendChild(rButton);
//            div.appendChild(bButton);
//            div.appendChild(lButton);
//
//            return div.outerHTML;
//          },
//          callback:function(key, selection ,event){
//            var className = event.target.className,
//              type = event.target.tagName;
//            if (type === "BUTTON") {
//              console.log('button');
//              if(className) {
//                prepareBorder.call(this, this.getSelectedRange(), className);
//              }
//            }
//
//
//          },
//          disabled:function () {
//            return false;
//          }
//        }
      }
    };

    this.checkSelectionReadOnlyConsistency = function(hot) {
      var atLeastOneReadOnly = false;

      hot.getSelectedRange().forAll(function(r, c) {
        if(hot.getCellMeta(r, c).readOnly) {
          atLeastOneReadOnly = true;
          return false; //breaks forAll
        }
      });

      return atLeastOneReadOnly;
    };

    Handsontable.hooks.run(instance, 'afterContextMenuDefaultOptions', this.defaultOptions);

    this.options = {};
    Handsontable.helper.extend(this.options, this.defaultOptions);

    this.updateOptions(customOptions);

    function createMenu(){

      var menu = $('body > .htContextMenu')[0];

      if(!menu){
        menu = document.createElement('DIV');
        Handsontable.Dom.addClass(menu, 'htContextMenu');
        document.getElementsByTagName('body')[0].appendChild(menu);
      }

      return menu;
    }
  }

  ContextMenu.prototype.bindMouseEvents = function (){

    function contextMenuOpenListener(event){

      event.preventDefault();

      var showRowHeaders = this.instance.getSettings().rowHeaders,
          showColHeaders = this.instance.getSettings().colHeaders;

      if(!(showRowHeaders || showColHeaders)) {
        if(event.target.nodeName != 'TD' && !(Handsontable.Dom.hasClass(event.target, 'current') && Handsontable.Dom.hasClass(event.target, 'wtBorder'))){
          return;
        }
      }

      //if(event.target.nodeName != 'TD' && !(Handsontable.Dom.hasClass(event.target, 'current') && Handsontable.Dom.hasClass(event.target, 'wtBorder'))){
      //	return;
      //}

      this.show(event.pageY, event.pageX);
      $(document).on('mousedown.htContextMenu', Handsontable.helper.proxy(ContextMenu.prototype.close, this));
    }

    this.instance.rootElement.on('contextmenu.htContextMenu', Handsontable.helper.proxy(contextMenuOpenListener, this));

  };

  ContextMenu.prototype.bindTableEvents = function () {
    var that = this;

    this._afterScrollCallback = function () {
      // that.close();
    };

    this.instance.addHook('afterScrollVertically', this._afterScrollCallback);
    this.instance.addHook('afterScrollHorizontally', this._afterScrollCallback);
  };

  ContextMenu.prototype.unbindTableEvents = function () {
    if(this._afterScrollCallback){
      this.instance.removeHook('afterScrollVertically', this._afterScrollCallback);
      this.instance.removeHook('afterScrollHorizontally', this._afterScrollCallback);
      this._afterScrollCallback = null;
    }
  };

  ContextMenu.prototype.performAction = function (event){
    var hot = $(this.menu).handsontable('getInstance');
    var selectedItemIndex = hot.getSelected()[0];
    var selectedItem = hot.getData()[selectedItemIndex];

    if (selectedItem.disabled === true || (typeof selectedItem.disabled == 'function' && selectedItem.disabled.call(this.instance) === true)){
      return;
    }

    if(typeof selectedItem.callback != 'function'){
      return;
    }
    var selRange = this.instance.getSelectedRange();
    var normalizedSelection = ContextMenu.utils.normalizeSelection(selRange);

    selectedItem.callback.call(this.instance, selectedItem.key, normalizedSelection, event);
  };

  ContextMenu.prototype.unbindMouseEvents = function () {
    this.instance.rootElement.off('contextmenu.htContextMenu');
    $(document).off('mousedown.htContextMenu');
  };

  ContextMenu.prototype.show = function(top, left){
    this.menu.style.display = 'block';

    $(this.menu)
      .off('mousedown.htContextMenu')
      .on('mousedown.htContextMenu', Handsontable.helper.proxy(this.performAction, this));

    $(this.menu).handsontable({
      data: ContextMenu.utils.convertItemsToArray(this.getItems()),
      colHeaders: false,
      colWidths: [160],
      readOnly: true,
      copyPaste: false,
      columns: [
        {
          data: 'name',
          renderer: Handsontable.helper.proxy(this.renderer, this)
        }
      ],
      beforeKeyDown: Handsontable.helper.proxy(this.onBeforeKeyDown, this),
      renderAllRows: true
    });
    this.bindTableEvents();

    this.setMenuPosition(top, left);

    $(this.menu).handsontable('listen');

  };

  ContextMenu.prototype.close = function () {
    this.hide();
    $(document).off('mousedown.htContextMenu');
    this.unbindTableEvents();
    this.instance.listen();
  };

  ContextMenu.prototype.hide = function(){
    this.menu.style.display = 'none';
    $(this.menu).handsontable('destroy');
  };

  ContextMenu.prototype.renderer = function(instance, TD, row, col, prop, value, cellProperties){
    var contextMenu = this;
    var item = instance.getData()[row];
    var wrapper = document.createElement('DIV');

    if(typeof value === 'function') {
      value = value.call(this.instance);
    }

    Handsontable.Dom.empty(TD);
    TD.appendChild(wrapper);

    if(itemIsSeparator(item)){
      Handsontable.Dom.addClass(TD, 'htSeparator');
    } else {
      Handsontable.Dom.fastInnerHTML(wrapper, value);
    }

    if (itemIsDisabled(item)){
      Handsontable.Dom.addClass(TD, 'htDisabled');

      $(wrapper).on('mouseenter', function () {
        instance.deselectCell();
      });

    } else {
      Handsontable.Dom.removeClass(TD, 'htDisabled');

      $(wrapper).on('mouseenter', function () {
        instance.selectCell(row, col);
      });

    }

    function itemIsSeparator(item){
      return new RegExp(ContextMenu.SEPARATOR, 'i').test(item.name);
    }

    function itemIsDisabled(item){
      return item.disabled === true || (typeof item.disabled == 'function' && item.disabled.call(contextMenu.instance) === true);
    }
  };

  ContextMenu.prototype.onBeforeKeyDown = function (event) {
    var contextMenu = this;
    var instance = $(contextMenu.menu).handsontable('getInstance');
    var selection = instance.getSelected();

    switch(event.keyCode){

      case Handsontable.helper.keyCode.ESCAPE:
        contextMenu.close();
        event.preventDefault();
        event.stopImmediatePropagation();
        break;

      case Handsontable.helper.keyCode.ENTER:
        if(instance.getSelected()){
          contextMenu.performAction();
          contextMenu.close();
        }
        break;

      case Handsontable.helper.keyCode.ARROW_DOWN:
        if(!selection){

          selectFirstCell(instance);

        } else {

          selectNextCell(selection[0], selection[1], instance);

        }

        event.preventDefault();
        event.stopImmediatePropagation();

        break;

      case Handsontable.helper.keyCode.ARROW_UP:
        if(!selection){

          selectLastCell(instance);

        }  else {

          selectPrevCell(selection[0], selection[1], instance);

        }

        event.preventDefault();
        event.stopImmediatePropagation();

        break;

    }

    function selectFirstCell(instance) {

      var firstCell = instance.getCell(0, 0);

      if(ContextMenu.utils.isSeparator(firstCell) || ContextMenu.utils.isDisabled(firstCell)){
        selectNextCell(0, 0, instance);
      } else {
        instance.selectCell(0, 0);
      }

    }


    function selectLastCell(instance) {

      var lastRow = instance.countRows() - 1;
      var lastCell = instance.getCell(lastRow, 0);

      if(ContextMenu.utils.isSeparator(lastCell) || ContextMenu.utils.isDisabled(lastCell)){
        selectPrevCell(lastRow, 0, instance);
      } else {
        instance.selectCell(lastRow, 0);
      }

    }

    function selectNextCell(row, col, instance){
      var nextRow = row + 1;
      var nextCell =  nextRow < instance.countRows() ? instance.getCell(nextRow, col) : null;

      if(!nextCell){
        return;
      }

      if(ContextMenu.utils.isSeparator(nextCell) || ContextMenu.utils.isDisabled(nextCell)){
        selectNextCell(nextRow, col, instance);
      } else {
        instance.selectCell(nextRow, col);
      }
    }

    function selectPrevCell(row, col, instance) {

      var prevRow = row - 1;
      var prevCell = prevRow >= 0 ? instance.getCell(prevRow, col) : null;

      if (!prevCell) {
        return;
      }

      if(ContextMenu.utils.isSeparator(prevCell) || ContextMenu.utils.isDisabled(prevCell)){
        selectPrevCell(prevRow, col, instance);
      } else {
        instance.selectCell(prevRow, col);
      }

    }

  };

  ContextMenu.prototype.getItems = function () {
    var items = {};
    function Item(rawItem){
      if(typeof rawItem == 'string'){
        this.name = rawItem;
      } else {
        Handsontable.helper.extend(this, rawItem);
      }
    }
    Item.prototype = this.options;

    for(var itemName in this.options.items){
      if(this.options.items.hasOwnProperty(itemName) && (!this.itemsFilter || this.itemsFilter.indexOf(itemName) != -1)){
        items[itemName] = new Item(this.options.items[itemName]);
      }
    }

    return items;

  };

  ContextMenu.prototype.updateOptions = function(newOptions){
    newOptions = newOptions || {};

    if(newOptions.items){
      for(var itemName in newOptions.items){
        var item = {};

        if(newOptions.items.hasOwnProperty(itemName)) {
          if(this.defaultOptions.items.hasOwnProperty(itemName)
            && Handsontable.helper.isObject(newOptions.items[itemName])){
            Handsontable.helper.extend(item, this.defaultOptions.items[itemName]);
            Handsontable.helper.extend(item, newOptions.items[itemName]);
            newOptions.items[itemName] = item;
          }
        }

      }
    }

    Handsontable.helper.extend(this.options, newOptions);
  };

  ContextMenu.prototype.setMenuPosition = function (cursorY, cursorX) {
    var scrollTop = Handsontable.Dom.getWindowScrollTop();
    var scrollLeft = Handsontable.Dom.getWindowScrollLeft();

    var cursor = {
      top:  cursorY,
      topRelative: cursorY - scrollTop,
      left: cursorX,
      leftRelative:cursorX - scrollLeft,
      scrollTop: scrollTop,
      scrollLeft: scrollLeft
    };

    if(this.menuFitsBelowCursor(cursor)){
      this.positionMenuBelowCursor(cursor);
    } else {
      if (this.menuFitsAboveCursor(cursor)) {
        this.positionMenuAboveCursor(cursor);
      } else {
        this.positionMenuBelowCursor(cursor);
      }
    }

    if(this.menuFitsOnRightOfCursor(cursor)){
      this.positionMenuOnRightOfCursor(cursor);
    } else {
      this.positionMenuOnLeftOfCursor(cursor);
    }

  };

  ContextMenu.prototype.menuFitsAboveCursor = function (cursor) {
    return cursor.topRelative >= this.menu.offsetHeight;
  };

  ContextMenu.prototype.menuFitsBelowCursor = function (cursor) {
    return cursor.topRelative + this.menu.offsetHeight <= cursor.scrollTop + document.body.clientHeight;
  };

  ContextMenu.prototype.menuFitsOnRightOfCursor = function (cursor) {
    return cursor.leftRelative + this.menu.offsetWidth <= cursor.scrollLeft + document.body.clientWidth;
  };

  ContextMenu.prototype.positionMenuBelowCursor = function (cursor) {
    this.menu.style.top = cursor.top + 'px';
  };

  ContextMenu.prototype.positionMenuAboveCursor = function (cursor) {
    this.menu.style.top = (cursor.top - this.menu.offsetHeight) + 'px';
  };

  ContextMenu.prototype.positionMenuOnRightOfCursor = function (cursor) {
    this.menu.style.left = cursor.left + 'px';
  };

  ContextMenu.prototype.positionMenuOnLeftOfCursor = function (cursor) {
    this.menu.style.left = (cursor.left - this.menu.offsetWidth) + 'px';
  };

  ContextMenu.utils = {};
  ContextMenu.utils.convertItemsToArray = function (items) {
    var itemArray = [];
    var item;
    for(var itemName in items){
      if(items.hasOwnProperty(itemName)){
        if(typeof items[itemName] == 'string'){
          item = {name: items[itemName]};
        } else if (items[itemName].visible !== false) {
          item = items[itemName];
        } else {
          continue;
        }

        item.key = itemName;
        itemArray.push(item);
      }
    }

    return itemArray;
  };

  ContextMenu.utils.normalizeSelection = function(selRange){
    return {
      start: selRange.getTopLeftCorner(),
      end: selRange.getBottomRightCorner()
    }
  };

  ContextMenu.utils.isSeparator = function (cell) {
    return Handsontable.Dom.hasClass(cell, 'htSeparator');
  };

  ContextMenu.utils.isDisabled = function (cell) {
    return Handsontable.Dom.hasClass(cell, 'htDisabled');
  };

  ContextMenu.prototype.enable = function () {
    if(!this.enabled){
      this.enabled = true;
      this.bindMouseEvents();
    }
  };

  ContextMenu.prototype.disable = function () {
    if(this.enabled){
      this.enabled = false;
      this.close();
      this.unbindMouseEvents();
      this.unbindTableEvents();
    }
  };

  ContextMenu.prototype.destroy = function () {
    this.close();
    this.unbindMouseEvents();
    this.unbindTableEvents();

    if(!this.isMenuEnabledByOtherHotInstance()){
      this.removeMenu();
    }

  };

  ContextMenu.prototype.isMenuEnabledByOtherHotInstance = function () {
    var hotContainers = $('.handsontable');
    var menuEnabled = false;

    for(var i = 0, len = hotContainers.length; i < len; i++){
      var instance = $(hotContainers[i]).handsontable('getInstance');
      if(instance && instance.getSettings().contextMenu){
        menuEnabled = true;
        break;
      }
    }

    return menuEnabled;
  };

  ContextMenu.prototype.removeMenu = function () {
    if(this.menu.parentNode){
      this.menu.parentNode.removeChild(this.menu);
    }
  };

  ContextMenu.prototype.filterItems = function(itemsToLeave){
    this.itemsFilter = itemsToLeave;
  };

  ContextMenu.SEPARATOR = "---------";

  function updateHeight() {

    if(this.rootElement[0].className.indexOf('htContextMenu')) {
      return;
    }

    var realSeparatorHeight = 0,
        realEntrySize = 0,
        dataSize = this.getSettings().data.length;

    for(var i = 0; i < dataSize; i++) {
      if(this.getSettings().data[i].name == ContextMenu.SEPARATOR) {
        realSeparatorHeight += 2;
      } else {
        realEntrySize += 26;
      }
    }

    this.view.wt.wtScrollbars.vertical.fixedContainer.style.height = realEntrySize + realSeparatorHeight + "px";
  }

  function init(){
    var instance = this;
    var contextMenuSetting = instance.getSettings().contextMenu;
    var customOptions = Handsontable.helper.isObject(contextMenuSetting) ? contextMenuSetting : {};

    if(contextMenuSetting){
      if(!instance.contextMenu){
        instance.contextMenu = new ContextMenu(instance, customOptions);
      }

      instance.contextMenu.enable();

      if(Handsontable.helper.isArray(contextMenuSetting)){
        instance.contextMenu.filterItems(contextMenuSetting);
      }

    }  else if(instance.contextMenu){
      instance.contextMenu.destroy();
      delete instance.contextMenu;
    }

  }

  Handsontable.hooks.add('afterInit', init);
  Handsontable.hooks.add('afterUpdateSettings', init);
  Handsontable.hooks.add('afterInit',updateHeight);

  if(Handsontable.PluginHooks.register) { //HOT 0.11+
    Handsontable.PluginHooks.register('afterContextMenuDefaultOptions');
  }

  Handsontable.ContextMenu = ContextMenu;

})(Handsontable);

function Comments(instance) {

  var doSaveComment = function (row, col, comment, instance) {
      instance.setCellMeta(row, col, 'comment', comment);
      instance.render();
    },
    saveComment = function (range, comment, instance) {
		 //LIKE IN EXCEL (TOP LEFT CELL)
      doSaveComment(range.from.row, range.from.col, comment, instance);
    },
    hideCommentTextArea = function () {
      var commentBox = createCommentBox();
      commentBox.style.display = 'none';
      commentBox.value = '';
    },
    bindMouseEvent = function (range) {

			function commentsListener(event) {
				$(document).off('mouseover.htCommment');
        if (!(event.target.className == 'htCommentTextArea' || event.target.innerHTML.indexOf('Comment') != -1)) {
          var value = document.getElementsByClassName('htCommentTextArea')[0].value;
          if (value.trim().length > 1) {
            saveComment(range, value, instance);
          }
		      unBindMouseEvent();
          hideCommentTextArea();
        }
      }

      $(document).on('mousedown.htCommment', Handsontable.helper.proxy(commentsListener));
    },
    unBindMouseEvent = function () {
      $(document).off('mousedown.htCommment');
			$(document).on('mouseover.htCommment', Handsontable.helper.proxy(commentsMouseOverListener));
    },
    placeCommentBox = function (range, commentBox) {
      var TD = instance.view.wt.wtTable.getCell(range.from),
        offset = Handsontable.Dom.offset(TD),
        lastColWidth = instance.getColWidth(range.from.col);

      commentBox.style.position = 'absolute';
      commentBox.style.left = offset.left + lastColWidth + 'px';
      commentBox.style.top = offset.top + 'px';
      commentBox.style.zIndex = 2;
      bindMouseEvent(range, commentBox);
    },
    createCommentBox = function (value) {
      var comments = document.getElementsByClassName('htComments')[0];

      if (!comments) {
        comments = document.createElement('DIV');

        var textArea = document.createElement('TEXTAREA');
        Handsontable.Dom.addClass(textArea, 'htCommentTextArea');
        textArea.style.backgroundColor = '#FFFACD';
        textArea.style.boxShadow = '1px 1px 2px #bbb';
        textArea.style.fontFamily = 'Arial';
        comments.appendChild(textArea);

        Handsontable.Dom.addClass(comments, 'htComments');
        document.getElementsByTagName('body')[0].appendChild(comments);
      }

			value = value ||'';

      document.getElementsByClassName('htCommentTextArea')[0].value = value;

      //var tA = document.getElementsByClassName('htCommentTextArea')[0];
      //tA.focus();
      return comments;
    },
    commentsMouseOverListener = function (event) {
        if(event.target.className.indexOf('htCommentCell') != -1) {
						unBindMouseEvent();
            var coords = instance.view.wt.wtTable.getCoords(event.target);
            var range = {
                from: new WalkontableCellCoords(coords.row, coords.col)
            };

            Handsontable.Comments.showComment(range);
        }
        else if(event.target.className !='htCommentTextArea'){
            hideCommentTextArea();
        }
    };

  return {
    init: function () {
        $(document).on('mouseover.htCommment', Handsontable.helper.proxy(commentsMouseOverListener));
    },
    showComment: function (range) {
			var meta = instance.getCellMeta(range.from.row, range.from.col),
        value = '';

      if (meta.comment) {
        value = meta.comment;
      }
      var commentBox = createCommentBox(value);
      commentBox.style.display = 'block';
      placeCommentBox(range, commentBox);
    },
    removeComment: function (row, col) {
      instance.removeCellMeta(row, col, 'comment');
      instance.render();
    },
    checkSelectionCommentsConsistency : function () {
      var hasComment = false;
      // IN EXCEL THERE IS COMMENT ONLY FOR TOP LEFT CELL IN SELECTION
      var cell = instance.getSelectedRange().from;

      if(instance.getCellMeta(cell.row,cell.col).comment) {
        hasComment = true;
      }
      return hasComment;
    }


  };
}


var init = function () {
    var instance = this;
    var commentsSetting = instance.getSettings().comments;

    if (commentsSetting) {
      Handsontable.Comments = new Comments(instance);
        Handsontable.Comments.init();
    }
  },
  afterRenderer = function (TD, row, col, prop, value, cellProperties) {
    if(cellProperties.comment) {
      Handsontable.Dom.addClass(TD, cellProperties.commentedCellClassName);
    }
  },
  addCommentsActionsToContextMenu = function (defaultOptions) {
    var instance = this;
    if (!instance.getSettings().comments) {
      return;
    }

    defaultOptions.items.commentsCellsSeparator = Handsontable.ContextMenu.SEPARATOR;

    defaultOptions.items.commentsAddEdit = {
      name: function () {
        var hasComment = Handsontable.Comments.checkSelectionCommentsConsistency();
        return hasComment ? "Edit Comment" : "Add Comment";

      },
      callback: function (key, selection, event) {
          Handsontable.Comments.showComment(this.getSelectedRange());
      },
      disabled: function () {
        return false;
      }
    };

    defaultOptions.items.commentsRemove = {
      name: function () {
        return "Delete Comment"
      },
      callback: function (key, selection, event) {
        Handsontable.Comments.removeComment(selection.start.row, selection.start.col);
      },
      disabled: function () {
        var hasComment = Handsontable.Comments.checkSelectionCommentsConsistency();
        return !hasComment;
      }
    }
  };

Handsontable.hooks.add('beforeInit', init);
Handsontable.hooks.add('afterContextMenuDefaultOptions', addCommentsActionsToContextMenu);
Handsontable.hooks.add('afterRenderer', afterRenderer);
//$(document).on('mouseover.htCommment', Handsontable.helper.proxy(commentsMouseOverListener));
function HandsontableManualColumnMove() {
  var pressed
    , startCol
    , endCol
    , startX
    , startOffset
    , moveHandle
    , scrollLeft
    , scrollTop
    , currentCol;

  var ghost = document.createElement('DIV')
    , ghostStyle = ghost.style;

  ghost.className = 'ghost';
  ghostStyle.position = 'absolute';
  ghostStyle.top = '25px';
  ghostStyle.left = 0;
  ghostStyle.width = '10px';
  ghostStyle.height = '10px';
  ghostStyle.backgroundColor = '#CCC';
  ghostStyle.opacity = 0.7;

  var saveManualColumnPositions = function () {
    var instance = this;

    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnPositions', instance.manualColumnPositions);
  };

  var loadManualColumnPositions = function () {
    var instance = this;
    var storedState = {};
    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnPositions', storedState);

    return storedState.value;
  };

  var bindMoveColEvents = function () {
    var instance = this;

    instance.rootElement.on('mousemove.manualColumnMove', function (e) {
      if (pressed) {
        ghostStyle.left = startOffset + e.pageX - startX + 6 + 'px';
        if (ghostStyle.display === 'none') {
          ghostStyle.display = 'block';
        }
      }
    });

    instance.rootElement.on('mouseup.manualColumnMove', function () {
      if (pressed) {
        if (startCol < endCol) {
          endCol--;
        }
        if (instance.getSettings().rowHeaders) {
          startCol--;
          endCol--;
        }
        instance.manualColumnPositions.splice(endCol, 0, instance.manualColumnPositions.splice(startCol, 1)[0]);
        $('.manualColumnMover.active').removeClass('active');
        pressed = false;
        instance.forceFullRender = true;
        instance.view.render(); //updates all
        ghostStyle.display = 'none';

        saveManualColumnPositions.call(instance);

        Handsontable.hooks.run(instance, 'afterColumnMove', startCol, endCol);
      }
    });

    instance.rootElement.on('mousedown.manualColumnMove', '.manualColumnMover', function (e) {

      var mover = e.currentTarget,
          TH = instance.view.THEAD.querySelectorAll('th')[currentCol];

      startCol = Handsontable.Dom.index(TH) + instance.colOffset();
      endCol = startCol;
      pressed = true;
      startX = e.pageX;

      var TABLE = instance.$table[0];
      TABLE.parentNode.appendChild(ghost);
      ghostStyle.width = Handsontable.Dom.outerWidth(TH) + 'px';
      ghostStyle.height = Handsontable.Dom.outerHeight(TABLE) + 'px';
      startOffset = parseInt(Handsontable.Dom.offset(TH).left - Handsontable.Dom.offset(TABLE).left, 10);
      ghostStyle.left = startOffset + 6 + 'px';
      ghostStyle.display = 'none';
    });

    instance.rootElement.on('mouseenter.manualColumnMove', 'td, th', function (e) {
      var currentColId = Handsontable.Dom.index(this) + instance.colOffset();
          currentCol = currentColId;

      if (pressed) {
        var active = instance.view.THEAD.querySelector('.manualColumnMover.active');
        if (active) {
          Handsontable.Dom.removeClass(active, 'active');
        }
        endCol = currentColId;
        var mover = instance.rootElement[0].querySelector('.manualColumnMover');
        Handsontable.Dom.addClass(mover, 'active');
      }

    });

    instance.rootElement.on('mouseenter.manualColumnMove', 'table thead tr > th', function (event) {
      updateHandlePosition.call(instance, moveHandle, event.target);
    });

    instance.addHook('afterDestroy', unbindMoveColEvents);
  };

  var unbindMoveColEvents = function(){
    var instance = this;
    instance.rootElement.off('mouseup.manualColumnMove');
    instance.rootElement.off('mousemove.manualColumnMove');
    instance.rootElement.off('mousedown.manualColumnMove');
    instance.rootElement.off('mouseenter.manualColumnMove');
  };

  this.beforeInit = function () {
    this.manualColumnPositions = [];
  };

  this.init = function (source) {
    var instance = this;

    var manualColMoveEnabled = !!(this.getSettings().manualColumnMove);

    if (manualColMoveEnabled) {
      var initialManualColumnPositions = this.getSettings().manualColumnMove;

      var loadedManualColumnPositions = loadManualColumnPositions.call(instance);

      if (typeof loadedManualColumnPositions != 'undefined') {
        this.manualColumnPositions = loadedManualColumnPositions;
      } else if (initialManualColumnPositions instanceof Array) {
        this.manualColumnPositions = initialManualColumnPositions;
      } else {
        this.manualColumnPositions = [];
      }


      instance.forceFullRender = true;

      if (source == 'afterInit') {
        bindMoveColEvents.call(this);
        if (this.manualColumnPositions.length > 0) {
          this.forceFullRender = true;
          this.render();
        }

        moveHandle = addHandle.call(this,'manualColumnMover');
        Handsontable.hooks.add('afterRender', afterRender);
      }

    } else {
      unbindMoveColEvents.call(this);
      this.manualColumnPositions = [];
    }
  };

  var afterRender = function () {
    var instance = this;
    scrollTop = instance.rootElement.scrollTop();
    scrollLeft = instance.rootElement.scrollLeft();
    currentCol = 0;
  };

  var addHandle = function (className) {
    var handle = document.createElement('DIV')
      , instance = this;

    handle.className = className;
    handle.style.left = instance.getCell(0,0).offsetLeft + 'px';
    handle.style.top ='0px';
    instance.rootElement[0].appendChild(handle);

    return handle;
  };

  var updateHandlePosition = function (handle, target) {
    var instance = this;

    handle.style.left = target.offsetLeft + 'px';
    handle.style.top = Handsontable.Dom.getScrollTop(instance.rootElement[0]) + "px";
  };

  this.modifyCol = function (col) {
    //TODO test performance: http://jsperf.com/object-wrapper-vs-primitive/2
    if (this.getSettings().manualColumnMove) {
      if (typeof this.manualColumnPositions[col] === 'undefined') {
        this.manualColumnPositions[col] = col;
      }
      return this.manualColumnPositions[col];
    }
    return col;
  };

}
var htManualColumnMove = new HandsontableManualColumnMove();

Handsontable.hooks.add('beforeInit', htManualColumnMove.beforeInit);
Handsontable.hooks.add('afterInit', function () {
  htManualColumnMove.init.call(this, 'afterInit')
});

Handsontable.hooks.add('afterUpdateSettings', function () {
  htManualColumnMove.init.call(this, 'afterUpdateSettings')
});
// Handsontable.hooks.add('afterGetColHeader', htManualColumnMove.getColHeader);
Handsontable.hooks.add('modifyCol', htManualColumnMove.modifyCol);

Handsontable.hooks.register('afterColumnMove');



function HandsontableManualColumnResize() {
  var pressed
    , currentTH
    , currentCol
    , currentWidth
    , instance
    , newSize
    , startX
    , startWidth
    , startOffset
    , scrollTop = 0
    , scrollLeft = 0
    , resizer = document.createElement('DIV')
    , handle = document.createElement('DIV')
    , line = document.createElement('DIV')
    , lineStyle = line.style;

  resizer.className = 'manualColumnResizer';

  handle.className = 'manualColumnResizerHandle';
  resizer.appendChild(handle);

  line.className = 'manualColumnResizerLine';
  resizer.appendChild(line);

  var $document = $(document);

  $document.mousemove(function (e) {
    if (pressed) {
      currentWidth = startWidth + (e.pageX - startX);
      newSize = setManualSize(currentCol, currentWidth); //save col width
      resizer.style.left = startOffset + currentWidth + 'px';
    }
  });

  $document.mouseup(function () {
    if (pressed) {
      Handsontable.Dom.removeClass(resizer, 'active');
      pressed = false;

      if(newSize != startWidth){
        instance.forceFullRender = true;
        instance.view.render(); //updates all

        saveManualColumnWidths.call(instance);

        Handsontable.hooks.run(instance, 'afterColumnResize', currentCol, newSize);
      }

      refreshResizerPosition.call(instance, currentTH);
    }
  });

  var saveManualColumnWidths = function () {
    var instance = this;

    Handsontable.hooks.run(instance, 'persistentStateSave', 'manualColumnWidths', instance.manualColumnWidths);
  };

  var loadManualColumnWidths = function () {
    var instance = this;
    var storedState = {};
    Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualColumnWidths', storedState);

    return storedState.value;
  };

  function refreshResizerPosition(TH) {
    instance = this;
    currentTH = TH;

    var col = this.view.wt.wtTable.getCoords(TH).col; //getCoords returns WalkontableCellCoords
    if (col >= 0) { //if not row header
      currentCol = col;
      var rootOffset = Handsontable.Dom.offset(this.rootElement[0]).left;
      var thOffset = Handsontable.Dom.offset(TH).left;
      startOffset = (thOffset - rootOffset) - 6 + scrollLeft;
      resizer.style.left = startOffset + parseInt(Handsontable.Dom.outerWidth(TH), 10) + 'px';
      resizer.style.top = scrollTop + 'px';
      this.rootElement[0].appendChild(resizer);
    }
  }

  function refreshLinePosition() {
    var instance = this;
    startWidth = parseInt(Handsontable.Dom.outerWidth(currentTH), 10);
    Handsontable.Dom.addClass(resizer, 'active');
    lineStyle.height = Handsontable.Dom.outerHeight(instance.$table[0]) + 'px';
    pressed = instance;
  }

  var bindManualColumnWidthEvents = function () {
    var instance = this;
    var dblclick = 0;
    var autoresizeTimeout = null;

    this.rootElement.on('mouseenter.handsontable', 'table thead tr > th', function (e) {
      if (!pressed) {
        refreshResizerPosition.call(instance, e.currentTarget);
      }
    });

    this.rootElement.on('mousedown.handsontable', '.manualColumnResizer', function () {
      if (autoresizeTimeout == null) {
        autoresizeTimeout = setTimeout(function () {
          if (dblclick >= 2) {
            newSize = instance.determineColumnWidth.call(instance, currentCol);
            setManualSize(currentCol, newSize);
            instance.forceFullRender = true;
            instance.view.render(); //updates all
            Handsontable.hooks.run(instance, 'afterColumnResize', currentCol, newSize);
          }
          dblclick = 0;
          autoresizeTimeout = null;
        }, 500);
      }
      dblclick++;
    });

    this.rootElement.on('mousedown.handsontable', '.manualColumnResizer', function (e) {
      startX = e.pageX;
      refreshLinePosition.call(instance);
      newSize = startWidth;
    });
  };

  this.beforeInit = function () {
    this.manualColumnWidths = [];
  };

  this.init = function (source) {
    var instance = this;
    var manualColumnWidthEnabled = !!(this.getSettings().manualColumnResize);

    if (manualColumnWidthEnabled) {
      var initialColumnWidths = this.getSettings().manualColumnResize;

      var loadedManualColumnWidths = loadManualColumnWidths.call(instance);

      if (typeof loadedManualColumnWidths != 'undefined') {
        this.manualColumnWidths = loadedManualColumnWidths;
      } else if (initialColumnWidths instanceof Array) {
        this.manualColumnWidths = initialColumnWidths;
      } else {
        this.manualColumnWidths = [];
      }

      if (source == 'afterInit') {
        bindManualColumnWidthEvents.call(this);
        instance.forceFullRender = true;
        instance.render();

        Handsontable.hooks.add('afterScrollVertically', afterScrollVertically);
        Handsontable.hooks.add('afterScrollHorizontally', afterScrollHorizontally);
      }
    }
  };


  var setManualSize = function (col, width) {
    width = Math.max(width, 20);

    /**
     *  We need to run col through modifyCol hook, in case the order of displayed columns is different than the order
     *  in data source. For instance, this order can be modified by manualColumnMove plugin.
     */
    col = Handsontable.hooks.execute(instance, 'modifyCol', col);

    instance.manualColumnWidths[col] = width;
    return width;
  };

  this.modifyColWidth = function (width, col) {
    col = this.runHooksAndReturn('modifyCol', col);
    if (this.getSettings().manualColumnResize && this.manualColumnWidths[col]) {
      return this.manualColumnWidths[col];
    }
    return width;
  };

  var afterScrollVertically = function () {
    scrollTop = Handsontable.Dom.getScrollTop(this.rootElement[0]);
  };

  var afterScrollHorizontally = function () {
    scrollLeft = Handsontable.Dom.getScrollLeft(this.rootElement[0]);
  }
}
var htManualColumnResize = new HandsontableManualColumnResize();

Handsontable.hooks.add('beforeInit', htManualColumnResize.beforeInit);
Handsontable.hooks.add('afterInit', function () {
  htManualColumnResize.init.call(this, 'afterInit')
});
Handsontable.hooks.add('afterUpdateSettings', function () {
  htManualColumnResize.init.call(this, 'afterUpdateSettings')
});
Handsontable.hooks.add('modifyColWidth', htManualColumnResize.modifyColWidth);

Handsontable.hooks.register('afterColumnResize');

(function (Handsontable) {
  function HandsontableManualRowResize () {

    var pressed
      , currentTH
      , currentRow
      , currentHeight
      , instance
      , newSize
      , startY
      , startHeight
      , startOffset
      , scrollTop = 0
      , scrollLeft = 0
      , resizer = document.createElement('DIV')
      , handle = document.createElement('DIV')
      , line = document.createElement('DIV')
      , lineStyle = line.style;


    resizer.className = 'manualRowResizer';
    handle.className = 'manualRowResizerHandle';

    resizer.appendChild(handle);

    line.className = 'manualRowResizerLine';
    resizer.appendChild(line);

    var $document = $(document);
    $document.mousemove(function (e) {
      if (pressed) {
        currentHeight = startHeight + (e.pageY - startY);
        newSize = setManualSize(currentRow, currentHeight);
        resizer.style.top = startOffset + currentHeight + 'px';
      }
    });

    $document.mouseup(function () {
      if (pressed) {
        Handsontable.Dom.removeClass(resizer, 'active');
        pressed = false;

        if (newSize != startHeight) {
          instance.forceFullRender = true;
          instance.view.render();

          saveManualRowHeights.call(instance);

          Handsontable.hooks.run(instance, 'afterRowResize', currentRow, newSize);
        }

        refreshResizerPosition.call(instance, currentTH);
      }
    });

    var saveManualRowHeights = function () {
      var instance = this;
      Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowHeights', instance.manualRowHeights);
    };

    var loadManualRowHeights = function () {
      var instance = this
        , storedState = {};

      Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowHeights', storedState);

      return storedState.value;
    };

    var refreshResizerPosition = function(TH) {
      instance = this;
      currentTH = TH;

      var row = this.view.wt.wtTable.getCoords(TH).row; //getCoords returns WalkontableCellCoords

      if (row >= 0) { //if not row header
        currentRow = row;
        var rootOffset = Handsontable.Dom.offset(this.rootElement[0]).top;
        var thOffset = Handsontable.Dom.offset(TH).top;
        startOffset = (thOffset - rootOffset) + scrollTop - 4;
        resizer.style.top = startOffset + parseInt(Handsontable.Dom.outerHeight(TH), 10) + 'px';
        resizer.style.left = scrollLeft + 'px';
        this.rootElement[0].appendChild(resizer);
      }
    }

    var refreshLinePosition = function() {
      var instance = this;
      startHeight = parseInt(Handsontable.Dom.outerHeight(currentTH), 10);
      Handsontable.Dom.addClass(resizer, 'active');
      lineStyle.width = Handsontable.Dom.outerWidth(instance.$table[0]) + 'px';
      pressed = instance;
    }

    var bindManualRowHeightEvents = function () {
      var instance = this,
        autoresizeTimeout = null,
        dblclick = 0;


      instance.rootElement.on('mouseenter.handsontable', 'table tbody tr > th', function (e) {
        if (!pressed) {
          refreshResizerPosition.call(instance, e.currentTarget);
        }
      });


      instance.rootElement.on('mousedown.handsontable', '.manualRowResizer', function () {
        if (autoresizeTimeout == null) {
          autoresizeTimeout = setTimeout(function () {

            if (dblclick >= 2) {
              setManualSize(currentRow, null); //double click sets auto row size
              instance.forceFullRender = true;
              instance.view.render();
              Handsontable.hooks.run(instance, 'afterRowResize', currentRow, newSize);
            }

            dblclick = 0;
            autoresizeTimeout = null;
          }, 200);
        }
        dblclick++;
      });

      instance.rootElement.on('mousedown.handsontable', '.manualRowResizer', function (e) {
        startY = e.pageY;
        refreshLinePosition.call(instance);
        newSize = startHeight;
      });
    };

    this.beforeInit = function () {
      this.manualRowHeights = [];
    };

    this.init = function (source) {

      var instance = this;
      var manualColumnHeightEnabled = !!(this.getSettings().manualRowResize);

      if (manualColumnHeightEnabled) {

        var initialRowHeights = this.getSettings().manualRowResize;

        var loadedManualRowHeights = loadManualRowHeights.call(instance);

        if (typeof loadedManualRowHeights != 'undefined') {
          this.manualRowHeights = loadedManualRowHeights;
        } else if (initialRowHeights instanceof Array) {
          this.manualRowHeights = initialRowHeights;
        } else {
          this.manualRowHeights = [];
        }

        if (source === 'afterInit') {
          bindManualRowHeightEvents.call(this);
          instance.forceFullRender = true;
          instance.render();
          Handsontable.hooks.add('afterScrollVertically', afterScrollVertically);
          Handsontable.hooks.add('afterScrollHorizontally', afterScrollHorizontally);
        }
      }
    };

    var setManualSize = function (row, height) {
      row = Handsontable.hooks.execute(instance, 'modifyRow', row);

      instance.manualRowHeights[row] = height;
      return height;
    };

    this.modifyRowHeight = function (height, row) {
      if (this.getSettings().manualRowResize) {
        row = this.runHooksAndReturn('modifyRow', row);
        if (this.manualRowHeights[row] !== void 0) {
          return this.manualRowHeights[row];
        }
      }
      return height;
    };

    var afterScrollVertically = function () {
      scrollTop = Handsontable.Dom.getScrollTop(this.rootElement[0]);
    };

    var afterScrollHorizontally = function () {
      scrollLeft = Handsontable.Dom.getScrollLeft(this.rootElement[0]);
    }
  }

  var htManualRowResize = new HandsontableManualRowResize();

  Handsontable.hooks.add('beforeInit', htManualRowResize.beforeInit);
  Handsontable.hooks.add('afterInit', function () {
    htManualRowResize.init.call(this, 'afterInit');
  });

  Handsontable.hooks.add('afterUpdateSettings', function () {
    htManualRowResize.init.call(this, 'afterUpdateSettings')
  });

  Handsontable.hooks.add('modifyRowHeight', htManualRowResize.modifyRowHeight);

  Handsontable.hooks.register('afterRowResize');

})(Handsontable);

(function HandsontableObserveChanges() {

  Handsontable.hooks.add('afterLoadData', init);
  Handsontable.hooks.add('afterUpdateSettings', init);

  Handsontable.hooks.register('afterChangesObserved');

  function init() {
    var instance = this;
    var pluginEnabled = instance.getSettings().observeChanges;

    if (pluginEnabled) {
      if(instance.observer) {
        destroy.call(instance); //destroy observer for old data object
      }
      createObserver.call(instance);
      bindEvents.call(instance);

    } else if (!pluginEnabled){
      destroy.call(instance);
    }
  }

  function createObserver(){
    var instance = this;

    instance.observeChangesActive = true;

    instance.pauseObservingChanges = function(){
      instance.observeChangesActive = false;
    };

    instance.resumeObservingChanges = function(){
      instance.observeChangesActive = true;
    };

    instance.observedData = instance.getData();
    instance.observer = jsonpatch.observe(instance.observedData, function (patches) {
      if(instance.observeChangesActive){
        runHookForOperation.call(instance, patches);
        instance.render();
      }

      instance.runHooks('afterChangesObserved');
    });
  }

  function runHookForOperation(rawPatches){
    var instance = this;
    var patches = cleanPatches(rawPatches);

    for(var i = 0, len = patches.length; i < len; i++){
      var patch = patches[i];
      var parsedPath = parsePath(patch.path);


      switch(patch.op){
        case 'add':
          if(isNaN(parsedPath.col)){
            instance.runHooks('afterCreateRow', parsedPath.row);
          } else {
            instance.runHooks('afterCreateCol', parsedPath.col);
          }
          break;

        case 'remove':
          if(isNaN(parsedPath.col)){
            instance.runHooks('afterRemoveRow', parsedPath.row, 1);
          } else {
            instance.runHooks('afterRemoveCol', parsedPath.col, 1);
          }
          break;

        case 'replace':
          instance.runHooks('afterChange', [parsedPath.row, parsedPath.col, null, patch.value], 'external');
          break;
      }
    }

    function cleanPatches(rawPatches){
      var patches;

      patches = removeLengthRelatedPatches(rawPatches);
      patches = removeMultipleAddOrRemoveColPatches(patches);

      return patches;
    }

    /**
     * Removing or adding column will produce one patch for each table row.
     * This function leaves only one patch for each column add/remove operation
     */
    function removeMultipleAddOrRemoveColPatches(rawPatches){
      var newOrRemovedColumns = [];

      return rawPatches.filter(function(patch){
        var parsedPath = parsePath(patch.path);

        if(['add', 'remove'].indexOf(patch.op) != -1 && !isNaN(parsedPath.col)){
          if(newOrRemovedColumns.indexOf(parsedPath.col) != -1){
            return false;
          } else {
            newOrRemovedColumns.push(parsedPath.col);
          }
        }

        return true;
      });

    }

    /**
     * If observeChanges uses native Object.observe method, then it produces patches for length property.
     * This function removes them.
     */
    function removeLengthRelatedPatches(rawPatches){
      return rawPatches.filter(function(patch){
        return !/[/]length/ig.test(patch.path);
      })
    }

    function parsePath(path){
      var match = path.match(/^\/(\d+)\/?(.*)?$/);
      return {
        row: parseInt(match[1], 10),
        col: /^\d*$/.test(match[2]) ? parseInt(match[2], 10) : match[2]
      }
    }
  }

  function destroy(){
    var instance = this;

    if (instance.observer){
      destroyObserver.call(instance);
      unbindEvents.call(instance);
    }
  }

  function destroyObserver(){
    var instance = this;

    jsonpatch.unobserve(instance.observedData, instance.observer);
    delete instance.observeChangesActive;
    delete instance.pauseObservingChanges;
    delete instance.resumeObservingChanges;
  }

  function bindEvents(){
    var instance = this;
    instance.addHook('afterDestroy', destroy);

    instance.addHook('afterCreateRow', afterTableAlter);
    instance.addHook('afterRemoveRow', afterTableAlter);

    instance.addHook('afterCreateCol', afterTableAlter);
    instance.addHook('afterRemoveCol', afterTableAlter);

    instance.addHook('afterChange', function(changes, source){
      if(source != 'loadData'){
        afterTableAlter.call(this);
      }
    });
  }

  function unbindEvents(){
    var instance = this;
    instance.removeHook('afterDestroy', destroy);

    instance.removeHook('afterCreateRow', afterTableAlter);
    instance.removeHook('afterRemoveRow', afterTableAlter);

    instance.removeHook('afterCreateCol', afterTableAlter);
    instance.removeHook('afterRemoveCol', afterTableAlter);

    instance.removeHook('afterChange', afterTableAlter);
  }

  function afterTableAlter(){
    var instance = this;

    instance.pauseObservingChanges();

    instance.addHookOnce('afterChangesObserved', function(){
      instance.resumeObservingChanges();
    });

  }
})();


/*
 *
 * Plugin enables saving table state
 *
 * */


function Storage(prefix) {

  var savedKeys;

  var saveSavedKeys = function () {
    window.localStorage[prefix + '__' + 'persistentStateKeys'] = JSON.stringify(savedKeys);
  };

  var loadSavedKeys = function () {
    var keysJSON = window.localStorage[prefix + '__' + 'persistentStateKeys'];
    var keys = typeof keysJSON == 'string' ? JSON.parse(keysJSON) : void 0;
    savedKeys = keys ? keys : [];
  };

  var clearSavedKeys = function () {
    savedKeys = [];
    saveSavedKeys();
  };

  loadSavedKeys();

  this.saveValue = function (key, value) {
    window.localStorage[prefix + '_' + key] = JSON.stringify(value);
    if (savedKeys.indexOf(key) == -1) {
      savedKeys.push(key);
      saveSavedKeys();
    }

  };

  this.loadValue = function (key, defaultValue) {

    key = typeof key != 'undefined' ? key : defaultValue;

    var value = window.localStorage[prefix + '_' + key];

    return typeof value == "undefined" ? void 0 : JSON.parse(value);

  };

  this.reset = function (key) {
    window.localStorage.removeItem(prefix + '_' + key);
  };

  this.resetAll = function () {
    for (var index = 0; index < savedKeys.length; index++) {
      window.localStorage.removeItem(prefix + '_' + savedKeys[index]);
    }

    clearSavedKeys();
  };

}


(function (StorageClass) {
  function HandsontablePersistentState() {
    var plugin = this;


    this.init = function () {
      var instance = this,
        pluginSettings = instance.getSettings()['persistentState'];

      plugin.enabled = !!(pluginSettings);

      if (!plugin.enabled) {
        removeHooks.call(instance);
        return;
      }

      if (!instance.storage) {
        instance.storage = new StorageClass(instance.rootElement[0].id);
      }

      instance.resetState = plugin.resetValue;

      addHooks.call(instance);

    };

    this.saveValue = function (key, value) {
      var instance = this;

      instance.storage.saveValue(key, value);
    };

    this.loadValue = function (key, saveTo) {
      var instance = this;

      saveTo.value = instance.storage.loadValue(key);
    };

    this.resetValue = function (key) {
      var instance = this;

      if (typeof  key != 'undefined') {
        instance.storage.reset(key);
      } else {
        instance.storage.resetAll();
      }

    };

    var hooks = {
      'persistentStateSave': plugin.saveValue,
      'persistentStateLoad': plugin.loadValue,
      'persistentStateReset': plugin.resetValue
    };

    for (var hookName in hooks) {
      if (hooks.hasOwnProperty(hookName)) {
        Handsontable.hooks.register(hookName);
      }
    }

    function addHooks() {
      var instance = this;

      for (var hookName in hooks) {
        if (hooks.hasOwnProperty(hookName)) {
          instance.addHook(hookName, hooks[hookName]);
        }
      }
    }

    function removeHooks() {
      var instance = this;

      for (var hookName in hooks) {
        if (hooks.hasOwnProperty(hookName)) {
          instance.removeHook(hookName, hooks[hookName]);
        }
      }
    }
  }

  var htPersistentState = new HandsontablePersistentState();
  Handsontable.hooks.add('beforeInit', htPersistentState.init);
  Handsontable.hooks.add('afterUpdateSettings', htPersistentState.init);
})(Storage);

/**
 * Handsontable UndoRedo class
 */
(function(Handsontable){
  Handsontable.UndoRedo = function (instance) {
    var plugin = this;
    this.instance = instance;
    this.doneActions = [];
    this.undoneActions = [];
    this.ignoreNewActions = false;
    instance.addHook("afterChange", function (changes, origin) {
      if(changes){
        var action = new Handsontable.UndoRedo.ChangeAction(changes);
        plugin.done(action);
      }
    });

    instance.addHook("afterCreateRow", function (index, amount, createdAutomatically) {

      if (createdAutomatically) {
        return;
      }

      var action = new Handsontable.UndoRedo.CreateRowAction(index, amount);
      plugin.done(action);
    });

    instance.addHook("beforeRemoveRow", function (index, amount) {
      var originalData = plugin.instance.getData();
      index = ( originalData.length + index ) % originalData.length;
      var removedData = originalData.slice(index, index + amount);
      var action = new Handsontable.UndoRedo.RemoveRowAction(index, removedData);
      plugin.done(action);
    });

    instance.addHook("afterCreateCol", function (index, amount, createdAutomatically) {

      if (createdAutomatically) {
        return;
      }

      var action = new Handsontable.UndoRedo.CreateColumnAction(index, amount);
      plugin.done(action);
    });

    instance.addHook("beforeRemoveCol", function (index, amount) {
      var originalData = plugin.instance.getData();
      index = ( plugin.instance.countCols() + index ) % plugin.instance.countCols();
      var removedData = [];

      for (var i = 0, len = originalData.length; i < len; i++) {
        removedData[i] = originalData[i].slice(index, index + amount);
      }

      var headers;
      if(Handsontable.helper.isArray(instance.getSettings().colHeaders)){
        headers = instance.getSettings().colHeaders.slice(index, index + removedData.length);
      }

      var action = new Handsontable.UndoRedo.RemoveColumnAction(index, removedData, headers);
      plugin.done(action);
    });
  };

  Handsontable.UndoRedo.prototype.done = function (action) {
    if (!this.ignoreNewActions) {
      this.doneActions.push(action);
      this.undoneActions.length = 0;
    }
  };

  /**
   * Undo operation from current revision
   */
  Handsontable.UndoRedo.prototype.undo = function () {
    if (this.isUndoAvailable()) {
      var action = this.doneActions.pop();

      this.ignoreNewActions = true;
      var that = this;
      action.undo(this.instance, function () {
        that.ignoreNewActions = false;
        that.undoneActions.push(action);
      });



    }
  };

  /**
   * Redo operation from current revision
   */
  Handsontable.UndoRedo.prototype.redo = function () {
    if (this.isRedoAvailable()) {
      var action = this.undoneActions.pop();

      this.ignoreNewActions = true;
      var that = this;
      action.redo(this.instance, function () {
        that.ignoreNewActions = false;
        that.doneActions.push(action);
      });



    }
  };

  /**
   * Returns true if undo point is available
   * @return {Boolean}
   */
  Handsontable.UndoRedo.prototype.isUndoAvailable = function () {
    return this.doneActions.length > 0;
  };

  /**
   * Returns true if redo point is available
   * @return {Boolean}
   */
  Handsontable.UndoRedo.prototype.isRedoAvailable = function () {
    return this.undoneActions.length > 0;
  };

  /**
   * Clears undo history
   */
  Handsontable.UndoRedo.prototype.clear = function () {
    this.doneActions.length = 0;
    this.undoneActions.length = 0;
  };

  Handsontable.UndoRedo.Action = function () {
  };
  Handsontable.UndoRedo.Action.prototype.undo = function () {
  };
  Handsontable.UndoRedo.Action.prototype.redo = function () {
  };

  Handsontable.UndoRedo.ChangeAction = function (changes) {
    this.changes = changes;
  };
  Handsontable.helper.inherit(Handsontable.UndoRedo.ChangeAction, Handsontable.UndoRedo.Action);
  Handsontable.UndoRedo.ChangeAction.prototype.undo = function (instance, undoneCallback) {
    var data = $.extend(true, [], this.changes),
        emptyRowsAtTheEnd = instance.countEmptyRows(true),
        emptyColsAtTheEnd = instance.countEmptyCols(true);

    for (var i = 0, len = data.length; i < len; i++) {
      data[i].splice(3, 1);
    }

    instance.addHookOnce('afterChange', undoneCallback);

    instance.setDataAtRowProp(data, null, null, 'undo');

    for (var i = 0, len = data.length; i < len; i++) {
     if(instance.getSettings().minSpareRows &&
      data[i][0] + 1 + instance.getSettings().minSpareRows === instance.countRows()
      && emptyRowsAtTheEnd == instance.getSettings().minSpareRows) {
        instance.alter('remove_row', parseInt(data[i][0]+1,10), instance.getSettings().minSpareRows);

        instance.undoRedo.doneActions.pop();

      }

      if (instance.getSettings().minSpareCols &&
      data[i][1] + 1 + instance.getSettings().minSpareCols === instance.countCols()
      && emptyColsAtTheEnd == instance.getSettings().minSpareCols) {
        instance.alter('remove_col', parseInt(data[i][1]+1,10), instance.getSettings().minSpareCols);

        instance.undoRedo.doneActions.pop();
      }
    }

  };
  Handsontable.UndoRedo.ChangeAction.prototype.redo = function (instance, onFinishCallback) {
    var data = $.extend(true, [], this.changes);
    for (var i = 0, len = data.length; i < len; i++) {
      data[i].splice(2, 1);
    }

    instance.addHookOnce('afterChange', onFinishCallback);

    instance.setDataAtRowProp(data, null, null, 'redo');

  };

  Handsontable.UndoRedo.CreateRowAction = function (index, amount) {
    this.index = index;
    this.amount = amount;
  };
  Handsontable.helper.inherit(Handsontable.UndoRedo.CreateRowAction, Handsontable.UndoRedo.Action);
  Handsontable.UndoRedo.CreateRowAction.prototype.undo = function (instance, undoneCallback) {
    instance.addHookOnce('afterRemoveRow', undoneCallback);
    instance.alter('remove_row', this.index, this.amount);
  };
  Handsontable.UndoRedo.CreateRowAction.prototype.redo = function (instance, redoneCallback) {
    instance.addHookOnce('afterCreateRow', redoneCallback);
    instance.alter('insert_row', this.index + 1, this.amount);
  };

  Handsontable.UndoRedo.RemoveRowAction = function (index, data) {
    this.index = index;
    this.data = data;
  };
  Handsontable.helper.inherit(Handsontable.UndoRedo.RemoveRowAction, Handsontable.UndoRedo.Action);
  Handsontable.UndoRedo.RemoveRowAction.prototype.undo = function (instance, undoneCallback) {
    var spliceArgs = [this.index, 0];
    Array.prototype.push.apply(spliceArgs, this.data);

    Array.prototype.splice.apply(instance.getData(), spliceArgs);

    instance.addHookOnce('afterRender', undoneCallback);
    instance.render();
  };
  Handsontable.UndoRedo.RemoveRowAction.prototype.redo = function (instance, redoneCallback) {
    instance.addHookOnce('afterRemoveRow', redoneCallback);
    instance.alter('remove_row', this.index, this.data.length);
  };

  Handsontable.UndoRedo.CreateColumnAction = function (index, amount) {
    this.index = index;
    this.amount = amount;
  };
  Handsontable.helper.inherit(Handsontable.UndoRedo.CreateColumnAction, Handsontable.UndoRedo.Action);
  Handsontable.UndoRedo.CreateColumnAction.prototype.undo = function (instance, undoneCallback) {
    instance.addHookOnce('afterRemoveCol', undoneCallback);
    instance.alter('remove_col', this.index, this.amount);
  };
  Handsontable.UndoRedo.CreateColumnAction.prototype.redo = function (instance, redoneCallback) {
    instance.addHookOnce('afterCreateCol', redoneCallback);
    instance.alter('insert_col', this.index + 1, this.amount);
  };

  Handsontable.UndoRedo.RemoveColumnAction = function (index, data, headers) {
    this.index = index;
    this.data = data;
    this.amount = this.data[0].length;
    this.headers = headers;
  };
  Handsontable.helper.inherit(Handsontable.UndoRedo.RemoveColumnAction, Handsontable.UndoRedo.Action);
  Handsontable.UndoRedo.RemoveColumnAction.prototype.undo = function (instance, undoneCallback) {
    var row, spliceArgs;
    for (var i = 0, len = instance.getData().length; i < len; i++) {
      row = instance.getSourceDataAtRow(i);

      spliceArgs = [this.index, 0];
      Array.prototype.push.apply(spliceArgs, this.data[i]);

      Array.prototype.splice.apply(row, spliceArgs);

    }

    if(typeof this.headers != 'undefined'){
      spliceArgs = [this.index, 0];
      Array.prototype.push.apply(spliceArgs, this.headers);
      Array.prototype.splice.apply(instance.getSettings().colHeaders, spliceArgs);
    }

    instance.addHookOnce('afterRender', undoneCallback);
    instance.render();
  };
  Handsontable.UndoRedo.RemoveColumnAction.prototype.redo = function (instance, redoneCallback) {
    instance.addHookOnce('afterRemoveCol', redoneCallback);
    instance.alter('remove_col', this.index, this.amount);
  };
})(Handsontable);

(function(Handsontable){

  function init(){
    var instance = this;
    var pluginEnabled = typeof instance.getSettings().undo == 'undefined' || instance.getSettings().undo;

    if(pluginEnabled){
      if(!instance.undoRedo){
        instance.undoRedo = new Handsontable.UndoRedo(instance);

        exposeUndoRedoMethods(instance);

        instance.addHook('beforeKeyDown', onBeforeKeyDown);
        instance.addHook('afterChange', onAfterChange);
      }
    } else {
      if(instance.undoRedo){
        delete instance.undoRedo;

        removeExposedUndoRedoMethods(instance);

        instance.removeHook('beforeKeyDown', onBeforeKeyDown);
        instance.removeHook('afterChange', onAfterChange);
      }
    }
  }

  function onBeforeKeyDown(event){
    var instance = this;

    var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;

    if(ctrlDown){
      if (event.keyCode === 89 || (event.shiftKey && event.keyCode === 90)) { //CTRL + Y or CTRL + SHIFT + Z
        instance.undoRedo.redo();
        event.stopImmediatePropagation();
      }
      else if (event.keyCode === 90) { //CTRL + Z
        instance.undoRedo.undo();
        event.stopImmediatePropagation();
      }
    }
  }

  function onAfterChange(changes, source){
    var instance = this;
    if (source == 'loadData'){
      return instance.undoRedo.clear();
    }
  }

  function exposeUndoRedoMethods(instance){
    instance.undo = function(){
      return instance.undoRedo.undo();
    };

    instance.redo = function(){
      return instance.undoRedo.redo();
    };

    instance.isUndoAvailable = function(){
      return instance.undoRedo.isUndoAvailable();
    };

    instance.isRedoAvailable = function(){
      return instance.undoRedo.isRedoAvailable();
    };

    instance.clearUndo = function(){
      return instance.undoRedo.clear();
    };
  }

  function removeExposedUndoRedoMethods(instance){
    delete instance.undo;
    delete instance.redo;
    delete instance.isUndoAvailable;
    delete instance.isRedoAvailable;
    delete instance.clearUndo;
  }

  Handsontable.hooks.add('afterInit', init);
  Handsontable.hooks.add('afterUpdateSettings', init);

})(Handsontable);

/**
 * Plugin used to scroll Handsontable by selecting a cell and dragging outside of visible viewport
 * @constructor
 */
function DragToScroll() {
  this.boundaries = null;
  this.callback = null;
}

/**
 * @param boundaries {Object} compatible with getBoundingClientRect
 */
DragToScroll.prototype.setBoundaries = function (boundaries) {
  this.boundaries = boundaries;
};

/**
 * @param callback {Function}
 */
DragToScroll.prototype.setCallback = function (callback) {
  this.callback = callback;
};

/**
 * Check if mouse position (x, y) is outside of the viewport
 * @param x
 * @param y
 */
DragToScroll.prototype.check = function (x, y) {
  var diffX = 0;
  var diffY = 0;

  if (y < this.boundaries.top) {
    //y is less than top
    diffY = y - this.boundaries.top;
  }
  else if (y > this.boundaries.bottom) {
    //y is more than bottom
    diffY = y - this.boundaries.bottom;
  }

  if (x < this.boundaries.left) {
    //x is less than left
    diffX = x - this.boundaries.left;
  }
  else if (x > this.boundaries.right) {
    //x is more than right
    diffX = x - this.boundaries.right;
  }

  this.callback(diffX, diffY);
};

var dragToScroll;
var instance;

if (typeof Handsontable !== 'undefined') {
  var setupListening = function (instance) {
    instance.dragToScrollListening = false;
    var scrollHandler = instance.view.wt.wtScrollbars.vertical.scrollHandler; //native scroll
    dragToScroll = new DragToScroll();
    if (scrollHandler === window) {
      //not much we can do currently
      return;
    }
    else if (scrollHandler) {
      dragToScroll.setBoundaries(scrollHandler.getBoundingClientRect());
    }
    else {
      dragToScroll.setBoundaries(instance.$table[0].getBoundingClientRect());
    }

    dragToScroll.setCallback(function (scrollX, scrollY) {
      if (scrollX < 0) {
        if (scrollHandler) {
          scrollHandler.scrollLeft -= 50;
        }
        else {
          instance.view.wt.scrollHorizontal(-1).draw();
        }
      }
      else if (scrollX > 0) {
        if (scrollHandler) {
          scrollHandler.scrollLeft += 50;
        }
        else {
          instance.view.wt.scrollHorizontal(1).draw();
        }
      }

      if (scrollY < 0) {
        if (scrollHandler) {
          scrollHandler.scrollTop -= 20;
        }
        else {
          instance.view.wt.scrollVertical(-1).draw();
        }
      }
      else if (scrollY > 0) {
        if (scrollHandler) {
          scrollHandler.scrollTop += 20;
        }
        else {
          instance.view.wt.scrollVertical(1).draw();
        }
      }
    });

    instance.dragToScrollListening = true;
  };

  Handsontable.hooks.add('afterInit', function () {
    var instance = this;

    $(document).on('mouseup.' + this.guid, function () {
      instance.dragToScrollListening = false;
    });

    $(document).on('mousemove.' + this.guid, function (event) {
      if (instance.dragToScrollListening) {
        dragToScroll.check(event.clientX, event.clientY);
      }
    });
  });

  Handsontable.hooks.add('afterDestroy', function () {
    $(document).off('.' + this.guid);
  });

  Handsontable.hooks.add('afterOnCellMouseDown', function () {
    setupListening(this);
  });

  Handsontable.hooks.add('afterOnCellCornerMouseDown', function () {
    setupListening(this);
  });

  Handsontable.plugins.DragToScroll = DragToScroll;
}

(function (Handsontable, CopyPaste, SheetClip) {

  function CopyPastePlugin(instance) {
    this.copyPasteInstance = CopyPaste.getInstance();

    this.copyPasteInstance.onCut(onCut);
    this.copyPasteInstance.onPaste(onPaste);
    var plugin = this;

    instance.addHook('beforeKeyDown', onBeforeKeyDown);

    function onCut() {
      if (!instance.isListening()) {
        return;
      }

      instance.selection.empty();
    }

    function onPaste(str) {
      if (!instance.isListening() || !instance.selection.isSelected()) {
        return;
      }

      var input = str.replace(/^[\r\n]*/g, '').replace(/[\r\n]*$/g, '') //remove newline from the start and the end of the input
        , inputArray = SheetClip.parse(input)
        , selected = instance.getSelected()
        , coordsFrom = new WalkontableCellCoords(selected[0], selected[1])
        , coordsTo = new WalkontableCellCoords(selected[2], selected[3])
        , cellRange = new WalkontableCellRange(coordsFrom, coordsFrom, coordsTo)
        , topLeftCorner = cellRange.getTopLeftCorner()
        , bottomRightCorner = cellRange.getBottomRightCorner()
        , areaStart = topLeftCorner
        , areaEnd = new WalkontableCellCoords(
          Math.max(bottomRightCorner.row, inputArray.length - 1 + topLeftCorner.row),
          Math.max(bottomRightCorner.col, inputArray[0].length - 1 + topLeftCorner.col)
        );

      instance.addHookOnce('afterChange', function (changes, source) {
        if (changes && changes.length) {
          this.selectCell(areaStart.row, areaStart.col, areaEnd.row, areaEnd.col);
        }
      });

      instance.populateFromArray(areaStart.row, areaStart.col, inputArray, areaEnd.row, areaEnd.col, 'paste', instance.getSettings().pasteMode);
    };

    function onBeforeKeyDown (event) {
      if (Handsontable.helper.isCtrlKey(event.keyCode) && instance.getSelected()) {
        //when CTRL is pressed, prepare selectable text in textarea
        //http://stackoverflow.com/questions/3902635/how-does-one-capture-a-macs-command-key-via-javascript
        plugin.setCopyableText();
        event.stopImmediatePropagation();
        return;
      }

      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey; //catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)

      if (event.keyCode == Handsontable.helper.keyCode.A && ctrlDown) {
        setTimeout(Handsontable.helper.proxy(plugin.setCopyableText, plugin));
      }

    }

    this.destroy = function () {
      this.copyPasteInstance.removeCallback(onCut);
      this.copyPasteInstance.removeCallback(onPaste);
      this.copyPasteInstance.destroy();
      instance.removeHook('beforeKeyDown', onBeforeKeyDown);
    };

    instance.addHook('afterDestroy', Handsontable.helper.proxy(this.destroy, this));

    this.triggerPaste = Handsontable.helper.proxy(this.copyPasteInstance.triggerPaste, this.copyPasteInstance);
    this.triggerCut = Handsontable.helper.proxy(this.copyPasteInstance.triggerCut, this.copyPasteInstance);

    /**
     * Prepares copyable text in the invisible textarea
     */
    this.setCopyableText = function () {

      var settings = instance.getSettings();
      var copyRowsLimit = settings.copyRowsLimit;
      var copyColsLimit = settings.copyColsLimit;

      var selRange = instance.getSelectedRange();
      var topLeft = selRange.getTopLeftCorner();
      var bottomRight = selRange.getBottomRightCorner();
      var startRow = topLeft.row;
      var startCol = topLeft.col;
      var endRow = bottomRight.row;
      var endCol = bottomRight.col;
      var finalEndRow = Math.min(endRow, startRow + copyRowsLimit - 1);
      var finalEndCol = Math.min(endCol, startCol + copyColsLimit - 1);

      instance.copyPaste.copyPasteInstance.copyable(instance.getCopyableData(startRow, startCol, finalEndRow, finalEndCol));

      if (endRow !== finalEndRow || endCol !== finalEndCol) {
        Handsontable.hooks.run(instance, "afterCopyLimit", endRow - startRow + 1, endCol - startCol + 1, copyRowsLimit, copyColsLimit);
      }
    };

  }



  function init() {
    var instance  = this;
    var pluginEnabled = instance.getSettings().copyPaste !== false;

    if(pluginEnabled && !instance.copyPaste){

      instance.copyPaste = new CopyPastePlugin(instance);

    } else if (!pluginEnabled && instance.copyPaste) {

      instance.copyPaste.destroy();
      delete instance.copyPaste;

    }

  }

  Handsontable.hooks.add('afterInit', init);
  Handsontable.hooks.add('afterUpdateSettings', init);

  Handsontable.hooks.register('afterCopyLimit');
})(Handsontable, CopyPaste, SheetClip);
(function (Handsontable) {

  'use strict';

  Handsontable.Search = function Search(instance) {
    this.query = function (queryStr, callback, queryMethod) {
      var rowCount = instance.countRows();
      var colCount = instance.countCols();
      var queryResult = [];

      if (!callback) {
        callback = Handsontable.Search.global.getDefaultCallback();
      }

      if (!queryMethod) {
        queryMethod = Handsontable.Search.global.getDefaultQueryMethod();
      }

      for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
        for (var colIndex = 0; colIndex < colCount; colIndex++) {
          var cellData = instance.getDataAtCell(rowIndex, colIndex);
          var cellProperties = instance.getCellMeta(rowIndex, colIndex);
          var cellCallback = cellProperties.search.callback || callback;
          var cellQueryMethod = cellProperties.search.queryMethod || queryMethod;
          var testResult = cellQueryMethod(queryStr, cellData);

          if (testResult) {
            var singleResult = {
              row: rowIndex,
              col: colIndex,
              data: cellData
            };

            queryResult.push(singleResult);
          }

          if (cellCallback) {
            cellCallback(instance, rowIndex, colIndex, cellData, testResult);
          }
        }
      }

      return queryResult;

    };

  };

  Handsontable.Search.DEFAULT_CALLBACK = function (instance, row, col, data, testResult) {
    instance.getCellMeta(row, col).isSearchResult = testResult;
  };

  Handsontable.Search.DEFAULT_QUERY_METHOD = function (query, value) {

    if (typeof query == 'undefined' || query == null || !query.toLowerCase || query.length == 0){
      return false;
    }

    return value.toString().toLowerCase().indexOf(query.toLowerCase()) != -1;
  };

  Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS = 'htSearchResult';

  Handsontable.Search.global = (function () {

    var defaultCallback = Handsontable.Search.DEFAULT_CALLBACK;
    var defaultQueryMethod = Handsontable.Search.DEFAULT_QUERY_METHOD;
    var defaultSearchResultClass = Handsontable.Search.DEFAULT_SEARCH_RESULT_CLASS;

    return {
      getDefaultCallback: function () {
        return defaultCallback;
      },

      setDefaultCallback: function (newDefaultCallback) {
        defaultCallback = newDefaultCallback;
      },

      getDefaultQueryMethod: function () {
        return defaultQueryMethod;
      },

      setDefaultQueryMethod: function (newDefaultQueryMethod) {
        defaultQueryMethod = newDefaultQueryMethod;
      },

      getDefaultSearchResultClass: function () {
        return defaultSearchResultClass;
      },

      setDefaultSearchResultClass: function (newSearchResultClass) {
        defaultSearchResultClass = newSearchResultClass;
      }
    }

  })();



  Handsontable.SearchCellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {

    var searchResultClass = (typeof cellProperties.search == 'object' && cellProperties.search.searchResultClass) || Handsontable.Search.global.getDefaultSearchResultClass();

    if(cellProperties.isSearchResult){
      Handsontable.Dom.addClass(TD, searchResultClass);
    } else {
      Handsontable.Dom.removeClass(TD, searchResultClass);
    }
  };



  var originalDecorator = Handsontable.renderers.cellDecorator;

  Handsontable.renderers.cellDecorator = function (instance, TD, row, col, prop, value, cellProperties) {
    originalDecorator.apply(this, arguments);
    Handsontable.SearchCellDecorator.apply(this, arguments);
  };

  function init() {
    var instance = this;

    var pluginEnabled = !!instance.getSettings().search;

    if (pluginEnabled) {
      instance.search = new Handsontable.Search(instance);
    } else {
      delete instance.search;
    }

  }

  Handsontable.hooks.add('afterInit', init);
  Handsontable.hooks.add('afterUpdateSettings', init);


})(Handsontable);
function CellInfoCollection() {

  var collection = [];

  collection.getInfo = function (row, col) {
    for (var i = 0, ilen = this.length; i < ilen; i++) {
      if (this[i].row <= row && this[i].row + this[i].rowspan - 1 >= row && this[i].col <= col && this[i].col + this[i].colspan - 1 >= col) {
        return this[i];
      }
    }
  };

  collection.setInfo = function (info) {
    for (var i = 0, ilen = this.length; i < ilen; i++) {
      if (this[i].row === info.row && this[i].col === info.col) {
        this[i] = info;
        return;
      }
    }
    this.push(info);
  };

  collection.removeInfo = function (row, col) {
    for (var i = 0, ilen = this.length; i < ilen; i++) {
      if (this[i].row === row && this[i].col === col) {
        this.splice(i, 1);
        break;
      }
    }
  };

  return collection;

}


/**
 * Plugin used to merge cells in Handsontable
 * @constructor
 */
function MergeCells(mergeCellsSetting) {
  this.mergedCellInfoCollection = new CellInfoCollection();

  if (Handsontable.helper.isArray(mergeCellsSetting)) {
    for (var i = 0, ilen = mergeCellsSetting.length; i < ilen; i++) {
      this.mergedCellInfoCollection.setInfo(mergeCellsSetting[i]);
    }
  }
}

/**
 * @param cellRange (WalkontableCellRange)
 */
MergeCells.prototype.canMergeRange = function (cellRange) {
  //is more than one cell selected
  return !cellRange.isSingle();
};

MergeCells.prototype.mergeRange = function (cellRange) {
  if (!this.canMergeRange(cellRange)) {
    return;
  }

  //normalize top left corner
  var topLeft = cellRange.getTopLeftCorner();
  var bottomRight = cellRange.getBottomRightCorner();

  var mergeParent = {};
  mergeParent.row = topLeft.row;
  mergeParent.col = topLeft.col;
  mergeParent.rowspan = bottomRight.row - topLeft.row + 1; //TD has rowspan == 1 by default. rowspan == 2 means spread over 2 cells
  mergeParent.colspan = bottomRight.col - topLeft.col + 1;
  this.mergedCellInfoCollection.setInfo(mergeParent);
};

MergeCells.prototype.mergeOrUnmergeSelection = function (cellRange) {
  var info = this.mergedCellInfoCollection.getInfo(cellRange.from.row, cellRange.from.col);
  if (info) {
    //unmerge
    this.unmergeSelection(cellRange.from);
  }
  else {
    //merge
    this.mergeSelection(cellRange);
  }
};

MergeCells.prototype.mergeSelection = function (cellRange) {
  this.mergeRange(cellRange);
};

MergeCells.prototype.unmergeSelection = function (cellRange) {
  var info = this.mergedCellInfoCollection.getInfo(cellRange.row, cellRange.col);
  this.mergedCellInfoCollection.removeInfo(info.row, info.col);
};

MergeCells.prototype.applySpanProperties = function (TD, row, col) {
  var info = this.mergedCellInfoCollection.getInfo(row, col);
  if (info) {
    if (info.row === row && info.col === col) {
      TD.setAttribute('rowspan', info.rowspan);
      TD.setAttribute('colspan', info.colspan);
    }
    else {
      TD.style.display = "none";
    }
  }
  else {
    TD.removeAttribute('rowspan');
    TD.removeAttribute('colspan');
  }
};

MergeCells.prototype.modifyTransform = function (hook, currentSelectedRange, delta) {
  var current;
  switch (hook) {
    case 'modifyTransformStart':
      current = currentSelectedRange.highlight;
      break;

    case 'modifyTransformEnd':
      current = currentSelectedRange.to;
      break;
  }

  if (hook == "modifyTransformStart") {
    //in future - can this take the logic from modifyTransformEnd?
    var mergeParent = this.mergedCellInfoCollection.getInfo(current.row + delta.row, current.col + delta.col);
    if (mergeParent) {
      if (current.row > mergeParent.row) { //entering merge by going up or left
        this.lastDesiredCoords = new WalkontableCellCoords(current.row + delta.row, current.col + delta.col); //copy
        delta.row += (mergeParent.row - current.row) - delta.row;
      }
      else if (current.row == mergeParent.row && delta.row > 0) { //leaving merge by going down
        delta.row += mergeParent.row - current.row + mergeParent.rowspan - 1;
      }
      else { //leaving merge by going right
        if (this.lastDesiredCoords && delta.row === 0) {
          delta.row += this.lastDesiredCoords.row - current.row;
          this.lastDesiredCoords = null;
        }
      }

      if (current.col > mergeParent.col) { //entering merge by going up or left
        if (!this.lastDesiredCoords) {
          this.lastDesiredCoords = new WalkontableCellCoords(current.row + delta.row, current.col + delta.col); //copy
        }
        delta.col += (mergeParent.col - current.col) - delta.col;
      }
      else if (current.col == mergeParent.col && delta.col > 0) { //leaving merge by going right
        delta.col += mergeParent.col - current.col + mergeParent.colspan - 1;
      }
      else { //leaving merge by going down
        if (this.lastDesiredCoords && delta.col === 0) {
          delta.col += this.lastDesiredCoords.col - current.col;
          this.lastDesiredCoords = null;
        }
      }
    }
    else {
      if (this.lastDesiredCoords) {
        if (delta.col == 0) { //leaving merge by going up
          delta.col += this.lastDesiredCoords.col - current.col;
        }
        else if (delta.row == 0) { //leaving merge by going left
          delta.row += this.lastDesiredCoords.row - current.row;
        }
        this.lastDesiredCoords = null;
      }
    }
  }
  else {
    //modify transform end
    var hightlightMergeParent = this.mergedCellInfoCollection.getInfo(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col);
    if (hightlightMergeParent) {
      if (currentSelectedRange.isSingle()) {
        currentSelectedRange.from = new WalkontableCellCoords(hightlightMergeParent.row, hightlightMergeParent.col);
        currentSelectedRange.to = new WalkontableCellCoords(hightlightMergeParent.row + hightlightMergeParent.rowspan - 1, hightlightMergeParent.col + hightlightMergeParent.colspan - 1);
      }
    }

    if (currentSelectedRange.isSingle()) {
      //make sure objects are clones but not reference to the same instance
      //because we will mutate them
      currentSelectedRange.from = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col);
      currentSelectedRange.to = new WalkontableCellCoords(currentSelectedRange.highlight.row, currentSelectedRange.highlight.col);
    }

    var solveDimension = function (dim) {
      var altDim = dim == "col" ? "row" : "col";

      function changeCoords(obj, altDimValue, dimValue) {
        obj[altDim] = altDimValue;
        obj[dim] = dimValue;
      }

      if (delta[dim] != 0) {
        var topLeft;
        var bottomRight;

        var updateCornerInfo = function () {
          topLeft = currentSelectedRange.getTopLeftCorner();
          bottomRight = currentSelectedRange.getBottomRightCorner();
        }
        updateCornerInfo();

        var expanding = false; //expanding false means shrinking
        var examinedCol;
        //now check if maybe we are expanding?
        if (delta[dim] < 0) {
          examinedCol = bottomRight[dim] + delta[dim];
          if (bottomRight[dim] == currentSelectedRange.highlight[dim]) {
            examinedCol = topLeft[dim] + delta[dim];
            expanding = true;
          }
          else {
            for (var i = topLeft[altDim]; i <= bottomRight[altDim]; i++) {
              var mergeParent = this.mergedCellInfoCollection.getInfo(i, bottomRight[dim]);
              if (mergeParent) {
                if (mergeParent[dim] <= currentSelectedRange.highlight[dim]) {
                  examinedCol = topLeft[dim] + delta[dim];
                  expanding = true;
                  break;
                }
              }
            }
          }
        }
        else if (delta[dim] > 0) {
          examinedCol = topLeft[dim] + delta[dim];
          if (topLeft[dim] == currentSelectedRange.highlight[dim]) {
            examinedCol = bottomRight[dim] + delta[dim];
            expanding = true;
          }
          else {
            for (var i = topLeft[altDim]; i <= bottomRight[altDim]; i++) {
              var mergeParent = this.mergedCellInfoCollection.getInfo(i, topLeft[dim]);
              if (mergeParent) {
                if (mergeParent[dim] + mergeParent[dim + "span"] > currentSelectedRange.highlight[dim]) {
                  examinedCol = bottomRight[dim] + delta[dim];
                  expanding = true;
                  break;
                }
              }
            }
          }
        }

        if (expanding) {
          if (delta[dim] > 0) { //moving East wall further East
            changeCoords(currentSelectedRange.from, topLeft[altDim], topLeft[dim]);
            changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.max(bottomRight[dim], examinedCol));
            updateCornerInfo();
          }
          else { //moving West wall further West
            changeCoords(currentSelectedRange.from, topLeft[altDim], Math.min(topLeft[dim], examinedCol));
            changeCoords(currentSelectedRange.to, bottomRight[altDim], bottomRight[dim]);
            updateCornerInfo();
          }

        }
        else {
          if (delta[dim] > 0) { //shrinking West wall towards East
            changeCoords(currentSelectedRange.from, topLeft[altDim], Math.max(topLeft[dim], examinedCol));
            changeCoords(currentSelectedRange.to, bottomRight[altDim], bottomRight[dim]);
            updateCornerInfo();
          }
          else { //shrinking East wall towards West
            changeCoords(currentSelectedRange.from, topLeft[altDim], topLeft[dim]);
            changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.min(bottomRight[dim], examinedCol));
            updateCornerInfo();
          }
        }

        for (var i = topLeft[altDim]; i <= bottomRight[altDim]; i++) {
          var mergeParent = dim == "col" ? this.mergedCellInfoCollection.getInfo(i, examinedCol) : this.mergedCellInfoCollection.getInfo(examinedCol, i);
          if (mergeParent) {
            if (expanding) {
              if (delta[dim] > 0) { //moving East wall further East
                changeCoords(currentSelectedRange.from, Math.min(topLeft[altDim], mergeParent[altDim]), Math.min(topLeft[dim], mergeParent[dim]));
                if (examinedCol > mergeParent[dim]) {
                  changeCoords(currentSelectedRange.to, Math.max(bottomRight[altDim], mergeParent[altDim] + mergeParent[altDim + "span"] - 1), Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                }
                else {
                  changeCoords(currentSelectedRange.to, Math.max(bottomRight[altDim], mergeParent[altDim] + mergeParent[altDim + "span"] - 1), Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"] - 1));
                }
                updateCornerInfo();
              }
              else { //moving West wall further West
                changeCoords(currentSelectedRange.from, Math.min(topLeft[altDim], mergeParent[altDim]), Math.min(topLeft[dim], mergeParent[dim]));
                changeCoords(currentSelectedRange.to, Math.max(bottomRight[altDim], mergeParent[altDim] + mergeParent[altDim + "span"] - 1), Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"] - 1));
                updateCornerInfo();
              }
            }
            else {
              if (delta[dim] > 0) { //shrinking West wall towards East
                if (examinedCol > mergeParent[dim]) {
                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.max(topLeft[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                }
                else {
                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.max(topLeft[dim], mergeParent[dim]));
                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.max(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"] - 1));
                }
                updateCornerInfo();
              }
              else { //shrinking East wall towards West
                if (examinedCol < mergeParent[dim] + mergeParent[dim + "span"] - 1) {
                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.min(topLeft[dim], mergeParent[dim] - 1));
                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.min(bottomRight[dim], mergeParent[dim] - 1));
                }
                else {
                  changeCoords(currentSelectedRange.from, topLeft[altDim], Math.min(topLeft[dim], mergeParent[dim]));
                  changeCoords(currentSelectedRange.to, bottomRight[altDim], Math.min(bottomRight[dim], mergeParent[dim] + mergeParent[dim + "span"]));
                }
                updateCornerInfo();
              }
            }
          }
        }

        /*if (expanding) {
         //check if corners are not part of merged cells as well
         var oneLastCheck = function (row, col) {
         var mergeParent = this.mergedCellInfoCollection.getInfo(row, col);
         if (mergeParent) {
         currentSelectedRange.expand(new WalkontableCellCoords(mergeParent.row, mergeParent.col));
         currentSelectedRange.expand(new WalkontableCellCoords(mergeParent.row + mergeParent.rowspan - 1, mergeParent.col + mergeParent.colspan - 1));
         updateCornerInfo();
         }
         }
         oneLastCheck.call(this, topLeft.row, topLeft.col);
         oneLastCheck.call(this, topLeft.row, bottomRight.col);
         oneLastCheck.call(this, bottomRight.row, bottomRight.col);
         oneLastCheck.call(this, bottomRight.row, topLeft.col);
         }
         else {
         //TODO there is still a glitch if you go to merge_cells.html, go to D5 and press up, right, down
         }*/
      }
    };

    solveDimension.call(this, "col");
    solveDimension.call(this, "row");

    delta.row = 0;
    delta.col = 0;
  }
};

if (typeof Handsontable == 'undefined') {
  throw new Error('Handsontable is not defined');
}

var init = function () {
  var instance = this;
  var mergeCellsSetting = instance.getSettings().mergeCells;

  if (mergeCellsSetting) {
    if (!instance.mergeCells) {
      instance.mergeCells = new MergeCells(mergeCellsSetting);
    }
  }
};

var onBeforeKeyDown = function (event) {
  if (!this.mergeCells) {
    return;
  }

  var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;

  if (ctrlDown) {
    if (event.keyCode === 77) { //CTRL + M
      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
      this.render();
      event.stopImmediatePropagation();
    }
  }
};

var addMergeActionsToContextMenu = function (defaultOptions) {
  if (!this.getSettings().mergeCells) {
    return;
  }

  defaultOptions.items.mergeCellsSeparator = Handsontable.ContextMenu.SEPARATOR;

  defaultOptions.items.mergeCells = {
    name: function () {
      var sel = this.getSelected();
      var info = this.mergeCells.mergedCellInfoCollection.getInfo(sel[0], sel[1]);
      if (info) {
        return 'Unmerge cells';
      }
      else {
        return 'Merge cells';
      }
    },
    callback: function () {
      this.mergeCells.mergeOrUnmergeSelection(this.getSelectedRange());
      this.render();
    },
    disabled: function () {
      return false;
    }
  };
};

var afterRenderer = function (TD, row, col, prop, value, cellProperties) {
  if (this.mergeCells) {
    this.mergeCells.applySpanProperties(TD, row, col);
  }
};

var modifyTransformFactory = function (hook) {
  return function (delta) {
    var mergeCellsSetting = this.getSettings().mergeCells;
    if (mergeCellsSetting) {
      var currentSelectedRange = this.getSelectedRange();
      this.mergeCells.modifyTransform(hook, currentSelectedRange, delta);

      if (hook === "modifyTransformEnd") {
        //sanitize "from" (core.js will sanitize to)
        var totalRows = this.countRows();
        var totalCols = this.countCols();
        if (currentSelectedRange.from.row < 0) {
          currentSelectedRange.from.row = 0;
        }
        else if (currentSelectedRange.from.row > 0 && currentSelectedRange.from.row >= totalRows) {
          currentSelectedRange.from.row = currentSelectedRange.from - 1;
        }

        if (currentSelectedRange.from.col < 0) {
          currentSelectedRange.from.col = 0;
        }
        else if (currentSelectedRange.from.col > 0 && currentSelectedRange.from.col >= totalCols) {
          currentSelectedRange.from.col = totalCols - 1;
        }
      }
    }
  }
};

/**
 * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell
 * @param coords
 */
var beforeSetRangeEnd = function (coords) {
  this.lastDesiredCoords = null; //unset lastDesiredCoords when selection is changed with mouse
  var mergeCellsSetting = this.getSettings().mergeCells;
  if (mergeCellsSetting) {
    var selRange = this.getSelectedRange();
    selRange.highlight = new WalkontableCellCoords(selRange.highlight.row, selRange.highlight.col); //clone in case we will modify its reference
    selRange.to = coords;

    for (var i = 0, ilen = this.mergeCells.mergedCellInfoCollection.length; i < ilen; i++) {
      var cellInfo = this.mergeCells.mergedCellInfoCollection[i];
      var mergedCellTopLeft = new WalkontableCellCoords(cellInfo.row, cellInfo.col);
      var mergedCellBottomRight = new WalkontableCellCoords(cellInfo.row + cellInfo.rowspan - 1, cellInfo.col + cellInfo.colspan - 1);

      var mergedCellRange = new WalkontableCellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);
      if (selRange.expandByRange(mergedCellRange)) {
        var selRangeBottomRight = selRange.getBottomRightCorner();
        coords.row = selRangeBottomRight.row;
        coords.col = selRangeBottomRight.col;
      }
    }
  }
};

var afterGetCellMeta = function(row, col, cellProperties) {
  var mergeCellsSetting = this.getSettings().mergeCells;
  if (mergeCellsSetting) {
    var mergeParent = this.mergeCells.mergedCellInfoCollection.getInfo(row, col);
    if(mergeParent && (mergeParent.row != row || mergeParent.col != col)) {
      cellProperties.copyable = false;
    }
  }
};

Handsontable.hooks.add('beforeInit', init);
Handsontable.hooks.add('beforeKeyDown', onBeforeKeyDown);
Handsontable.hooks.add('modifyTransformStart', modifyTransformFactory('modifyTransformStart'));
Handsontable.hooks.add('modifyTransformEnd', modifyTransformFactory('modifyTransformEnd'));
Handsontable.hooks.add('beforeSetRangeEnd', beforeSetRangeEnd);
Handsontable.hooks.add('afterRenderer', afterRenderer);
Handsontable.hooks.add('afterContextMenuDefaultOptions', addMergeActionsToContextMenu);
Handsontable.hooks.add('afterGetCellMeta', afterGetCellMeta);

Handsontable.MergeCells = MergeCells;


(function () {

  function CustomBorders () {}

  /***
   * Array for all custom border objects (for redraw)
   * @type {{}}
   */
  var bordersArray = {},
    /***
     * Flag for prevent redraw borders after each AfterRender hook
     * @type {boolean}
     */
    doDraw = false;


  var init = function () {
    var customBorders = this.getSettings().customBorders;
    var enable = false;

    if(typeof customBorders === "boolean"){
      if (customBorders == true){
        enable = true;
      }
    }

    if(typeof customBorders === "object"){
      if(customBorders.length > 0) {
        for(var i = 0; i< customBorders.length; i++) {
          if(customBorders[i].range){
            prepareBorderFromCustomAddedRange(customBorders[i]);
          } else {
            prepareBorderFromCustomAdded(customBorders[i].row, customBorders[i].col, customBorders[i]);
          }
        }
        doDraw = true;
      }
    }

    if(enable){
      if(!this.customBorders){
        this.customBorders = new CustomBorders();
      }
    }
  };

  var prepareBorderFromCustomAdded = function (row, col, borderObj){
    var border = createEmptyBorders(row, col);
    border = extendDefaultBorder(border, borderObj);
    //this.setCellMeta(row, col, 'borders', border);
    insertBorderToArray(border);
  };

  var prepareBorderFromCustomAddedRange = function (rowObj) {
    var range = rowObj.range;

    for (var row = range.from.row; row <= range.to.row; row ++) {
      for (var col = range.from.col; col<= range.to.col; col++){

        var border = createEmptyBorders(row, col);
        var add = 0;

        if(row == range.from.row) {
          add++;
          if(rowObj.hasOwnProperty('top')){
            border.top = rowObj.top;
          }
        }

        if(row == range.to.row){
          add++;
          if(rowObj.hasOwnProperty('bottom')){
            border.bottom = rowObj.bottom;
          }
        }

        if(col == range.from.col) {
          add++;
          if(rowObj.hasOwnProperty('left')){
            border.left = rowObj.left;
          }
        }


        if (col == range.to.col) {
          add++;
          if(rowObj.hasOwnProperty('right')){
            border.right = rowObj.right;
          }
        }


        if(add>0){
//          this.setCellMeta(row, col, 'borders', border);
          insertBorderToArray(border);
        }
      }
    }
  };

  /***
   * Create separated class name for borders for each cell
   * @param row
   * @param col
   * @returns {string}
   */
  var createClassName = function (row, col) {
    return "border_row" + row + "col" + col;
  };


  /***
   * Create default single border for each position (top/right/bottom/left)
   * @returns {{width: number, color: string}}
   */
  var createDefaultCustomBorder = function () {
    return {
      width: 1,
      color: '#000'
    };
  };

  /***
   * Create default Handsontable border object
   * @returns {{width: number, color: string, cornerVisible: boolean}}
   */
  var createDefaultHtBorder = function () {
    return {
      width: 1,
      color: '#000',
      cornerVisible: false
    }
  };

  /***
   * Prepare empty border for each cell with all custom borders hidden
   *
   * @param row
   * @param col
   * @returns {{className: *, border: *, row: *, col: *, top: {hide: boolean}, right: {hide: boolean}, bottom: {hide: boolean}, left: {hide: boolean}}}
   */
  var createEmptyBorders = function (row, col){
    return {
      className: createClassName(row, col),
      border: createDefaultHtBorder(),
      row: row,
      col: col,
      top:{
        hide:true
      },
      right:{
        hide:true
      },
      bottom:{
        hide:true
      },
      left:{
        hide:true
      }
    }
  };


  var extendDefaultBorder = function (defaultBorder, customBorder){

    if(customBorder.hasOwnProperty('border')){
      defaultBorder.border = customBorder.border;
    }

    if(customBorder.hasOwnProperty('top')){
      defaultBorder.top = customBorder.top;
    }

    if(customBorder.hasOwnProperty('right')){
      defaultBorder.right = customBorder.right;
    }

    if(customBorder.hasOwnProperty('bottom')){
      defaultBorder.bottom = customBorder.bottom;
    }

    if(customBorder.hasOwnProperty('left')){
      defaultBorder.left = customBorder.left;
    }
    return defaultBorder;
  };

  /***
   * Insert object with borders for each cell to bordersArray
   *
   * @param bordersObj
   */
  var insertBorderToArray = function (bordersObj) {
    bordersArray[bordersObj.className] = bordersObj;
  };

  /***
   * Clean bordersArray for cell when custom border has been removed
   *
   * @param className
   */
  var removeBorderFromArray = function (className) {
    delete bordersArray[className];
  };


  /***
   * Remove borders divs from DOM
   *
   * @param borderClassName
   */
  var removeBordersFromDom = function (borderClassName) {
    var borders = document.getElementsByClassName(borderClassName)[0];

    if(borders){
      var parent = borders.parentNode;
      parent.parentNode.removeChild(parent);
    }

  };


  /***
   * Remove border (triggered from context menu)
   *
   * @param row
   * @param col
   */
  var removeBorder = function(row,col) {
    var borderClassName = createClassName(row,col);
    removeBordersFromDom(borderClassName);
    removeBorderFromArray(borderClassName);

    this.removeCellMeta(row, col, 'borders');
  };


  /***
   * Draw borders for single cell
   *
   * @param borderObj
   */
  var drawBorders = function (borderObj) {
    var bordersInDOM = document.getElementsByClassName(createClassName(borderObj.row,borderObj.col)),
      bordersExist = bordersInDOM.length > 0;

    if(bordersExist){
      removeBordersFromDom(createClassName(borderObj.row,borderObj.col));
    }

    var border = new WalkontableBorder(this.view.wt,borderObj);
    border.appear([borderObj.row,borderObj.col,borderObj.row,borderObj.col]);
  };


  /***
   * Set borders for each cell re. to border position
   *
   * @param row
   * @param col
   * @param place
   */
  var setBorder = function (row, col,place){
    var bordersMeta = this.getCellMeta(row, col).borders;
    if (!bordersMeta || bordersMeta.border == undefined){
      bordersMeta = createEmptyBorders(row, col);
    }
    bordersMeta[place] = createDefaultCustomBorder();
    this.setCellMeta(row, col, 'borders', bordersMeta);
    insertBorderToArray(bordersMeta);
    doDraw = true;
    this.render();
  };


  /***
   * Prepare borders based on cell and border position
   *
   * @param range
   * @param place
   */
  var prepareBorder = function (range, place) {
    if (range.from.row == range.to.row && range.from.col == range.to.col){
      if(place == "noBorders"){
        removeBorder.call(this, range.from.row, range.from.col);
      } else {
        setBorder.call(this, range.from.row, range.from.col, place);
      }
    } else {
      switch (place) {
        case "noBorders":
          for(var column = range.from.col; column <= range.to.col; column++){
            for(var row = range.from.row; row <= range.to.row; row++) {
              removeBorder.call(this, row, column);
            }
          }
          break;
        case "top":
          for(var topCol = range.from.col; topCol <= range.to.col; topCol++){
            setBorder.call(this, range.from.row, topCol, place);
          }
          break;
        case "right":
          for(var rowRight = range.from.row; rowRight <=range.to.row; rowRight++){
            setBorder.call(this,rowRight, range.to.col, place);
          }
          break;
        case "bottom":
          for(var bottomCol = range.from.col; bottomCol <= range.to.col; bottomCol++){
            setBorder.call(this, range.to.row, bottomCol, place);
          }
          break;
        case "left":
          for(var rowLeft = range.from.row; rowLeft <=range.to.row; rowLeft++){
            setBorder.call(this,rowLeft, range.from.col, place);
          }
          break;
      }
    }
  };


  /***
   * Add border options to context menu
   *
   * @param defaultOptions
   */
  var addBordersOptionsToContextMenu = function (defaultOptions) {
    if(!this.getSettings().customBorders){
      return;
    }

    defaultOptions.items.bordersCellsSeparator = Handsontable.ContextMenu.SEPARATOR;
    defaultOptions.items.borders = {
      name: function () {
        var div = document.createElement('div'),
          button = document.createElement('button'),
          xButton = button.cloneNode(true),
          tButton = button.cloneNode(true),
          lButton = button.cloneNode(true),
          bButton = button.cloneNode(true),
          rButton = button.cloneNode(true),

          xText = document.createTextNode('X'),
          tText = document.createTextNode('top'),
          rText = document.createTextNode('right'),
          bText = document.createTextNode('bottom'),
          lText = document.createTextNode('left');

        xButton.appendChild(xText);
        tButton.appendChild(tText);
        rButton.appendChild(rText);
        bButton.appendChild(bText);
        lButton.appendChild(lText);

        Handsontable.Dom.addClass(xButton,'noBorders');
        Handsontable.Dom.addClass(tButton,'top');
        Handsontable.Dom.addClass(rButton,'right');
        Handsontable.Dom.addClass(bButton,'bottom');
        Handsontable.Dom.addClass(lButton,'left');

        div.appendChild(xButton);
        div.appendChild(tButton);
        div.appendChild(rButton);
        div.appendChild(bButton);
        div.appendChild(lButton);

        return div.outerHTML;
      },
      callback:function(key, selection ,event){
        var className = event.target.className,
          type = event.target.tagName;
        if (type === "BUTTON") {
          if(className) {
            prepareBorder.call(this, this.getSelectedRange(), className);
          }
        }
      },
      disabled:function () {
        return false;
      }
    };
  };


  Handsontable.hooks.add('beforeInit', init);
  Handsontable.hooks.add('afterContextMenuDefaultOptions', addBordersOptionsToContextMenu);
  Handsontable.hooks.add('afterRender', function () {
    if(doDraw){
      for (var key in bordersArray) {
        if (bordersArray.hasOwnProperty(key)) {
          drawBorders.call(this,bordersArray[key])
        }
      }
    }
  });
  Handsontable.CustomBorders = CustomBorders;

}());

(function (Handsontable) {
  function HandsontableManualRowMove() {

    var pressed,
        startRow,
        endRow,
        startY,
        startOffest,
        moveHandle,
        startOffset,
        scrollTop = 0,
        scrollLeft = 0,
        currentRow;

    var ghost = document.createElement('DIV'),
        ghostStyle = ghost.style;

    ghost.className = 'ghost';
    ghostStyle.position = 'absolute';
    ghostStyle.top = '25px';
    ghostStyle.left = '50px';
    ghostStyle.width = '10px';
    ghostStyle.height = '10px';
    ghostStyle.backgroundColor = '#CCC';
    ghostStyle.opacity = 0.7;

    moveHandle = document.createElement('DIV');
    moveHandle.className = 'manualRowMover';

    var saveManualRowPostions = function () {
      var instance = this;
      Handsontable.hooks.run(instance, 'persistentStateSave', 'manualRowPositions', instance.manualRowPositions);
    };

    var loadManualRowPositions = function () {
      var instance = this,
          storedState = {};

      Handsontable.hooks.run(instance, 'persistentStateLoad', 'manualRowPositions', storedState);

      return storedState.value;
    };

    var refreshMoverPosition = function(TH) {
      var row = this.view.wt.wtTable.getCoords(TH).row; //getCoords returns WalkontableCellCoords

      if (row >= 0) { //if not row header
        currentRow = row;

        var rootOffset = Handsontable.Dom.offset(this.rootElement[0]).top;
        var thOffset = Handsontable.Dom.offset(TH).top;
        startOffset = (thOffset - rootOffset) + scrollTop;
        //moveHandle.style.top = startOffset + parseInt(Handsontable.Dom.outerHeight(TH), 10) + 'px';
        moveHandle.style.top = startOffset + 'px';
        moveHandle.style.left = scrollLeft + 'px';
      }
    }

    var bindMoveRowEvents = function () {
      var instance = this;

      instance.rootElement.on('mousemove.manualRowMove', function (e) {
        if (pressed) {
          var top = startOffest + e.pageY - startY + 'px';
          ghostStyle.top = top;
          if (ghostStyle.display === 'none') {
            ghostStyle.display = 'block';
          }
        }
      });

      instance.rootElement.on('mouseup.manualRowMove', function () {
        if (pressed) {
          if (startRow < endRow) {
            endRow--;
          }

          if (instance.getSettings().colHeaders) {
            startRow--;
            endRow--;
          }

          instance.manualRowPositions.splice(endRow, 0, instance.manualRowPositions.splice(startRow, 1)[0]);

          var mover = instance.rootElement[0].querySelector('.manualRowMover.active');
          if (mover) {
            Handsontable.Dom.removeClass(mover, 'active');
          }

          pressed = false;
          instance.forceFullRender = true;
          instance.view.render();
          ghostStyle.display = 'none';

          saveManualRowPostions.call(instance);

          Handsontable.hooks.run(instance, 'afterRowMove', startRow, endRow);
        }
      });

      instance.rootElement.on('mousedown.manualRowMove', '.manualRowMover', function (e) {
        var rowOffset = instance.rowOffset(),
            TH = instance.view.TBODY.querySelectorAll('TH')[currentRow - rowOffset],
            TR = TH.parentNode;

        startRow = parseInt(Handsontable.Dom.index(TR), 10) + 1 + rowOffset;
        endRow = startRow;
        pressed = true;
        startY = e.pageY;

        var TABLE = instance.$table[0];
        TABLE.parentNode.appendChild(ghost);
        ghostStyle.width = Handsontable.Dom.outerWidth(TABLE) + 'px';
        ghostStyle.height = Handsontable.Dom.outerHeight(TH) + 'px';
        startOffest = parseInt(Handsontable.Dom.offset(TH).top - Handsontable.Dom.offset(TABLE).top, 10);

        ghostStyle.top = startOffest + 'px';
        ghostStyle.display = 'none';

      });

      instance.rootElement.on('mouseenter.manualRowMove', 'table tbody th, table tbody td', function (e) {

        if (pressed) {
          var currentTarget = e.currentTarget,
              TR = currentTarget.parentNode,
              rowOffset = instance.rowOffset();

          currentRow = parseInt(Handsontable.Dom.index(TR), 10) + 1 + rowOffset;
          endRow = currentRow;

          var mover = instance.rootElement[0].querySelector('.manualRowMover');
          Handsontable.Dom.addClass(mover, 'active');
        }

        refreshMoverPosition.apply(instance, [e.currentTarget]);
      });

      instance.addHook('afterDestroy', unbindMoveRowEvents);
    };

    var unbindMoveRowEvents = function () {
      var instance = this;
      instance.rootElement.off('mouseup.manualRowMove');
      instance.rootElement.off('mousemove.manualRowMove');
      instance.rootElement.off('mousedown.manualRowMove');
      instance.rootElement.off('mouseenter.manualRowMove');
    };

    this.beforeInit = function () {
      this.manualRowPositions = [];
    };

    this.init = function (source) {
      var instance = this;

      var manualRowMoveEnabled = !!(instance.getSettings().manualRowMove);

      if (manualRowMoveEnabled) {
        var initialManualRowPositions = instance.getSettings().manualRowMove;

        var loadedManualRowPostions = loadManualRowPositions.call(instance);

        if (typeof loadedManualRowPostions != 'undefined') {
          this.manualRowPositions = loadedManualRowPostions;
        } else if(initialManualRowPositions instanceof Array) {
          this.manualRowPositions = initialManualRowPositions;
        } else {
          this.manualRowPositions = [];
        }

        instance.forceFullRender = true;

        if (source === 'afterInit') {
          bindMoveRowEvents.call(this);

          if (this.manualRowPositions.length > 0) {
            instance.forceFullRender = true;
            instance.render();
          }

          Handsontable.hooks.add('afterScrollVertically', afterScrollVertically);
          Handsontable.hooks.add('afterScrollHorizontally', afterScrollHorizontally);

          this.rootElement[0].appendChild(moveHandle);
        }
      } else {
        unbindMoveRowEvents.call(this);
        instance.manualRowPositions = [];
      }

    };

    var afterScrollVertically = function () {
      scrollTop = Handsontable.Dom.getScrollTop(this.rootElement[0]);
    };

    var afterScrollHorizontally = function () {
      scrollLeft = Handsontable.Dom.getScrollLeft(this.rootElement[0]);
    }

    this.modifyRow = function (row) {
      var instance = this;
      if (instance.getSettings().manualRowMove) {
        if (typeof instance.manualRowPositions[row] === 'undefined') {
          instance.manualRowPositions[row] = row;
        }
        return instance.manualRowPositions[row];
      }

      return row;
    };
  }

  var htManualRowMove = new HandsontableManualRowMove();

  Handsontable.hooks.add('beforeInit', htManualRowMove.beforeInit);
  Handsontable.hooks.add('afterInit',  function () {
    htManualRowMove.init.call(this, 'afterInit');
  });

  Handsontable.hooks.add('afterUpdateSettings', function () {
    htManualRowMove.init.call(this, 'afterUpdateSettings');
  });

  Handsontable.hooks.add('modifyRow', htManualRowMove.modifyRow);
  Handsontable.hooks.register('afterRowMove');

})(Handsontable);
/**
 * This plugin provides "drag-down" and "copy-down" functionalities, both operated
 * using the small square in the right bottom of the cell selection.
 *
 * "Drag-down" expands the value of the selected cells to the neighbouring
 * cells when you drag the small square in the corner.
 *
 * "Copy-down" copies the value of the selection to all empty cells
 * below when you double click the small square.
 */
(function (Handsontable) {
  'use strict';

  function Autofill(instance) {
    this.instance = instance;
    this.addingStarted = false;

    var $document = $(document),
      wtOnCellCornerMouseDown,
      wtOnCellMouseOver;

    $(this.instance.$table).off('mouseup.' + instance.guid).on('mouseup.' + instance.guid, function (event) {
      if (instance.autofill.handle && instance.autofill.handle.isDragged) {
        if (instance.autofill.handle.isDragged > 1) {
          instance.autofill.apply();
        }
        instance.autofill.handle.isDragged = 0;
      }
    });

    /*
     * Appeding autofill-specific methods to walkontable event settings
     */
    wtOnCellCornerMouseDown = this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown;
    this.instance.view.wt.wtSettings.settings.onCellCornerMouseDown = function(event) {
      instance.autofill.handle.isDragged = 1;
      wtOnCellCornerMouseDown(event);
    }

    wtOnCellMouseOver = this.instance.view.wt.wtSettings.settings.onCellMouseOver;
    this.instance.view.wt.wtSettings.settings.onCellMouseOver = function(event, coords, TD, wt) {

      if (instance.autofill && (!instance.view.isMouseDown() && instance.autofill.handle && instance.autofill.handle.isDragged)) {
        instance.autofill.handle.isDragged++;
        instance.autofill.showBorder(coords);
        instance.autofill.checkIfNewRowNeeded();
      }

      wtOnCellMouseOver(event, coords, TD, wt);
    }

    this.instance.view.wt.wtSettings.settings.onCellCornerDblClick = function () {
      instance.autofill.selectAdjacent();
    };

  };

  /**
   * Create fill handle and fill border objects
   */
  Autofill.prototype.init = function () {
    this.handle = {};
  },

  /**
   * Hide fill handle and fill border permanently
   */
    Autofill.prototype.disable = function () {
      this.handle.disabled = true;
    },

  /**
   * Selects cells down to the last row in the left column, then fills down to that cell
   */
    Autofill.prototype.selectAdjacent = function () {
      var select, data, r, maxR, c;

      if (this.instance.selection.isMultiple()) {
        select = this.instance.view.wt.selections.area.getCorners();
      }
      else {
        select = this.instance.view.wt.selections.current.getCorners();
      }

      data = this.instance.getData();
      rows : for (r = select[2] + 1; r < this.instance.countRows(); r++) {
        for (c = select[1]; c <= select[3]; c++) {
          if (data[r][c]) {
            break rows;
          }
        }
        if (!!data[r][select[1] - 1] || !!data[r][select[3] + 1]) {
          maxR = r;
        }
      }
      if (maxR) {
        this.instance.view.wt.selections.fill.clear();
        this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(select[0], select[1]));
        this.instance.view.wt.selections.fill.add(new WalkontableCellCoords(maxR, select[3]));
        this.apply();
      }
    },

  /**
   * Apply fill values to the area in fill border, omitting the selection border
   */
    Autofill.prototype.apply = function () {
      var drag, select, start, end, _data;

      this.handle.isDragged = 0;

      drag = this.instance.view.wt.selections.fill.getCorners();
      if (!drag) {
        return;
      }

      this.instance.view.wt.selections.fill.clear();

      if (this.instance.selection.isMultiple()) {
        select = this.instance.view.wt.selections.area.getCorners();
      }
      else {
        select = this.instance.view.wt.selections.current.getCorners();
      }

      if (drag[0] === select[0] && drag[1] < select[1]) {
        start = new WalkontableCellCoords(
          drag[0],
          drag[1]
        );
        end = new WalkontableCellCoords(
          drag[2],
          select[1] - 1
        );
      }
      else if (drag[0] === select[0] && drag[3] > select[3]) {
        start = new WalkontableCellCoords(
          drag[0],
          select[3] + 1
        );
        end = new WalkontableCellCoords(
          drag[2],
          drag[3]
        );
      }
      else if (drag[0] < select[0] && drag[1] === select[1]) {
        start = new WalkontableCellCoords(
          drag[0],
          drag[1]
        );
        end = new WalkontableCellCoords(
          select[0] - 1,
          drag[3]
        );
      }
      else if (drag[2] > select[2] && drag[1] === select[1]) {
        start = new WalkontableCellCoords(
          select[2] + 1,
          drag[1]
        );
        end = new WalkontableCellCoords(
          drag[2],
          drag[3]
        );
      }

      if (start) {
        var selRange = {from: this.instance.getSelectedRange().from, to: this.instance.getSelectedRange().to};

        _data = this.instance.getData(selRange.from.row,selRange.from.col,selRange.to.row,selRange.to.col);

        Handsontable.hooks.run(this.instance, 'beforeAutofill', start, end, _data);

        this.instance.populateFromArray(start.row, start.col, _data, end.row, end.col, 'autofill');

        this.instance.selection.setRangeStart(new WalkontableCellCoords(drag[0], drag[1]));
        this.instance.selection.setRangeEnd(new WalkontableCellCoords(drag[2], drag[3]));
      }
      /*else {
       //reset to avoid some range bug
       selection.refreshBorders();
       }*/
    },

  /**
   * Show fill border
   * @param {WalkontableCellCoords} coords
   */
    Autofill.prototype.showBorder = function (coords) {
      var topLeft = this.instance.getSelectedRange().getTopLeftCorner();
      var bottomRight = this.instance.getSelectedRange().getBottomRightCorner();
      if (this.instance.getSettings().fillHandle !== 'horizontal' && (bottomRight.row < coords.row || topLeft.row > coords.row)) {
        coords = new WalkontableCellCoords(coords.row, bottomRight.col);
      }
      else if (this.instance.getSettings().fillHandle !== 'vertical') {
        coords = new WalkontableCellCoords(bottomRight.row, coords.col);
      }
      else {
        return; //wrong direction
      }

      this.instance.view.wt.selections.fill.clear();
      this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().from);
      this.instance.view.wt.selections.fill.add(this.instance.getSelectedRange().to);
      this.instance.view.wt.selections.fill.add(coords);
      this.instance.view.render();
    }

  Autofill.prototype.checkIfNewRowNeeded = function() {
    var fillCorners,
      tableRows = this.instance.countRows(),
      that = this;

    if(this.instance.view.wt.selections.fill.cellRange && this.addingStarted === false) {
      fillCorners = this.instance.view.wt.selections.fill.getCorners();

      if(fillCorners[2] === tableRows - 1) {
        this.addingStarted = true;

        setTimeout(function() {
          that.instance.alter('insert_row');
          that.addingStarted = false;
        }, 200);
      }
    }

  }


  Handsontable.hooks.add('afterInit', function(){
    var autofill = new Autofill(this);

    if (typeof this.getSettings().fillHandle !== "undefined") {
      if (autofill.handle && this.getSettings().fillHandle === false) {
        autofill.disable();
      }
      else if (!autofill.handle && this.getSettings().fillHandle !== false) {
        this.autofill = autofill;
        this.autofill.init();
      }
    }

  });

  Handsontable.Autofill = Autofill;

})(Handsontable);
/**
 * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable
 * and (optionally) implements behavior needed for native horizontal and vertical scrolling
 */
function WalkontableOverlay() {}

/*
 Possible optimizations:
 [x] don't rerender if scroll delta is smaller than the fragment outside of the viewport
 [ ] move .style.top change before .draw()
 [ ] put .draw() in requestAnimationFrame
 [ ] don't rerender rows that remain visible after the scroll
 */

WalkontableOverlay.prototype.init = function () {
  this.TABLE = this.instance.wtTable.TABLE;
  this.fixed = this.instance.wtTable.hider;
  this.fixedContainer = this.instance.wtTable.holder;
//  this.fixed.style.position = 'absolute';
//  this.fixed.style.left = '0';
  this.scrollHandler = this.getScrollableElement(this.TABLE);
  this.$scrollHandler = $(this.scrollHandler); //in future remove jQuery from here
};

WalkontableOverlay.prototype.makeClone = function (direction) {
  var clone = document.createElement('DIV');
  clone.className = 'ht_clone_' + direction + ' handsontable';
  clone.style.position = 'fixed';
  clone.style.overflow = 'hidden';

  var table2 = document.createElement('TABLE');
  table2.className = this.instance.wtTable.TABLE.className;
  clone.appendChild(table2);

  this.instance.wtTable.holder.parentNode.appendChild(clone);

  return new Walkontable({
    cloneSource: this.instance,
    cloneOverlay: this,
    table: table2
  });
};

WalkontableOverlay.prototype.getScrollableElement = function (TABLE) {
  var el = TABLE.parentNode;
  while (el && el.style) {
    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {
      return el;
    }
    if (this instanceof WalkontableHorizontalScrollbarNative && el.style.overflowX !== 'visible' && el.style.overflowX !== '') {
      return el;
    }
    el = el.parentNode;
  }
  return window;
};

WalkontableOverlay.prototype.prepare = function () {
};

WalkontableOverlay.prototype.onScroll = function () {

  this.windowScrollPosition = this.getScrollPosition();
  this.readSettings(); //read window scroll position

  this.resetFixedPosition(); //may be redundant
};

WalkontableOverlay.prototype.availableSize = function () {
  var availableSize;

  if (this.windowScrollPosition > this.tableParentOffset /*&& last > -1*/) { //last -1 means that viewport is scrolled behind the table
    if (this.instance.wtTable.getLastVisibleRow() === this.total - 1) {
      availableSize = Handsontable.Dom.outerHeight(this.TABLE);
    }
    else {
      availableSize = this.windowSize;
    }
  }
  else {
    availableSize = this.windowSize - (this.tableParentOffset);
  }

  return availableSize;
};

WalkontableOverlay.prototype.refresh = function (selectionsOnly) {
  var last = this.getLastCell();
  this.measureBefore = this.sumCellSizes(0, this.offset);
  if (last === -1) { //last -1 means that viewport is scrolled behind the table
    this.measureAfter = 0;
  }
  else {
    this.measureAfter = this.sumCellSizes(last, this.total - last);
  }
  this.applyToDOM();
  this.clone && this.clone.draw(selectionsOnly);
};

WalkontableOverlay.prototype.destroy = function () {
  this.$scrollHandler.off('.' + this.clone.guid);
  $(window).off('.' + this.clone.guid);
  $(document).off('.' + this.clone.guid);
  $(document.body).off('.' + this.clone.guid);
};
/**
 * WalkontableAbstractStrategy (WalkontableColumnStrategy and WalkontableRowStrategy inherit from this)
 * @constructor
 */
function WalkontableAbstractStrategy(instance) {
  this.instance = instance;
}

WalkontableAbstractStrategy.prototype.getSize = function (index) {
  return this.cellSizes[index];
};

WalkontableAbstractStrategy.prototype.getContainerSize = function (proposedSize) {
  return typeof this.containerSizeFn === 'function' ? this.containerSizeFn(proposedSize) : this.containerSizeFn;
};

WalkontableAbstractStrategy.prototype.countVisible = function () {
  return this.cellCount;
};

WalkontableAbstractStrategy.prototype.isLastIncomplete = function () {
  return this.remainingSize > 0;
};
function WalkontableBorder(instance, settings) {
  var style;

  if(!settings){
    return;
  }

  //reference to instance
  this.instance = instance;
  this.settings = settings;

  this.main = document.createElement("div");
  style = this.main.style;
  style.position = 'absolute';
  style.top = 0;
  style.left = 0;

  var borderDivs = ['top','left','bottom','right','corner'];

  for (var i = 0; i < 5; i++) {
    var position = borderDivs[i];

    var DIV = document.createElement('DIV');
    DIV.className = 'wtBorder ' + (this.settings.className || ''); // + borderDivs[i];
    if(this.settings[position] && this.settings[position].hide){
      DIV.className += " hidden";
    }

    style = DIV.style;
    style.backgroundColor = (this.settings[position] && this.settings[position].color) ? this.settings[position].color : settings.border.color;
    style.height = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';
    style.width = (this.settings[position] && this.settings[position].width) ? this.settings[position].width + 'px' : settings.border.width + 'px';

    this.main.appendChild(DIV);
  }

  this.top = this.main.childNodes[0];
  this.left = this.main.childNodes[1];
  this.bottom = this.main.childNodes[2];
  this.right = this.main.childNodes[3];

  this.topStyle = this.top.style;
  this.leftStyle = this.left.style;
  this.bottomStyle = this.bottom.style;
  this.rightStyle = this.right.style;

  this.corner = this.main.childNodes[4];
  this.corner.className += ' corner';
  this.cornerStyle = this.corner.style;
  this.cornerStyle.width = '5px';
  this.cornerStyle.height = '5px';
  this.cornerStyle.border = '2px solid #FFF';

  this.disappear();
  if (!instance.wtTable.bordersHolder) {
    instance.wtTable.bordersHolder = document.createElement('div');
    instance.wtTable.bordersHolder.className = 'htBorders';
    instance.wtTable.hider.appendChild(instance.wtTable.bordersHolder);

  }
  instance.wtTable.bordersHolder.insertBefore(this.main, instance.wtTable.bordersHolder.firstChild);

  var down = false;
  var $body = $(document.body);

  $body.on('mousedown.walkontable.' + instance.guid, function () {
    down = true;
  });

  $body.on('mouseup.walkontable.' + instance.guid, function () {
    down = false
  });

  $(this.main.childNodes).on('mouseenter', function (event) {
    if (!down || !instance.getSetting('hideBorderOnMouseDownOver')) {
      return;
    }
    event.preventDefault();
    event.stopImmediatePropagation();

    var bounds = this.getBoundingClientRect();

    var $this = $(this);
    $this.hide();

    var isOutside = function (event) {
      if (event.clientY < Math.floor(bounds.top)) {
        return true;
      }
      if (event.clientY > Math.ceil(bounds.top + bounds.height)) {
        return true;
      }
      if (event.clientX < Math.floor(bounds.left)) {
        return true;
      }
      if (event.clientX > Math.ceil(bounds.left + bounds.width)) {
        return true;
      }
    };

    $body.on('mousemove.border.' + instance.guid, function (event) {
      if (isOutside(event)) {
        $body.off('mousemove.border.' + instance.guid);
        $this.show();
      }
    });
  });
}

/**
 * Show border around one or many cells
 * @param {Array} corners
 */
WalkontableBorder.prototype.appear = function (corners) {
  var isMultiple, fromTD, toTD, fromOffset, toOffset, containerOffset, top, minTop, left, minLeft, height, width;
  if (this.disabled) {
    return;
  }

  var instance = this.instance;

  var fromRow
    , fromColumn
    , toRow
    , toColumn
    , i
    , ilen
    , s;

  if (instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
    ilen = instance.getSetting('fixedRowsTop');
  }
  else {
    ilen = instance.wtTable.getRowStrategy().countVisible();
  }

  for (i = 0; i < ilen; i++) {
    s = instance.wtTable.rowFilter.visibleToSource(i);
    if (s >= corners[0] && s <= corners[2]) {
      fromRow = s;
      break;
    }
  }

  for (i = ilen - 1; i >= 0; i--) {
    s = instance.wtTable.rowFilter.visibleToSource(i);
    if (s >= corners[0] && s <= corners[2]) {
      toRow = s;
      break;
    }
  }

  if (instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
    ilen = instance.getSetting('fixedColumnsLeft');
  }
  else {
    ilen = instance.wtTable.getColumnStrategy().cellCount;
  }

  for (i = 0; i < ilen; i++) {
    s = instance.wtTable.columnFilter.visibleToSource(i);
    if (s >= corners[1] && s <= corners[3]) {
      fromColumn = s;
      break;
    }
  }

  for (i = ilen - 1; i >= 0; i--) {
    s = instance.wtTable.columnFilter.visibleToSource(i);
    if (s >= corners[1] && s <= corners[3]) {
      toColumn = s;
      break;
    }
  }

  if (fromRow !== void 0 && fromColumn !== void 0) {
    isMultiple = (fromRow !== toRow || fromColumn !== toColumn);
    fromTD = instance.wtTable.getCell(new WalkontableCellCoords(fromRow, fromColumn));
    toTD = isMultiple ? instance.wtTable.getCell(new WalkontableCellCoords(toRow, toColumn)) : fromTD;
    fromOffset = Handsontable.Dom.offset(fromTD);
    toOffset = isMultiple ? Handsontable.Dom.offset(toTD) : fromOffset;
    containerOffset = Handsontable.Dom.offset(instance.wtTable.TABLE);

    minTop = fromOffset.top;
    height = toOffset.top + Handsontable.Dom.outerHeight(toTD) - minTop;
    minLeft = fromOffset.left;
    width = toOffset.left + Handsontable.Dom.outerWidth(toTD) - minLeft;

    top = minTop - containerOffset.top - 1;
    left = minLeft - containerOffset.left - 1;

    var style = Handsontable.Dom.getComputedStyle(fromTD);
    if (parseInt(style['borderTopWidth'], 10) > 0) {
      top += 1;
      height = height > 0 ? height - 1 : 0;
    }
    if (parseInt(style['borderLeftWidth'], 10) > 0) {
      left += 1;
      width = width > 0 ? width - 1 : 0;
    }
  }
  else {
    this.disappear();
    return;
  }

  this.topStyle.top = top + 'px';
  this.topStyle.left = left + 'px';
  this.topStyle.width = width + 'px';
  this.topStyle.display = 'block';



  this.leftStyle.top = top + 'px';
  this.leftStyle.left = left + 'px';
  this.leftStyle.height = height + 'px';
  this.leftStyle.display = 'block';

  var delta = Math.floor(this.settings.border.width / 2);

  this.bottomStyle.top = top + height - delta + 'px';
  this.bottomStyle.left = left + 'px';
  this.bottomStyle.width = width + 'px';
  this.bottomStyle.display = 'block';

  this.rightStyle.top = top + 'px';
  this.rightStyle.left = left + width - delta + 'px';
  this.rightStyle.height = height + 1 + 'px';
  this.rightStyle.display = 'block';

  if (!this.hasSetting(this.settings.border.cornerVisible)) {
    this.cornerStyle.display = 'none';
  }
  else {
    this.cornerStyle.top = top + height - 4 + 'px';
    this.cornerStyle.left = left + width - 4 + 'px';
    this.cornerStyle.display = 'block';
  }
};

/**
 * Hide border
 */
WalkontableBorder.prototype.disappear = function () {
  this.topStyle.display = 'none';
  this.leftStyle.display = 'none';
  this.bottomStyle.display = 'none';
  this.rightStyle.display = 'none';
  this.cornerStyle.display = 'none';
};

WalkontableBorder.prototype.hasSetting = function (setting) {
  if (typeof setting === 'function') {
    return setting();
  }
  return !!setting;
};
/**
 * WalkontableCellCoords holds cell coordinates (row, column) and few metiod to validate them and retrieve as an array or an object
 * TODO: change interface to WalkontableCellCoords(row, col) everywhere, remove those unnecessary setter and getter functions
 */

function WalkontableCellCoords(row, col) {
  if (typeof row !== 'undefined' && typeof col !== 'undefined') {
    this.row = row;
    this.col = col;
  }
  else {
    this.row = null;
    this.col = null;
  }
}

/**
 * Returns boolean information if given set of coordinates is valid in context of a given Walkontable instance
 * @param instance
 * @returns {boolean}
 */
WalkontableCellCoords.prototype.isValid = function (instance) {
  //is it a valid cell index (0 or higher)
  if (this.row < 0 || this.col < 0) {
    return false;
  }

  //is selection within total rows and columns
  if (this.row >= instance.getSetting('totalRows') || this.col >= instance.getSetting('totalColumns')) {
    return false;
  }

  return true;
};

/**
 * Returns boolean information if this cell coords are the same as cell coords given as a parameter
 * @param {WalkontableCellCoords} cellCoords
 * @returns {boolean}
 */
WalkontableCellCoords.prototype.isEqual = function (cellCoords) {
  if (cellCoords === this) {
    return true;
  }
  return (this.row === cellCoords.row && this.col === cellCoords.col);
};

WalkontableCellCoords.prototype.isSouthEastOf = function (testedCoords) {
  return this.row >= testedCoords.row && this.col >= testedCoords.col;
};

WalkontableCellCoords.prototype.isNorthWestOf = function (testedCoords) {
  return this.row <= testedCoords.row && this.col <= testedCoords.col;
};

window.WalkontableCellCoords = WalkontableCellCoords; //export
/**
 * A cell range is a set of exactly two WalkontableCellCoords (that can be the same or different)
 */

function WalkontableCellRange(highlight, from, to) {
  this.highlight = highlight; //this property is used to draw bold border around a cell where selection was started and to edit the cell when you press Enter
  this.from = from; //this property is usually the same as highlight, but in Excel there is distinction - one can change highlight within a selection
  this.to = to;
}

WalkontableCellRange.prototype.isValid = function (instance) {
  return (this.from.isValid(instance) && this.to.isValid(instance));
};

WalkontableCellRange.prototype.isSingle = function () {
  return (this.from.row === this.to.row && this.from.col === this.to.col);
};

/**
 * Returns boolean information if given cell coords is within `from` and `to` cell coords of this range
 * @param {WalkontableCellCoords} cellCoords
 * @returns {boolean}
 */
WalkontableCellRange.prototype.includes = function (cellCoords) {
  var topLeft = this.getTopLeftCorner();
  var bottomRight = this.getBottomRightCorner();
  return (topLeft.row <= cellCoords.row && bottomRight.row >= cellCoords.row && topLeft.col <= cellCoords.col && bottomRight.col >= cellCoords.col);
};

WalkontableCellRange.prototype.includesRange = function (testedRange) {
  return this.includes(testedRange.getTopLeftCorner()) && this.includes(testedRange.getBottomRightCorner());
};

/**
 * Returns true if tested range overlaps with the range.
 * Range A is considered to to be overlapping with range B if intersection of A and B or B and A is not empty.
 * @param testedRange
 * @returns {boolean}
 */
WalkontableCellRange.prototype.overlaps = function (testedRange) {
  return testedRange.isSouthEastOf(this.getTopLeftCorner()) && testedRange.isNorthWestOf(this.getBottomRightCorner());
};

WalkontableCellRange.prototype.isSouthEastOf = function (testedCoords) {
  return this.getTopLeftCorner().isSouthEastOf(testedCoords) || this.getBottomRightCorner().isSouthEastOf(testedCoords);
};

WalkontableCellRange.prototype.isNorthWestOf = function (testedCoords) {
  return this.getTopLeftCorner().isNorthWestOf(testedCoords) || this.getBottomRightCorner().isNorthWestOf(testedCoords);
};

/**
 * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded
 * @param {WalkontableCellCoords} cellCoords
 * @returns {boolean}
 */
WalkontableCellRange.prototype.expand = function (cellCoords) {
  var topLeft = this.getTopLeftCorner();
  var bottomRight = this.getBottomRightCorner();
  if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
    this.from = new WalkontableCellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
    this.to = new WalkontableCellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));
    return true;
  }
  return false;
};

WalkontableCellRange.prototype.expandByRange = function (expandingRange) {
  if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)){
    return false;
  }

  var topLeft = this.getTopLeftCorner();
  var bottomRight = this.getBottomRightCorner();

  var expandingTopLeft = expandingRange.getTopLeftCorner();
  var expandingBottomRight = expandingRange.getBottomRightCorner();

  var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
  var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
  var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
  var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);

  this.from = new WalkontableCellCoords(resultTopRow, resultTopCol);
  this.to = new WalkontableCellCoords(resultBottomRow, resultBottomCol);

  return true;


};

WalkontableCellRange.prototype.getTopLeftCorner = function () {
  return new WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
};

WalkontableCellRange.prototype.getBottomRightCorner = function () {
  return new WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
};

WalkontableCellRange.prototype.getInner = function () {
  var topLeft = this.getTopLeftCorner();
  var bottomRight = this.getBottomRightCorner();
  var out = [];
  for (var r = topLeft.row; r <= bottomRight.row; r++) {
    for (var c = topLeft.col; c <= bottomRight.col; c++) {
      if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
        out.push(new WalkontableCellCoords(r, c));
      }
    }
  }
  return out;
};

WalkontableCellRange.prototype.getAll = function () {
  var topLeft = this.getTopLeftCorner();
  var bottomRight = this.getBottomRightCorner();
  var out = [];
  for (var r = topLeft.row; r <= bottomRight.row; r++) {
    for (var c = topLeft.col; c <= bottomRight.col; c++) {
      if (topLeft.row === r && topLeft.col === c) {
        out.push(topLeft);
      }
      else if (bottomRight.row === r && bottomRight.col === c) {
        out.push(bottomRight);
      }
      else {
        out.push(new WalkontableCellCoords(r, c));
      }
    }
  }
  return out;
};

/**
 * Runs a callback function against all cells in the range. You can break the iteration by returning false in the callback function
 * @param callback {Function}
 */
WalkontableCellRange.prototype.forAll = function (callback) {
  var topLeft = this.getTopLeftCorner();
  var bottomRight = this.getBottomRightCorner();
  for (var r = topLeft.row; r <= bottomRight.row; r++) {
    for (var c = topLeft.col; c <= bottomRight.col; c++) {
      var breakIteration = callback(r, c);
      if (breakIteration === false) {
        return;
      }
    }
  }
};

window.WalkontableCellRange = WalkontableCellRange; //export
/**
 * WalkontableClassNameList
 * @constructor
 */
function WalkontableClassNameCache() {
  this.cache = [];
}

WalkontableClassNameCache.prototype.add = function (r, c, cls) {
  if (!this.cache[r]) {
    this.cache[r] = [];
  }
  if (!this.cache[r][c]) {
    this.cache[r][c] = [];
  }
  this.cache[r][c][cls] = true;
};

WalkontableClassNameCache.prototype.test = function (r, c, cls) {
  return (this.cache[r] && this.cache[r][c] && this.cache[r][c][cls]);
};
/**
 * WalkontableColumnFilter
 * @constructor
 */
function WalkontableColumnFilter(total, countTH) {
  this.total = total;
  this.countTH = countTH;
}

WalkontableColumnFilter.prototype.visibleToSource = function (n) {
  return n;
};

WalkontableColumnFilter.prototype.sourceToVisible = function (n) {
  return n;
};

WalkontableColumnFilter.prototype.offsettedTH = function (n) {
  return n - this.countTH;
};

WalkontableColumnFilter.prototype.unOffsettedTH = function (n) {
  return n + this.countTH;
};

WalkontableColumnFilter.prototype.visibleRowHeadedColumnToSourceColumn = function (n) {
  return this.visibleToSource(this.offsettedTH(n));
};

WalkontableColumnFilter.prototype.sourceColumnToVisibleRowHeadedColumn = function (n) {
  return this.unOffsettedTH(this.sourceToVisible(n));
};
/**
 * WalkontableColumnStrategy
 * @param containerSizeFn
 * @param sizeAtIndex
 * @param strategy - all, last, none
 * @constructor
 */
function WalkontableColumnStrategy(instance, containerSizeFn, sizeAtIndex, strategy) {
  var size
    , i = 0;

  WalkontableAbstractStrategy.apply(this, arguments);

  this.containerSizeFn = containerSizeFn;
  this.cellSizesSum = 0;
  this.cellSizes = [];
  this.cellStretch = [];
  this.cellCount = 0;
  this.visibleCellCount = 0;
  this.remainingSize = 0;
  this.strategy = strategy;

  //step 1 - determine cells that fit containerSize and cache their widths
  while (true) {
    size = sizeAtIndex(i);
    if (size === void 0) {
      break; //total columns exceeded
    }
    if (this.cellSizesSum < this.getContainerSize(this.cellSizesSum + size)) {
      this.visibleCellCount++;
    }
    this.cellSizes.push(size);
    this.cellSizesSum += size;
    this.cellCount++;

    i++;
  }

  var containerSize = this.getContainerSize(this.cellSizesSum);
  this.remainingSize = this.cellSizesSum - containerSize;
  //negative value means the last cell is fully visible and there is some space left for stretching
  //positive value means the last cell is not fully visible
}

WalkontableColumnStrategy.prototype = new WalkontableAbstractStrategy();

WalkontableColumnStrategy.prototype.getSize = function (index) {
  return this.cellSizes[index] + (this.cellStretch[index] || 0);
};

WalkontableColumnStrategy.prototype.stretch = function () {
  //step 2 - apply stretching strategy
  var containerSize
    , i = 0;

  containerSize = this.instance.wtTable.allRowsInViewport() ? this.getContainerSize() : this.getContainerSize(Infinity);

  this.remainingSize = this.cellSizesSum - containerSize;

  this.cellStretch.length = 0; //clear previous stretch

  if (this.strategy === 'all') {
    if (this.remainingSize < 0) {
      var ratio = containerSize / this.cellSizesSum;
      var newSize;

      while (i < this.cellCount - 1) { //"i < this.cellCount - 1" is needed because last cellSize is adjusted after the loop
        newSize = Math.floor(ratio * this.cellSizes[i]);
        this.remainingSize += newSize - this.cellSizes[i];
        this.cellStretch[i] = newSize - this.cellSizes[i];
        i++;
      }
      this.cellStretch[this.cellCount - 1] = -this.remainingSize;
      this.remainingSize = 0;
    }
  }
  else if (this.strategy === 'last') {
    if (this.remainingSize < 0 && containerSize !== Infinity) { //Infinity is with native scroll when the table is wider than the viewport (TODO: test)
      this.cellStretch[this.cellCount - 1] = -this.remainingSize;
      this.remainingSize = 0;
    }
  }
};

WalkontableColumnStrategy.prototype.countVisible = function () {
  return this.visibleCellCount;
};

WalkontableColumnStrategy.prototype.isLastIncomplete = function () {

  var firstRow = this.instance.wtTable.getFirstVisibleRow();
  var lastCol = this.instance.wtTable.getLastVisibleColumn();
  var cell = this.instance.wtTable.getCell(new WalkontableCellCoords(firstRow, lastCol));
  var cellOffset = Handsontable.Dom.offset(cell);
  var cellWidth = Handsontable.Dom.outerWidth(cell);
  var cellEnd = cellOffset.left + cellWidth;

  var viewportOffsetLeft = this.instance.wtScrollbars.vertical.getScrollPosition();
  var viewportWitdh = this.instance.wtViewport.getViewportWidth();
  var viewportEnd = viewportOffsetLeft + viewportWitdh;


  return viewportEnd >= cellEnd;
};
function Walkontable(settings) {
  var originalHeaders = [];

  this.guid = 'wt_' + walkontableRandomString(); //this is the namespace for global events

  //bootstrap from settings
  if (settings.cloneSource) {
    this.cloneSource = settings.cloneSource;
    this.cloneOverlay = settings.cloneOverlay;
    this.wtSettings = settings.cloneSource.wtSettings;
    this.wtTable = new WalkontableTable(this, settings.table);
    this.wtScroll = new WalkontableScroll(this);
    this.wtViewport = settings.cloneSource.wtViewport;
    this.wtEvent = new WalkontableEvent(this);
    this.selections = this.generateSelectionClones(this.cloneSource.selections);
  }
  else {
    this.wtSettings = new WalkontableSettings(this, settings);
    this.wtTable = new WalkontableTable(this, settings.table);
    this.wtScroll = new WalkontableScroll(this);
    this.wtViewport = new WalkontableViewport(this);
    this.wtEvent = new WalkontableEvent(this);
    var selectionSettings = this.getSetting('selections');
    this.selections = selectionSettings ? this.generateSelections(selectionSettings) : [];

    this.wtScrollbars = new WalkontableScrollbars(this);
  }

  //find original headers
  if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
    for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
      originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
    }
    if (!this.getSetting('columnHeaders').length) {
      this.update('columnHeaders', [function (column, TH) {
        Handsontable.Dom.fastInnerText(TH, originalHeaders[column]);
      }]);
    }
  }



  this.drawn = false;
  this.drawInterrupted = false;
}

Walkontable.prototype.draw = function (selectionsOnly) {
  this.drawInterrupted = false;
  if (!selectionsOnly && !Handsontable.Dom.isVisible(this.wtTable.TABLE)) {
    this.drawInterrupted = true; //draw interrupted because TABLE is not visible
    return;
  }

  selectionsOnly = selectionsOnly && this.getSetting('offsetRow') === this.lastOffsetRow;
  this.lastOffsetRow = this.getSetting('offsetRow');

  var totalRows = this.getSetting('totalRows');

  if (this.lastOffsetRow > totalRows && totalRows > 0) {
    this.scrollVertical(-Infinity); //TODO: probably very inefficient!
    this.scrollViewport(new WalkontableCellCoords(totalRows - 1, 0));
  }


  this.wtTable.draw(selectionsOnly);
  return this;
};

Walkontable.prototype.update = function (settings, value) {
  return this.wtSettings.update(settings, value);
};

Walkontable.prototype.scrollVertical = function (delta) {
  var result = this.wtScroll.scrollVertical(delta);

  this.getSetting('onScrollVertically');

  return result;
};

Walkontable.prototype.scrollHorizontal = function (delta) {
  var result = this.wtScroll.scrollHorizontal(delta);

  this.getSetting('onScrollHorizontally');

  return result;
};

/**
 * Scrolls the viewport to a cell (rerenders if needed)
 * @param {WalkontableCellCoords} coords
 * @returns {Walkontable}
 */

Walkontable.prototype.scrollViewport = function (coords) {
  this.wtScroll.scrollViewport(coords);
  return this;
};

Walkontable.prototype.getViewport = function () {
  return [
    this.wtTable.getFirstVisibleRow(),
    this.wtTable.getFirstVisibleColumn(),
    this.wtTable.getLastVisibleRow(),
    this.wtTable.getLastVisibleColumn()
  ];
};

Walkontable.prototype.getSetting = function (key, param1, param2, param3, param4) {
  return this.wtSettings.getSetting(key, param1, param2, param3, param4); //this is faster than .apply - https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
};

Walkontable.prototype.hasSetting = function (key) {
  return this.wtSettings.has(key);
};

Walkontable.prototype.generateSelections = function (settings) {
  var selections = [];
  for (var i = 0, ilen = settings.length; i < ilen; i++) {
    var sel = new WalkontableSelection(this, settings[i]);
    selections.push(sel);
    if (sel.settings.className) {
      selections[sel.settings.className] = sel; //create shorthand access
    }
  }
  return selections;
};

Walkontable.prototype.generateSelectionClones = function (selections) {
  var clones = [];
  for (var i = 0, ilen = selections.length; i < ilen; i++) {
    var sel = selections[i].makeClone(this);
    clones.push(sel);
    if (sel.settings.className) {
      clones[sel.settings.className] = sel; //create shorthand access
    }
  }
  return clones;
};

Walkontable.prototype.destroy = function () {
  $(window).off('.' + this.guid);
  $(document.body).off('.' + this.guid);
  this.wtScrollbars.destroy();
  this.wtEvent && this.wtEvent.destroy();
};
/**
 * A overlay that renders ALL available rows & columns positioned on top of the original Walkontable instance and all other overlays.
 * Used for debugging purposes to see if the other overlays (that render only part of the rows & columns) are positioned correctly
 * @param instance
 * @constructor
 */
function WalkontableDebugOverlay(instance) {
  this.instance = instance;
  this.init();
  this.clone = this.makeClone('debug');
  this.clone.wtTable.holder.style.opacity = 0.4;
  this.clone.wtTable.holder.style.textShadow = '0 0 2px #ff0000';

  var that = this;
  var lastTimeout;
  var lastX = 0;
  var lastY = 0;
  var overlayContainer = that.clone.wtTable.holder.parentNode;

  $(document.body).on('mousemove.' + this.instance.guid, function (event) {
    if (!that.instance.wtTable.holder.parentNode) {
      return; //removed from DOM
    }
    if ((event.clientX - lastX > -5 && event.clientX - lastX < 5) && (event.clientY - lastY > -5 && event.clientY - lastY < 5)) {
      return; //ignore minor mouse movement
    }
    lastX = event.clientX;
    lastY = event.clientY;
    Handsontable.Dom.addClass(overlayContainer, 'wtDebugHidden');
    Handsontable.Dom.removeClass(overlayContainer, 'wtDebugVisible');
    clearTimeout(lastTimeout);
    lastTimeout = setTimeout(function () {
      Handsontable.Dom.removeClass(overlayContainer, 'wtDebugHidden');
      Handsontable.Dom.addClass(overlayContainer, 'wtDebugVisible');
    }, 1000);
  });
}

WalkontableDebugOverlay.prototype = new WalkontableOverlay();

WalkontableDebugOverlay.prototype.resetFixedPosition = function () {
  if (!this.instance.wtTable.holder.parentNode) {
    return; //removed from DOM
  }
  var elem = this.clone.wtTable.holder.parentNode;
  var box = this.instance.wtTable.holder.getBoundingClientRect();
  elem.style.top = Math.ceil(box.top, 10) + 'px';
  elem.style.left = Math.ceil(box.left, 10) + 'px';
};

WalkontableDebugOverlay.prototype.prepare = function () {
};

WalkontableDebugOverlay.prototype.refresh = function (selectionsOnly) {
  this.clone && this.clone.draw(selectionsOnly);
};

WalkontableDebugOverlay.prototype.getScrollPosition = function () {
};

WalkontableDebugOverlay.prototype.getLastCell = function () {
};

WalkontableDebugOverlay.prototype.applyToDOM = function () {
};

WalkontableDebugOverlay.prototype.scrollTo = function () {
};

WalkontableDebugOverlay.prototype.readWindowSize = function () {
};

WalkontableDebugOverlay.prototype.readSettings = function () {
};
function WalkontableEvent(instance) {
  var that = this;

  //reference to instance
  this.instance = instance;

  var dblClickOrigin = [null, null];
  var dblClickTimeout = [null, null];

  var onMouseDown = function (event) {
    var cell = that.parentCell(event.target);
    if (Handsontable.Dom.hasClass(event.target, 'corner')) {
      that.instance.getSetting('onCellCornerMouseDown', event, event.target);
    }
    else if (cell.TD) {
      if (that.instance.hasSetting('onCellMouseDown')) {
        that.instance.getSetting('onCellMouseDown', event, cell.coords, cell.TD, that.instance);
      }
    }

    if (event.button !== 2) { //if not right mouse button
      if (cell.TD) {
        dblClickOrigin[0] = cell.TD;
        clearTimeout(dblClickTimeout[0]);
        dblClickTimeout[0] = setTimeout(function () {
          dblClickOrigin[0] = null;
        }, 1000);
      }
    }
  };

  var lastMouseOver;
  var onMouseOver = function (event) {
    if (that.instance.hasSetting('onCellMouseOver')) {
      var TABLE = that.instance.wtTable.TABLE;
      var TD = Handsontable.Dom.closest(event.target, ['TD', 'TH'], TABLE);
      if (TD && TD !== lastMouseOver && Handsontable.Dom.isChildOf(TD, TABLE)) {
        lastMouseOver = TD;
        that.instance.getSetting('onCellMouseOver', event, that.instance.wtTable.getCoords(TD), TD, that.instance);
      }
    }
  };

/*  var lastMouseOut;
  var onMouseOut = function (event) {
    if (that.instance.hasSetting('onCellMouseOut')) {
      var TABLE = that.instance.wtTable.TABLE;
      var TD = Handsontable.Dom.closest(event.target, ['TD', 'TH'], TABLE);
      if (TD && TD !== lastMouseOut && Handsontable.Dom.isChildOf(TD, TABLE)) {
        lastMouseOut = TD;
        if (TD.nodeName === 'TD') {
          that.instance.getSetting('onCellMouseOut', event, that.instance.wtTable.getCoords(TD), TD);
        }
      }
    }
  };*/

  var onMouseUp = function (event) {
    if (event.button !== 2) { //if not right mouse button
      var cell = that.parentCell(event.target);

      if (cell.TD === dblClickOrigin[0] && cell.TD === dblClickOrigin[1]) {
        if (Handsontable.Dom.hasClass(event.target, 'corner')) {
          that.instance.getSetting('onCellCornerDblClick', event, cell.coords, cell.TD, that.instance);
        }
        else {
          that.instance.getSetting('onCellDblClick', event, cell.coords, cell.TD, that.instance);
        }

        dblClickOrigin[0] = null;
        dblClickOrigin[1] = null;
      }
      else if (cell.TD === dblClickOrigin[0]) {
        dblClickOrigin[1] = cell.TD;
        clearTimeout(dblClickTimeout[1]);
        dblClickTimeout[1] = setTimeout(function () {
          dblClickOrigin[1] = null;
        }, 500);
      }
    }
  };

  $(this.instance.wtTable.holder).on('mousedown', onMouseDown);
  $(this.instance.wtTable.TABLE).on('mouseover', onMouseOver);
  $(this.instance.wtTable.holder).on('mouseup', onMouseUp);

}

WalkontableEvent.prototype.parentCell = function (elem) {
  var cell = {};
  var TABLE = this.instance.wtTable.TABLE;
  var TD = Handsontable.Dom.closest(elem, ['TD', 'TH'], TABLE);

  if (TD && Handsontable.Dom.isChildOf(TD, TABLE)) {
    cell.coords = this.instance.wtTable.getCoords(TD);
    cell.TD = TD;
  }
  else if (Handsontable.Dom.hasClass(elem, 'wtBorder') && Handsontable.Dom.hasClass(elem, 'current')) {
    cell.coords = this.instance.selections.current.cellRange.highlight;
    cell.TD = this.instance.wtTable.getCell(cell.coords);
  }
  return cell;
};

WalkontableEvent.prototype.destroy = function () {
  clearTimeout(this.dblClickTimeout0);
  clearTimeout(this.dblClickTimeout1);
};
function walkontableRangesIntersect() {
  var from = arguments[0];
  var to = arguments[1];
  for (var i = 1, ilen = arguments.length / 2; i < ilen; i++) {
    if (from <= arguments[2 * i + 1] && to >= arguments[2 * i]) {
      return true;
    }
  }
  return false;
}

/**
 * Generates a random hex string. Used as namespace for Walkontable instance events.
 * @return {String} - 16 character random string: "92b1bfc74ec4"
 */
function walkontableRandomString() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }

  return s4() + s4() + s4() + s4();
}
/**
 * http://notes.jetienne.com/2011/05/18/cancelRequestAnimFrame-for-paul-irish-requestAnimFrame.html
 */
window.requestAnimFrame = (function () {
  return  window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (/* function */ callback, /* DOMElement */ element) {
      return window.setTimeout(callback, 1000 / 60);
    };
})();

window.cancelRequestAnimFrame = (function () {
  return window.cancelAnimationFrame ||
    window.webkitCancelRequestAnimationFrame ||
    window.mozCancelRequestAnimationFrame ||
    window.oCancelRequestAnimationFrame ||
    window.msCancelRequestAnimationFrame ||
    clearTimeout
})();

//http://snipplr.com/view/13523/
//modified for speed
//http://jsperf.com/getcomputedstyle-vs-style-vs-css/8
if (!window.getComputedStyle) {
  (function () {
    var elem;

    var styleObj = {
      getPropertyValue: function getPropertyValue(prop) {
        if (prop == 'float') prop = 'styleFloat';
        return elem.currentStyle[prop.toUpperCase()] || null;
      }
    };

    window.getComputedStyle = function (el) {
      elem = el;
      return styleObj;
    }
  })();
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim
 */
if (!String.prototype.trim) {
  var trimRegex = /^\s+|\s+$/g;
  String.prototype.trim = function () {
    return this.replace(trimRegex, '');
  };
}
/**
 * WalkontableRowFilter
 * @constructor
 */
function WalkontableRowFilter(offset, total, fixedCount, countTH) {
  this.offset = offset;
  this.total = total;
  this.fixedCount = fixedCount;
  this.countTH = countTH;
}

WalkontableRowFilter.prototype.offsetted = function (n) {
  return n + this.offset;
};

WalkontableRowFilter.prototype.unOffsetted = function (n) {
  return n - this.offset;
};

WalkontableRowFilter.prototype.fixed = function (n) {
  if (n < this.fixedCount) {
    return n - this.offset;
  }
  else {
    return n;
  }
};

WalkontableRowFilter.prototype.unFixed = function (n) {
  if (n < this.fixedCount) {
    return n + this.offset;
  }
  else {
    return n;
  }
};

WalkontableRowFilter.prototype.visibleToSource = function (n) {
  return this.offsetted(this.fixed(n));
};

WalkontableRowFilter.prototype.sourceToVisible = function (n) {
  return this.unOffsetted(this.unFixed(n));
};

WalkontableRowFilter.prototype.offsettedTH = function (n) {
  return n - this.countTH;
};

WalkontableRowFilter.prototype.visibleColHeadedRowToSourceRow = function (n) {
  return this.visibleToSource(this.offsettedTH(n));
};

WalkontableRowFilter.prototype.sourceRowToVisibleColHeadedRow = function (n) {
  return this.unOffsettedTH(this.sourceToVisible(n));
};

/**
 * WalkontableRowStrategy
 * @param containerSizeFn
 * @param sizeAtIndex
 * @constructor
 */
function WalkontableRowStrategy(instance, containerSizeFn, sizeAtIndex) {

  WalkontableAbstractStrategy.apply(this, arguments);

  this.containerSizeFn = containerSizeFn;
  this.sizeAtIndex = sizeAtIndex;
  this.cellSizesSum = 0;
  this.cellSizes = [];
  this.cellCount = 0;
  this.visiblCellCount = 0;
  this.remainingSize = -Infinity;
  this.maxOuts = 10; //max outs in one direction (before and after table)
  this.curOuts = this.maxOuts;
}

WalkontableRowStrategy.prototype = new WalkontableAbstractStrategy();

WalkontableRowStrategy.prototype.add = function (i, TD) {
  if(!this.canRenderMoreRows()){
    return false;
  }

  var size = this.sizeAtIndex(i, TD);

  if (size === void 0) {
    return false; //total rows exceeded
  }

  var containerSize = this.getContainerSize(this.cellSizesSum + size);
  this.cellSizes.push(size);
  this.cellSizesSum += size;

  this.cellCount++;
  this.remainingSize = this.cellSizesSum - containerSize;

  if (this.remainingSize <= size ){
    this.visiblCellCount++;
  }

  return true;
};

/**
 * Checks whether the number of already rendered rows does not exceeds the number of rows visible in viewport + maximal
 * number of rows rendered above and below viewport
 * @returns {boolean}
 */
WalkontableRowStrategy.prototype.canRenderMoreRows = function () {
  return this.remainingSize <= 0 || this.cellCount - this.visiblCellCount < this.curOuts;
};

WalkontableRowStrategy.prototype.remove = function () {
  var size = this.cellSizes.pop();
  this.cellSizesSum -= size;
  this.cellCount--;
  this.remainingSize -= size;
};

WalkontableRowStrategy.prototype.removeOutstanding = function () {
  while (this.cellCount - this.visiblCellCount > this.curOuts) { //this row is completely off screen!
    this.remove();
  }
};

WalkontableRowStrategy.prototype.countRendered = function () {
  return this.cellCount;
}

WalkontableRowStrategy.prototype.countVisible = function () {
  return this.visiblCellCount;
};

WalkontableRowStrategy.prototype.isLastIncomplete = function () {
  var lastRow = this.instance.wtTable.getLastVisibleRow();
  var firstCol = this.instance.wtTable.getFirstVisibleColumn();
  var cell = this.instance.wtTable.getCell(new WalkontableCellCoords(lastRow, firstCol));
  var cellOffsetTop = Handsontable.Dom.offset(cell).top;
  var cellHeight = Handsontable.Dom.outerHeight(cell);
  var cellEnd = cellOffsetTop + cellHeight;

  var viewportOffsetTop = this.instance.wtScrollbars.horizontal.scrollHandler.offsetTop + this.instance.wtScrollbars.vertical.getScrollPosition();
  var viewportHeight = this.instance.wtViewport.getViewportHeight();
  var viewportEnd = viewportOffsetTop + viewportHeight;


  return viewportEnd < cellEnd;
};
function WalkontableScroll(instance) {
  this.instance = instance;
}

WalkontableScroll.prototype.scrollVertical = function (delta) {
  if (!this.instance.drawn) {
    throw new Error('scrollVertical can only be called after table was drawn to DOM');
  }

  var instance = this.instance
    , newOffset
    , offset = instance.getSetting('offsetRow')
    , fixedCount = instance.getSetting('fixedRowsTop')
    , total = instance.getSetting('totalRows')
    , maxSize = instance.wtViewport.getViewportHeight();

  if (total > 0 && !this.instance.wtTable.isLastRowFullyVisible()) {
    newOffset = this.scrollLogicVertical(delta, offset, total, fixedCount, maxSize, function (row) {
      if (row - offset < fixedCount && row - offset >= 0) {
        return instance.getSetting('rowHeight', row - offset);
      }
      else {
        return instance.getSetting('rowHeight', row);
      }
    });

  } else {
    newOffset = 0;
  }


  if (newOffset !== offset) {
    this.instance.wtScrollbars.vertical.scrollTo(newOffset);
  }
  return instance;
};

WalkontableScroll.prototype.scrollHorizontal = function (delta) {
  this.instance.wtScrollbars.horizontal.scrollTo(delta);
  return this.instance;
};

WalkontableScroll.prototype.scrollLogicVertical = function (delta, offset, total, fixedCount, maxSize, cellSizeFn) {
  var newOffset = offset + delta;

  if (newOffset >= total - fixedCount) {
    newOffset = total - fixedCount - 1;
  }

  if (newOffset < 0) {
    newOffset = 0;
  }

  return newOffset;
};

/**
 * Scrolls viewport to a cell by minimum number of cells
 * @param {WalkontableCellCoords} coords
 */
WalkontableScroll.prototype.scrollViewport = function (coords) {
  if (!this.instance.drawn) {
    return;
  }

  var offsetRow = this.instance.getSetting('offsetRow')
    , totalRows = this.instance.getSetting('totalRows')
    , totalColumns = this.instance.getSetting('totalColumns');


  if (coords.row < 0 || coords.row > totalRows - 1) {
    throw new Error('row ' + coords.row + ' does not exist');
  }

  if (coords.col < 0 || coords.col > totalColumns - 1) {
    throw new Error('column ' + coords.col + ' does not exist');
  }

  var TD = this.instance.wtTable.getCell(coords);
  if (typeof TD === 'object') {
    this.scrollToRenderedCell(TD);
  }  else if (coords.row >= this.instance.wtTable.getLastVisibleRow()) {

    this.scrollVertical(coords.row - this.instance.wtTable.getLastVisibleRow());

    if (coords.row == this.instance.wtTable.getLastVisibleRow() && this.instance.wtTable.getRowStrategy().isLastIncomplete()){
      this.scrollViewport(coords)
    }

  } else if (coords.row >= this.instance.getSetting('fixedRowsTop')){
    this.scrollVertical(coords.row - this.instance.wtTable.getFirstVisibleRow());
  }
};

WalkontableScroll.prototype.scrollToRenderedCell = function (TD) {
  var cellOffset = Handsontable.Dom.offset(TD);
  var cellWidth = Handsontable.Dom.outerWidth(TD);
  var cellHeight = Handsontable.Dom.outerHeight(TD);
  var workspaceOffset = Handsontable.Dom.offset(this.instance.wtTable.TABLE);
  var viewportScrollPosition = {
    left: this.instance.wtScrollbars.horizontal.getScrollPosition(),
    top: this.instance.wtScrollbars.vertical.getScrollPosition()
  };

  var workspaceWidth = this.instance.wtViewport.getWorkspaceWidth();
  var workspaceHeight = this.instance.wtViewport.getWorkspaceHeight();
  var leftCloneWidth = Handsontable.Dom.outerWidth(this.instance.wtScrollbars.horizontal.clone.wtTable.TABLE);
  var topCloneHeight = Handsontable.Dom.outerHeight(this.instance.wtScrollbars.vertical.clone.wtTable.TABLE);

  if (this.instance.wtScrollbars.horizontal.scrollHandler !== window) {
    workspaceOffset.left = 0;
    cellOffset.left -= Handsontable.Dom.offset(this.instance.wtScrollbars.horizontal.scrollHandler).left;
  }

  if (this.instance.wtScrollbars.vertical.scrollHandler !== window) {
    workspaceOffset.top = 0;
    cellOffset.top = cellOffset.top - Handsontable.Dom.offset(this.instance.wtScrollbars.vertical.scrollHandler).top;
  }

  if (cellWidth < workspaceWidth) {
    if (cellOffset.left < viewportScrollPosition.left + leftCloneWidth) {
      this.instance.wtScrollbars.horizontal.setScrollPosition(cellOffset.left - leftCloneWidth);
    }
    else if (cellOffset.left + cellWidth > workspaceOffset.left + viewportScrollPosition.left + workspaceWidth) {
      var delta = (cellOffset.left + cellWidth) - (workspaceOffset.left + viewportScrollPosition.left + workspaceWidth);
      this.instance.wtScrollbars.horizontal.setScrollPosition(viewportScrollPosition.left + delta);
    }
  }

  if (cellHeight < workspaceHeight) {
    if (cellOffset.top < viewportScrollPosition.top + topCloneHeight) {
      this.instance.wtScrollbars.vertical.setScrollPosition(cellOffset.top - topCloneHeight);
      this.instance.wtScrollbars.vertical.onScroll();
    }
    else if (cellOffset.top + cellHeight > viewportScrollPosition.top + workspaceHeight) {
      this.instance.wtScrollbars.vertical.setScrollPosition(cellOffset.top - workspaceHeight + cellHeight);
      this.instance.wtScrollbars.vertical.onScroll();
    }
  }

};

function WalkontableCornerScrollbarNative(instance) {
  this.instance = instance;
  this.init();
  this.clone = this.makeClone('corner');
}

WalkontableCornerScrollbarNative.prototype = new WalkontableOverlay();

WalkontableCornerScrollbarNative.prototype.resetFixedPosition = function () {
  if (!this.instance.wtTable.holder.parentNode) {
    return; //removed from DOM
  }
  var elem = this.clone.wtTable.holder.parentNode;

  var box;
  if (this.scrollHandler === window) {
    box = this.instance.wtTable.hider.getBoundingClientRect();
    var top = Math.ceil(box.top, 10);
    var bottom = Math.ceil(box.bottom, 10);

    if (top < 0 && bottom > 0) {
      elem.style.top = '0';
    }
    else {
      elem.style.top = top + 'px';
    }

    var left = Math.ceil(box.left, 10);
    var right = Math.ceil(box.right, 10);

    if (left < 0 && right > 0) {
      elem.style.left = '0';
    }
    else {
      elem.style.left = left + 'px';
    }
  }
  else {
    box = this.scrollHandler.getBoundingClientRect();
    elem.style.top = Math.ceil(box.top, 10) + 'px';
    elem.style.left = Math.ceil(box.left, 10) + 'px';
  }

  elem.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 4 + 'px';
  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 4 + 'px';
};

WalkontableCornerScrollbarNative.prototype.prepare = function () {
};

WalkontableCornerScrollbarNative.prototype.refresh = function (selectionsOnly) {
  this.measureBefore = 0;
  this.measureAfter = 0;
  this.clone && this.clone.draw(selectionsOnly);
};

WalkontableCornerScrollbarNative.prototype.getScrollPosition = function () {
};

WalkontableCornerScrollbarNative.prototype.getLastCell = function () {
};

WalkontableCornerScrollbarNative.prototype.applyToDOM = function () {
};

WalkontableCornerScrollbarNative.prototype.scrollTo = function () {
};

WalkontableCornerScrollbarNative.prototype.readWindowSize = function () {
};

WalkontableCornerScrollbarNative.prototype.readSettings = function () {
};
function WalkontableHorizontalScrollbarNative(instance) {
  this.instance = instance;
  this.type = 'horizontal';
  this.cellSize = 50;
  this.offset = 0;
  this.init();
  this.clone = this.makeClone('left');
}

WalkontableHorizontalScrollbarNative.prototype = new WalkontableOverlay();

//resetFixedPosition (in future merge it with this.refresh?)
WalkontableHorizontalScrollbarNative.prototype.resetFixedPosition = function () {
  if (!this.instance.wtTable.holder.parentNode) {
    return; //removed from DOM
  }
  var elem = this.clone.wtTable.holder.parentNode;

  var box;
  if (this.scrollHandler === window) {
    box = this.instance.wtTable.hider.getBoundingClientRect();
    var left = Math.ceil(box.left, 10);
    var right = Math.ceil(box.right, 10);

    if (left < 0 && right > 0) {
      elem.style.left = '0';
    }
    else {
      elem.style.left = left + 'px';
    }
  }
  else {
    box = this.scrollHandler.getBoundingClientRect();
    elem.style.top = Math.ceil(box.top, 10) + 'px';
    elem.style.left = Math.ceil(box.left, 10) + 'px';
  }

  this.react();
};

//react on movement of the other dimension scrollbar (in future merge it with this.refresh?)
WalkontableHorizontalScrollbarNative.prototype.react = function () {
  if (!this.instance.wtTable.holder.parentNode) {
    return; //removed from DOM
  }
  var overlayContainer = this.clone.wtTable.holder.parentNode;
  if (this.instance.wtScrollbars.vertical.scrollHandler === window) {
    var box = this.instance.wtTable.hider.getBoundingClientRect();
    overlayContainer.style.top = Math.ceil(box.top, 10) + 'px';
    overlayContainer.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 'px';
  }
  else {
    this.clone.wtTable.holder.style.top = -(this.instance.wtScrollbars.vertical.windowScrollPosition - this.instance.wtScrollbars.vertical.measureBefore) + 'px';
    overlayContainer.style.height = this.instance.wtViewport.getWorkspaceHeight() + 'px'
  }
  overlayContainer.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 4 + 'px'; //4 is for the box shadow
};

WalkontableHorizontalScrollbarNative.prototype.prepare = function () {
};

WalkontableHorizontalScrollbarNative.prototype.refresh = function (selectionsOnly) {
  this.measureBefore = 0;
  this.measureAfter = 0;
  this.clone && this.clone.draw(selectionsOnly);
};

WalkontableHorizontalScrollbarNative.prototype.getScrollPosition = function () {
  return Handsontable.Dom.getScrollLeft(this.scrollHandler);
};

WalkontableHorizontalScrollbarNative.prototype.setScrollPosition = function (pos) {
  if (this.scrollHandler === window){
    window.scrollTo(pos, Handsontable.Dom.getWindowScrollTop());
  } else {
    this.scrollHandler.scrollLeft = pos;
  }
};

WalkontableHorizontalScrollbarNative.prototype.onScroll = function () {
  WalkontableOverlay.prototype.onScroll.call(this);

  this.instance.getSetting('onScrollHorizontally');
};

WalkontableHorizontalScrollbarNative.prototype.getLastCell = function () {
  return this.instance.wtTable.getLastVisibleColumn();
};

//applyToDOM (in future merge it with this.refresh?)
WalkontableHorizontalScrollbarNative.prototype.applyToDOM = function () {
  this.fixedContainer.style.paddingLeft = this.measureBefore + 'px';
  this.fixedContainer.style.paddingRight = this.measureAfter + 'px';
};

WalkontableHorizontalScrollbarNative.prototype.scrollTo = function (cell) {
  this.setScrollPosition(this.tableParentOffset + cell * this.cellSize);
};

//readWindowSize (in future merge it with this.prepare?)
WalkontableHorizontalScrollbarNative.prototype.readWindowSize = function () {
  if (this.scrollHandler === window) {
    this.windowSize = document.documentElement.clientWidth;
    this.tableParentOffset = this.instance.wtTable.holderOffset.left;
  }
  else {
    this.windowSize = this.scrollHandler.clientWidth;
    this.tableParentOffset = 0;
  }
  this.windowScrollPosition = this.getScrollPosition();
};

//readSettings (in future merge it with this.prepare?)
WalkontableHorizontalScrollbarNative.prototype.readSettings = function () {
  this.readWindowSize();
  this.total = this.instance.getSetting('totalColumns');
};
function WalkontableVerticalScrollbarNative(instance) {
  this.instance = instance;
  this.type = 'vertical';
  this.cellSize = this.instance.wtSettings.settings.defaultRowHeight;
  this.offset;
  this.total;
  this.init();
  this.clone = this.makeClone('top');
}

WalkontableVerticalScrollbarNative.prototype = new WalkontableOverlay();

//resetFixedPosition (in future merge it with this.refresh?)
WalkontableVerticalScrollbarNative.prototype.resetFixedPosition = function () {
  if (!this.instance.wtTable.holder.parentNode) {
    return; //removed from DOM
  }
  var elem = this.clone.wtTable.holder.parentNode;

  var box;
  if (this.scrollHandler === window) {
    box = this.instance.wtTable.hider.getBoundingClientRect();
    var top = Math.ceil(box.top, 10);
    var bottom = Math.ceil(box.bottom, 10);

    if (top < 0 && bottom > 0) {
      elem.style.top = '0';
    }
    else {
      elem.style.top = top + 'px';
    }
  }
  else {
    box = this.instance.wtScrollbars.horizontal.scrollHandler.getBoundingClientRect();
    elem.style.top = Math.ceil(box.top, 10) + 'px';
    elem.style.left = Math.ceil(box.left, 10) + 'px';
  }

  if (this.instance.wtScrollbars.horizontal.scrollHandler === window) {
    elem.style.width = this.instance.wtViewport.getWorkspaceActualWidth() + 'px';
  }
  else {
    elem.style.width = Handsontable.Dom.outerWidth(this.instance.wtTable.holder.parentNode) + 'px';
  }

  elem.style.height = Handsontable.Dom.outerHeight(this.clone.wtTable.TABLE) + 4 + 'px';
};

//react on movement of the other dimension scrollbar (in future merge it with this.refresh?)
WalkontableVerticalScrollbarNative.prototype.react = function () {
  if (!this.instance.wtTable.holder.parentNode) {
    return; //removed from DOM
  }

  var overlayContainer = this.clone.wtTable.holder.parentNode;
  if (this.instance.wtScrollbars.horizontal.scrollHandler !== window) {

    overlayContainer.firstChild.style.left = -this.instance.wtScrollbars.horizontal.windowScrollPosition + 'px';
  } else {
      var box = this.instance.wtTable.hider.getBoundingClientRect();
      overlayContainer.style.left = Math.ceil(box.left, 10) + 'px';
      overlayContainer.style.width = Handsontable.Dom.outerWidth(this.clone.wtTable.TABLE) + 'px';
  }
};

WalkontableVerticalScrollbarNative.prototype.getScrollPosition = function () {
  return Handsontable.Dom.getScrollTop(this.scrollHandler);
};

WalkontableVerticalScrollbarNative.prototype.setScrollPosition = function (pos) {
  if (this.scrollHandler === window){
    window.scrollTo(Handsontable.Dom.getWindowScrollLeft(), pos);
  } else {
    this.scrollHandler.scrollTop = pos;
  }
};

WalkontableVerticalScrollbarNative.prototype.onScroll = function () {
  WalkontableOverlay.prototype.onScroll.call(this);

  this.instance.draw(true);//

  this.instance.getSetting('onScrollVertically');
};

WalkontableVerticalScrollbarNative.prototype.getLastCell = function () {
  return this.instance.getSetting('offsetRow') + this.instance.wtTable.tbodyChildrenLength - 1;
};

WalkontableVerticalScrollbarNative.prototype.sumCellSizes = function (from, length) {
  var sum = 0;
  while (from < length) {
    sum += this.instance.wtSettings.settings.rowHeight(from) || this.instance.wtSettings.settings.defaultRowHeight; //TODO optimize getSetting, because this is MUCH faster then getSetting
    from++;
  }
  return sum;
};

//applyToDOM (in future merge it with this.refresh?)
WalkontableVerticalScrollbarNative.prototype.applyToDOM = function () {
  var headerSize = this.instance.wtViewport.getColumnHeaderHeight();
  this.fixedContainer.style.height = headerSize + this.sumCellSizes(0, this.total) + 4 + 'px'; //+4 is needed, otherwise vertical scroll appears in Chrome (window scroll mode) - maybe because of fill handle in last row or because of box shadow
  this.fixed.style.top = this.measureBefore + 'px';
  this.fixed.style.bottom = '';
};

WalkontableVerticalScrollbarNative.prototype.scrollTo = function (cell) {
  var newY = this.tableParentOffset + cell * this.cellSize;
  this.setScrollPosition(newY);
  this.onScroll();
};

//readWindowSize (in future merge it with this.prepare?)
WalkontableVerticalScrollbarNative.prototype.readWindowSize = function () {
  if (this.scrollHandler === window) {
    this.windowSize = document.documentElement.clientHeight;
    this.tableParentOffset = this.instance.wtTable.holderOffset.top;
  }
  else {
    var elemHeight = Handsontable.Dom.outerHeight(this.scrollHandler);
    this.windowSize = elemHeight > 0 && this.scrollHandler.clientHeight > 0 ? this.scrollHandler.clientHeight : Infinity; //returns height without DIV scrollbar
    this.tableParentOffset = 0;
  }
  this.windowScrollPosition = this.getScrollPosition();
};

//readSettings (in future merge it with this.prepare?)
WalkontableVerticalScrollbarNative.prototype.readSettings = function () {
  this.readWindowSize();

  this.offset = this.instance.getSetting('offsetRow');
  this.total = this.instance.getSetting('totalRows');

  var scrollDelta = this.windowScrollPosition - this.tableParentOffset;

  var sum = 0;
  var last;
  for (var i = 0; i < this.total; i++) {
    last = this.instance.getSetting('rowHeight', i) || this.instance.wtSettings.settings.defaultRowHeight;
    sum += last;
    if (sum - 1 > scrollDelta) {
      break;
    }
  }

  this.offset = Math.min(i, this.total);
  this.instance.update('offsetRow', this.offset);
};
function WalkontableScrollbars(instance) {
  this.instance = instance;
  instance.update('scrollbarWidth', Handsontable.Dom.getScrollbarWidth());
  instance.update('scrollbarHeight', Handsontable.Dom.getScrollbarWidth());
  this.vertical = new WalkontableVerticalScrollbarNative(instance);
  this.horizontal = new WalkontableHorizontalScrollbarNative(instance);
  this.corner = new WalkontableCornerScrollbarNative(instance);
  if (instance.getSetting('debug')) {
    this.debug = new WalkontableDebugOverlay(instance);
  }
  this.registerListeners();
}

WalkontableScrollbars.prototype.registerListeners = function () {
  var that = this;

  var oldVerticalScrollPosition
    , oldHorizontalScrollPosition
    , oldBoxTop
    , oldBoxLeft
    , oldBoxWidth
    , oldBoxHeight;

  function refreshAll() {
    if(!that.instance.drawn) {
      return;
    }

    if (!that.instance.wtTable.holder.parentNode) {
      //Walkontable was detached from DOM, but this handler was not removed
      that.destroy();
      return;
    }

    that.vertical.windowScrollPosition = that.vertical.getScrollPosition();
    that.horizontal.windowScrollPosition = that.horizontal.getScrollPosition();
    that.box = that.instance.wtTable.hider.getBoundingClientRect();

    /*if((that.box.width !== oldBoxWidth || that.box.height !== oldBoxHeight) && that.instance.rowHeightCache) {
      //that.instance.rowHeightCache.length = 0; //at this point the cached row heights may be invalid, but it is better not to reset the cache, which could cause scrollbar jumping when there are multiline cells outside of the rendered part of the table
      oldBoxWidth = that.box.width;
      oldBoxHeight = that.box.height;
      that.instance.draw(true);
    }*/

    if (that.vertical.windowScrollPosition !== oldVerticalScrollPosition || that.horizontal.windowScrollPosition !== oldHorizontalScrollPosition || that.box.top !== oldBoxTop || that.box.left !== oldBoxLeft) {
      that.vertical.onScroll();
      that.horizontal.onScroll(); //it's done here to make sure that all onScroll's are executed before changing styles
      that.corner.onScroll();

      that.vertical.react();
      that.horizontal.react(); //it's done here to make sure that all onScroll's are executed before changing styles

      oldVerticalScrollPosition = that.vertical.windowScrollPosition;
      oldHorizontalScrollPosition = that.horizontal.windowScrollPosition;
      oldBoxTop = that.box.top;
      oldBoxLeft = that.box.left;
    }
  }

  var $window = $(window);
  this.vertical.$scrollHandler.on('scroll.' + this.instance.guid, refreshAll);
  if (this.vertical.scrollHandler !== this.horizontal.scrollHandler) {
    this.horizontal.$scrollHandler.on('scroll.' + this.instance.guid, refreshAll);
  }

  if (this.vertical.scrollHandler !== window && this.horizontal.scrollHandler !== window) {
    $window.on('scroll.' + this.instance.guid, refreshAll);
  }
};

WalkontableScrollbars.prototype.destroy = function () {
  this.vertical && this.vertical.destroy();
  this.horizontal && this.horizontal.destroy();
  this.corner && this.corner.destroy();
};

WalkontableScrollbars.prototype.refresh = function (selectionsOnly) {
  this.horizontal && this.horizontal.readSettings();
  this.vertical && this.vertical.readSettings();
  this.horizontal && this.horizontal.prepare();
  this.vertical && this.vertical.prepare();
  this.horizontal && this.horizontal.refresh(selectionsOnly);
  this.vertical && this.vertical.refresh(selectionsOnly);
  this.corner && this.corner.refresh(selectionsOnly);
  this.debug && this.debug.refresh(selectionsOnly);
};
function WalkontableSelection(instance, settings) {
  this.instance = instance;
  this.settings = settings;
  this.cellRange = null;
  if (settings.border) {
    this.border = new WalkontableBorder(instance, settings);
  }
}

/**
 * Returns boolean information if selection is empty
 * @returns {boolean}
 */
WalkontableSelection.prototype.isEmpty = function () {
  return (this.cellRange === null);
};

/**
 * Adds a cell coords to the selection
 * @param {WalkontableCellCoords} coords
 */
WalkontableSelection.prototype.add = function (coords) {
  if (this.isEmpty()) {
    this.cellRange = new WalkontableCellRange(coords, coords, coords);
  }
  else {
    this.cellRange.expand(coords);
  }
};

/**
 * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean information about success
 * @param {WalkontableCellCoords} oldCoords
 * @param {WalkontableCellCoords} newCoords
 * @return {boolean}
 */
WalkontableSelection.prototype.replace = function (oldCoords, newCoords) {
  if (!this.isEmpty()) {
    if(this.cellRange.from.isEqual(oldCoords)) {
      this.cellRange.from = newCoords;
      return true;
    }
    if(this.cellRange.to.isEqual(oldCoords)) {
      this.cellRange.to = newCoords;
      return true;
    }
  }
  return false;
};

WalkontableSelection.prototype.clear = function () {
  this.cellRange = null;
};

/**
 * Returns the top left (TL) and bottom right (BR) selection coordinates
 * @returns {Object}
 */
WalkontableSelection.prototype.getCorners = function () {
  var topLeft = this.cellRange.getTopLeftCorner();
  var bottomRight = this.cellRange.getBottomRightCorner();
  return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
};

WalkontableSelection.prototype.draw = function () {
  var corners, r, c, source_r, source_c,
    instance = this.instance,
    visibleRows = instance.wtTable.getRowStrategy().countVisible(),
    renderedColumns = instance.wtTable.getColumnStrategy().cellCount,
    cacheLength;

  if (!this.isEmpty()) {
    corners = this.getCorners();

    for (r = 0; r < visibleRows; r++) {
      for (c = 0; c < renderedColumns; c++) {
        source_r = instance.wtTable.rowFilter.visibleToSource(r);
        source_c = instance.wtTable.columnFilter.visibleToSource(c);

        if (source_r >= corners[0] && source_r <= corners[2] && source_c >= corners[1] && source_c <= corners[3]) {
          //selected cell
          if (this.settings.className) {
            instance.wtTable.currentCellCache.add(r, c, this.settings.className);
          }
        }
        else if (source_r >= corners[0] && source_r <= corners[2]) {
          //selection is in this row
          instance.wtTable.currentCellCache.add(r, c, this.settings.highlightRowClassName);

          // selected row headers
          instance.wtTable.currentCellCache.add(r,renderedColumns,this.settings.highlightRowClassName);
        }
        else if (source_c >= corners[1] && source_c <= corners[3]) {
          //selection is in this column
          instance.wtTable.currentCellCache.add(r, c, this.settings.highlightColumnClassName);

          // selected column headers
          instance.wtTable.currentCellCache.add(visibleRows,c,this.settings.highlightColumnClassName);
        }
      }
    }

    this.border && this.border.appear(corners); //warning! border.appear modifies corners!
  }
  else {
    this.border && this.border.disappear();
  }
};

/*
  Make a clone of a selection by overriding the WOT instance and creating new WalkontableBorder for the new instance
  Method is used for creating selections in overlays
 */
WalkontableSelection.prototype.makeClone = function (instance) {
  function WalkontableSelectionClone(){}
  WalkontableSelectionClone.prototype = this;

  var clone = new WalkontableSelectionClone();

  clone.instance = instance;

  if (clone.border){
    clone.border = new WalkontableBorder(instance, clone.settings);
  }

  return clone;

};

function WalkontableSettings(instance, settings) {
  var that = this;
  this.instance = instance;

  //default settings. void 0 means it is required, null means it can be empty
  this.defaults = {
    table: void 0,
    debug: false, //shows WalkontableDebugOverlay

    //presentation mode
    stretchH: 'none', //values: all, last, none
    currentRowClassName: null,
    currentColumnClassName: null,

    //data source
    data: void 0,
    offsetRow: 0,
    fixedColumnsLeft: 0,
    fixedRowsTop: 0,
    rowHeaders: function () {
      return []
    }, //this must be array of functions: [function (row, TH) {}]
    columnHeaders: function () {
      return []
    }, //this must be array of functions: [function (column, TH) {}]
    totalRows: void 0,
    totalColumns: void 0,
    width: null,
    height: null,
    cellRenderer: function (row, column, TD) {
      var cellData = that.getSetting('data', row, column);
      Handsontable.Dom.fastInnerText(TD, cellData === void 0 || cellData === null ? '' : cellData);
    },
    columnWidth: 50,
    rowHeight: function (row) {
      return 23;
    },
    defaultRowHeight: 23,
    selections: null,
    hideBorderOnMouseDownOver: false,

    //callbacks
    onCellMouseDown: null,
    onCellMouseOver: null,
//    onCellMouseOut: null,
    onCellDblClick: null,
    onCellCornerMouseDown: null,
    onCellCornerDblClick: null,
    beforeDraw: null,
    onDraw: null,
    onScrollVertically: null,
    onScrollHorizontally: null,

    //constants
    scrollbarWidth: 10,
    scrollbarHeight: 10,

    renderAllRows: false
  };

  //reference to settings
  this.settings = {};
  for (var i in this.defaults) {
    if (this.defaults.hasOwnProperty(i)) {
      if (settings[i] !== void 0) {
        this.settings[i] = settings[i];
      }
      else if (this.defaults[i] === void 0) {
        throw new Error('A required setting "' + i + '" was not provided');
      }
      else {
        this.settings[i] = this.defaults[i];
      }
    }
  }
}

/**
 * generic methods
 */

WalkontableSettings.prototype.update = function (settings, value) {
  if (value === void 0) { //settings is object
    for (var i in settings) {
      if (settings.hasOwnProperty(i)) {
        this.settings[i] = settings[i];
      }
    }
  }
  else { //if value is defined then settings is the key
    this.settings[settings] = value;
  }
  return this.instance;
};

WalkontableSettings.prototype.getSetting = function (key, param1, param2, param3, param4) {
  if (typeof this.settings[key] === 'function') {
    return this.settings[key](param1, param2, param3, param4); //this is faster than .apply - https://github.com/handsontable/jquery-handsontable/wiki/JavaScript-&-DOM-performance-tips
  }
  else if (param1 !== void 0 && Object.prototype.toString.call(this.settings[key]) === '[object Array]') { //perhaps this can be removed, it is only used in tests
    return this.settings[key][param1];
  }
  else {
    return this.settings[key];
  }
};

WalkontableSettings.prototype.has = function (key) {
  return !!this.settings[key]
};
function WalkontableTable(instance, table) {
  //reference to instance
  this.instance = instance;
  this.TABLE = table;
  Handsontable.Dom.removeTextNodes(this.TABLE);

  //wtSpreader
  var parent = this.TABLE.parentNode;
  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {
    var spreader = document.createElement('DIV');
    spreader.className = 'wtSpreader';
    if (parent) {
      parent.insertBefore(spreader, this.TABLE); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
    }
    spreader.appendChild(this.TABLE);
  }
  this.spreader = this.TABLE.parentNode;

  //wtHider
  parent = this.spreader.parentNode;
  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {
    var hider = document.createElement('DIV');
    hider.className = 'wtHider';
    if (parent) {
      parent.insertBefore(hider, this.spreader); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
    }
    hider.appendChild(this.spreader);
  }
  this.hider = this.spreader.parentNode;
  this.hiderStyle = this.hider.style;
  this.hiderStyle.position = 'relative';

  //wtHolder
  parent = this.hider.parentNode;
  if (!parent || parent.nodeType !== 1 || !Handsontable.Dom.hasClass(parent, 'wtHolder')) {
    var holder = document.createElement('DIV');
    holder.style.position = 'relative';
    holder.className = 'wtHolder';

    if(!instance.cloneSource) {
      holder.className += ' ht_master';
    }

    if (parent) {
      parent.insertBefore(holder, this.hider); //if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
    }
    holder.appendChild(this.hider);
  }
  this.holder = this.hider.parentNode;

  //bootstrap from settings
  this.TBODY = this.TABLE.getElementsByTagName('TBODY')[0];
  if (!this.TBODY) {
    this.TBODY = document.createElement('TBODY');
    this.TABLE.appendChild(this.TBODY);
  }
  this.THEAD = this.TABLE.getElementsByTagName('THEAD')[0];
  if (!this.THEAD) {
    this.THEAD = document.createElement('THEAD');
    this.TABLE.insertBefore(this.THEAD, this.TBODY);
  }
  this.COLGROUP = this.TABLE.getElementsByTagName('COLGROUP')[0];
  if (!this.COLGROUP) {
    this.COLGROUP = document.createElement('COLGROUP');
    this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
  }

  if (this.instance.getSetting('columnHeaders').length) {
    if (!this.THEAD.childNodes.length) {
      var TR = document.createElement('TR');
      this.THEAD.appendChild(TR);
    }
  }

  this.colgroupChildrenLength = this.COLGROUP.childNodes.length;
  this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;
  this.tbodyChildrenLength = this.TBODY.childNodes.length;

  this.oldCellCache = new WalkontableClassNameCache();
  this.currentCellCache = new WalkontableClassNameCache();

  this.rowFilter = null;
  this.columnFilter = null;

  this.columnWidthCache = [];
}

WalkontableTable.prototype.getRowStrategy = function () {
  return this.isWorkingOnClone() ? this.instance.cloneSource.wtTable.rowStrategy : this.rowStrategy;
};

WalkontableTable.prototype.getColumnStrategy = function () {
  return this.isWorkingOnClone() ? this.instance.cloneSource.wtTable.columnStrategy : this.columnStrategy;
};

WalkontableTable.prototype.isWorkingOnClone = function () {
  return !!this.instance.cloneSource;
};

WalkontableTable.prototype.refreshHiderDimensions = function () {
  var spreaderStyle = this.spreader.style;
  spreaderStyle.position = 'relative';
  spreaderStyle.width = 'auto';
  spreaderStyle.height = 'auto';
};

WalkontableTable.prototype.draw = function (selectionsOnly) {
  if (!selectionsOnly) {
    if (this.isWorkingOnClone()) {
      this.tableOffset = this.instance.cloneSource.wtTable.tableOffset;
    }
    else {
      this.holderOffset = Handsontable.Dom.offset(this.holder);
      this.tableOffset = Handsontable.Dom.offset(this.TABLE);
      this.instance.wtScrollbars.vertical.readSettings();
      this.instance.wtScrollbars.horizontal.readSettings();
      this.instance.wtViewport.resetSettings();
    }
    var offsetRow;
    if (this.instance.cloneOverlay instanceof WalkontableDebugOverlay) {
      offsetRow = 0;
    }
    else {
      offsetRow = this.instance.wtSettings.settings.offsetRow;
    }
    this.rowFilter = new WalkontableRowFilter(
      offsetRow,
      this.instance.getSetting('totalRows'),
      this.instance.getSetting('fixedRowsTop'),
      this.instance.getSetting('columnHeaders').length
    );
    this.columnFilter = new WalkontableColumnFilter(
      this.instance.getSetting('totalColumns'),
      this.instance.getSetting('rowHeaders').length
    );
    this._doDraw();
  }
  else {
    this.instance.wtScrollbars && this.instance.wtScrollbars.refresh(true);
  }

  this.refreshPositions(selectionsOnly);

  if (!selectionsOnly) {
    if (!this.isWorkingOnClone()) {
      this.instance.wtScrollbars.vertical.resetFixedPosition();
      this.instance.wtScrollbars.horizontal.resetFixedPosition();
      this.instance.wtScrollbars.corner.resetFixedPosition();
      this.instance.wtScrollbars.debug && this.instance.wtScrollbars.debug.resetFixedPosition();
    }
  }

  this.instance.drawn = true;
  return this;
};

WalkontableTable.prototype._doDraw = function () {
  var wtRenderer = new WalkontableTableRenderer(this);
  wtRenderer.render();
};

WalkontableTable.prototype.refreshPositions = function (selectionsOnly) {
  this.refreshHiderDimensions();
  this.refreshSelections(selectionsOnly);
};

WalkontableTable.prototype.refreshSelections = function (selectionsOnly) {
  var vr
    , r
    , vc
    , c
    , s
    , slen
    , classNames = []
    , visibleRows = this.getRowStrategy().countVisible()
    , renderedCells = this.getColumnStrategy().cellCount
    , cacheLength;


  this.oldCellCache = this.currentCellCache;
  this.currentCellCache = new WalkontableClassNameCache();

  if (this.instance.selections) {
    for (var i = 0, ilen = this.instance.selections.length; i < ilen; i++) {
      this.instance.selections[i].draw();

      if (this.instance.selections[i].settings.className) {
        classNames.push(this.instance.selections[i].settings.className);
      }
      if (this.instance.selections[i].settings.highlightRowClassName) {
        classNames.push(this.instance.selections[i].settings.highlightRowClassName);
      }
      if (this.instance.selections[i].settings.highlightColumnClassName) {
        classNames.push(this.instance.selections[i].settings.highlightColumnClassName);
      }
    }
  }

  slen = classNames.length;

  for (vr = 0; vr < visibleRows; vr++) {
    for (vc = 0; vc < renderedCells; vc++) {
      r = this.rowFilter.visibleToSource(vr);
      c = this.columnFilter.visibleToSource(vc);
      for (s = 0; s < slen; s++) {
        var cell;
        if (this.currentCellCache.test(vr, vc, classNames[s])) {
          cell = this.getCell(new WalkontableCellCoords(r, c));
          if (typeof cell == 'object' ) Handsontable.Dom.addClass(cell, classNames[s]);
        }
        else if (selectionsOnly && this.oldCellCache.test(vr, vc, classNames[s])) {
          cell = this.getCell(new WalkontableCellCoords(r, c));
          if (typeof cell == 'object' ) Handsontable.Dom.removeClass(cell, classNames[s]);

        }

        // for headers:
        // column headers
        cacheLength = this.currentCellCache.cache ? visibleRows : 0;
        cell = this.getColumnHeader(vc);
        if (this.currentCellCache.test(cacheLength, vc, classNames[s])) {
          if (typeof cell == 'object' ) Handsontable.Dom.addClass(cell,classNames[s]);
        } else {
          if (typeof cell == 'object' ) Handsontable.Dom.removeClass(cell,classNames[s]);
        }

        // row headers
        cacheLength = this.currentCellCache.cache[vr] ? renderedCells : 0;
        cell = this.getRowHeader(vr) != -1 ? this.getRowHeader(vr) : undefined;

        if (this.currentCellCache.test(vr, cacheLength, classNames[s])) {
          if (typeof cell == 'object' ) Handsontable.Dom.addClass(cell,classNames[s]);
        } else {
          if (typeof cell == 'object' ) Handsontable.Dom.removeClass(cell,classNames[s]);
       }

      }
    }
  }

};

/**
 * getCell
 * @param {WalkontableCellCoords} coords
 * @return {Object} HTMLElement on success or {Number} one of the exit codes on error:
 *  -1 row before viewport
 *  -2 row after viewport
 *
 */
WalkontableTable.prototype.getCell = function (coords) {
  if (this.isRowBeforeViewport(coords.row)) {
    return -1; //row before viewport
  }
  else if (this.isRowAfterViewport(coords.row)) {
    return -2; //row after viewport
  }

  var TR = this.TBODY.childNodes[this.rowFilter.sourceToVisible(coords.row)];

  if (TR) {
    return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(coords.col)];
  }
};

/**
 * getColumnHeader
 * @param col
 * @return {Object} HTMLElement on success or undefined on error
 *
 */
WalkontableTable.prototype.getColumnHeader = function(col) {
  var THEAD = this.THEAD.childNodes[0];
  if (THEAD) {
    return THEAD.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
  }
}

/**
 * getRowHeader
 * @param col
 * @return {Object} HTMLElement on success or {Number} one of the exit codes on error:
 *  -1 table doesn't have row headers
 *
 */
WalkontableTable.prototype.getRowHeader = function(row) {
  if(this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) == 0) {
    return -1;
  }

  var TR = this.TBODY.childNodes[this.rowFilter.sourceToVisible(row)];

  if (TR) {
    return TR.childNodes[0];
  }
}

/**
 * Returns cell coords object for a given TD
 * @param TD
 * @returns {WalkontableCellCoords}
 */
WalkontableTable.prototype.getCoords = function (TD) {
  var TR = TD.parentNode;
  var row = Handsontable.Dom.index(TR);
  if (TR.parentNode === this.THEAD) {
    row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
  }
  else {
    row = this.rowFilter.visibleToSource(row);
  }

  return new WalkontableCellCoords(
    row,
    this.columnFilter.visibleRowHeadedColumnToSourceColumn(TD.cellIndex)
  );
};

//returns -1 if no row is visible
WalkontableTable.prototype.getFirstVisibleRow = function () {
  return this.rowFilter.visibleToSource(0 + this.rowFilter.fixedCount);
};

//returns -1 if no column is visible
WalkontableTable.prototype.getFirstVisibleColumn = function () {

  if (this.isWorkingOnClone()){
    if (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative){
      return 0;
    } else {
      return this.instance.cloneSource.wtTable.getFirstVisibleColumn();
    }
  }

  var leftOffset = this.instance.wtScrollbars.horizontal.getScrollPosition();
  var columnCount = this.getColumnStrategy().cellCount;
  var firstTR = this.TBODY.firstChild;

  if (!firstTR){
    return 0;
  }

  for (var colIndex = 0; colIndex < columnCount; colIndex++){
    leftOffset -= firstTR.childNodes[colIndex].offsetWidth;

    if (leftOffset < 0){
      return colIndex;
    }

  }

  return -1;
};

//returns -1 if no row is visible
WalkontableTable.prototype.getLastVisibleRow = function () {
  var lastVisibleRow =  this.rowFilter.visibleToSource(this.getRowStrategy().countVisible() - 1);
  var instance = this.instance;

  if (instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
    var fixedRowsTop = this.instance.getSetting('fixedRowsTop');

    return Math.min(fixedRowsTop - 1, lastVisibleRow);
  } else {
    return lastVisibleRow;
  }

};

//returns -1 if no column is visible
WalkontableTable.prototype.getLastVisibleColumn = function () {
  var instance = this.instance;

  if (this.isWorkingOnClone()){

    if (instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || instance.cloneOverlay instanceof WalkontableCornerScrollbarNative){
      var lastVisibleColumn = this.getColumnStrategy().countVisible() - 1;
      var fixedColumnsLeft =  instance.getSetting('fixedColumnsLeft');
      return Math.min(fixedColumnsLeft - 1, lastVisibleColumn);
    } else {
      return this.instance.cloneSource.wtTable.getLastVisibleColumn();
    }

  }


  var leftOffset = this.instance.wtScrollbars.horizontal.getScrollPosition();
  var leftPartOfTable = leftOffset + this.instance.wtViewport.getWorkspaceWidth(Infinity);
  var columnCount = this.getColumnStrategy().cellCount;
  var rowHeaderCount = this.instance.getSetting('rowHeaders').length || 0;
  var firstTR = this.TBODY.firstChild;

  if (!columnCount) {
    return -1;
  }

  for (var colIndex = 0; colIndex < columnCount + rowHeaderCount; colIndex++){
    leftPartOfTable -= firstTR.childNodes[colIndex].offsetWidth;

    if (leftPartOfTable <= 0){
      return colIndex - rowHeaderCount;
    }

  }

  return colIndex - rowHeaderCount - 1;
};

WalkontableTable.prototype.isRowBeforeViewport = function (r) {
  return (this.rowFilter.sourceToVisible(r) < this.rowFilter.fixedCount && r >= this.rowFilter.fixedCount);
};

WalkontableTable.prototype.isRowAfterViewport = function (r) {
  return (r > this.getLastVisibleRow());
};

WalkontableTable.prototype.isColumnBeforeViewport = function (c) {
  return (this.columnFilter.sourceToVisible(c) < this.columnFilter.fixedCount && c >= this.columnFilter.fixedCount);
};

WalkontableTable.prototype.isColumnAfterViewport = function (c) {
  return (c > this.getLastVisibleColumn());
};

WalkontableTable.prototype.isRowInViewport = function (r) {
  return (!this.isRowBeforeViewport(r) && !this.isRowAfterViewport(r));
};

WalkontableTable.prototype.isColumnInViewport = function (c) {
  return (!this.isColumnBeforeViewport(c) && !this.isColumnAfterViewport(c));
};

WalkontableTable.prototype.isLastRowFullyVisible = function () {
  return (this.getLastVisibleRow() === this.instance.getSetting('totalRows') - 1 && !this.getRowStrategy().isLastIncomplete());
};

WalkontableTable.prototype.isLastColumnFullyVisible = function () {
  return (this.getLastVisibleColumn() === this.instance.getSetting('totalColumns') - 1 && !this.getColumnStrategy().isLastIncomplete());
};

WalkontableTable.prototype.getVisibleRowsCount = function () {
  return this.getRowStrategy().countVisible();
};

WalkontableTable.prototype.allRowsInViewport = function () {
  return this.getRowStrategy().cellCount == this.getVisibleRowsCount();
};

function WalkontableTableRenderer(wtTable){
  this.wtTable = wtTable;
  this.instance = wtTable.instance;
  this.rowFilter = wtTable.rowFilter;
  this.columnFilter = wtTable.columnFilter;

  this.TABLE = wtTable.TABLE;
  this.THEAD = wtTable.THEAD;
  this.TBODY = wtTable.TBODY;
  this.COLGROUP = wtTable.COLGROUP;

  this.utils = WalkontableTableRenderer.utils;

}

  WalkontableTableRenderer.prototype.render = function () {
    if (!this.wtTable.isWorkingOnClone()) {
      this.instance.getSetting('beforeDraw', true);
    }

    this.rowHeaders = this.instance.getSetting('rowHeaders');
    this.rowHeaderCount = this.rowHeaders.length;
    this.fixedRowsTop = this.instance.getSetting('fixedRowsTop');
    this.columnHeaders = this.instance.getSetting('columnHeaders');

  var visibleColIndex
    , totalRows = this.instance.getSetting('totalRows')
    , totalColumns = this.instance.getSetting('totalColumns')
    , displayTds
    , TR
    , TD
    , TH
    , adjusted = false
    , workspaceWidth
    , res;

  if (totalColumns > 0) {
    var cloneLimit;
    if (this.wtTable.isWorkingOnClone()) { //must be run after adjustAvailableNodes because otherwise this.rowStrategy is not yet defined
      if (this.instance.cloneOverlay instanceof WalkontableVerticalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative) {
        cloneLimit = this.fixedRowsTop;
      }
      else if (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative) {
        cloneLimit = this.wtTable.getRowStrategy().cellCount;
      }
      //else if WalkontableDebugOverlay do nothing. No cloneLimit means render ALL rows
    }

    this.adjustAvailableNodes();
    adjusted = true;

    this.renderColGroups();

    this.renderColumnHeaders();

    displayTds = this.getColumnCount();

    //Render table rows
    this.renderRows(totalRows, cloneLimit, displayTds);

    if (!this.wtTable.isWorkingOnClone()) {
      workspaceWidth = this.instance.wtViewport.getWorkspaceWidth();
      this.instance.wtViewport.containerWidth = null;
      this.wtTable.getColumnStrategy().stretch();
    }

    this.adjustColumnWidths(displayTds);
  }

  if (!adjusted) {
    this.adjustAvailableNodes();
  }

  if (!(this.instance.cloneOverlay instanceof WalkontableDebugOverlay)) {
    this.removeRedundantRows();
  }



  if (!this.wtTable.isWorkingOnClone()) {

    this.instance.wtScrollbars.refresh(false);

    if (workspaceWidth !== this.instance.wtViewport.getWorkspaceWidth()) {
      //workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching
      this.instance.wtViewport.containerWidth = null;
      this.wtTable.getColumnStrategy().stretch();
      for (visibleColIndex = 0; visibleColIndex < this.wtTable.getColumnStrategy().cellCount; visibleColIndex++) {
        this.COLGROUP.childNodes[visibleColIndex + this.rowHeaderCount].style.width = this.wtTable.getColumnStrategy().getSize(visibleColIndex) + 'px';
      }
    }
    this.instance.getSetting('onDraw', true);
  }

};

WalkontableTableRenderer.prototype.removeRedundantRows = function () {
  var renderedRowIndex = this.wtTable.getRowStrategy().countRendered();
  while (this.wtTable.tbodyChildrenLength > renderedRowIndex) {
    this.TBODY.removeChild(this.TBODY.lastChild);
    this.wtTable.tbodyChildrenLength--;
  }
};

WalkontableTableRenderer.prototype.renderRows = function (totalRows, cloneLimit, displayTds) {
  var lastTD, TR, res;
  var offsetRow = this.instance.getSetting('offsetRow');
  var visibleRowIndex = 0;
  var sourceRowIndex = this.rowFilter.visibleToSource(visibleRowIndex);
  var isWorkingOnClone = this.wtTable.isWorkingOnClone();

  while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {
    if (visibleRowIndex > 1000) {
      throw new Error('Security brake: Too much TRs. Please define height for your table, which will enforce scrollbars.');
    }

    if (cloneLimit !== void 0 && visibleRowIndex === cloneLimit) {
      break; //we have as much rows as needed for this clone
    }

    TR = this.getTrForRow(visibleRowIndex, TR);

    //Render row headers
    this.renderRowHeaders(sourceRowIndex, TR);

    this.adjustColumns(TR, displayTds + this.rowHeaderCount);

    lastTD = this.renderCells(sourceRowIndex, TR, displayTds);

    offsetRow = this.instance.getSetting('offsetRow'); //refresh the value

    //after last column is rendered, check if last cell is fully displayed
    if (!isWorkingOnClone) {
      res = this.wtTable.getRowStrategy().add(visibleRowIndex, lastTD);

      if (res === false) {
        break;
      }

      if (visibleRowIndex == 0) { //rendering the first row may caused bottom scrollbar to appear, so we need to refresh the window size
        this.instance.wtScrollbars.vertical.readWindowSize();
      }
    }

    if (TR.firstChild) {
      var height = this.instance.getSetting('rowHeight', sourceRowIndex); //if I have 2 fixed columns with one-line content and the 3rd column has a multiline content, this is the way to make sure that the overlay will has same row height
      if(height) {
        TR.firstChild.style.height = height + 'px';
      }
      else {
        TR.firstChild.style.height = '';
      }
    }

    visibleRowIndex++;

    sourceRowIndex = this.rowFilter.visibleToSource(visibleRowIndex);
  }
};


WalkontableTableRenderer.prototype.renderCells = function (sourceRowIndex, TR, displayTds) {
  var TD, sourceColIndex;
  for (var visibleColIndex = 0; visibleColIndex < displayTds; visibleColIndex++) {
    sourceColIndex = this.columnFilter.visibleToSource(visibleColIndex);
    if (visibleColIndex === 0) {
      TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];
    }
    else {
      TD = TD.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
    }

    //If the number of headers has been reduced, we need to replace excess TH with TD
    if (TD.nodeName == 'TH') {
      TD = this.utils.replaceThWithTd(TD, TR);
    }

    TD.className = '';
    TD.removeAttribute('style');

    this.instance.getSetting('cellRenderer', sourceRowIndex, sourceColIndex, TD);

  }

  return TD;
};

WalkontableTableRenderer.prototype.adjustColumnWidths = function (displayTds) {
  var cache = this.instance.wtTable.columnWidthCache;
  var cacheChanged = false;
  var width;
  for (var visibleColIndex = 0; visibleColIndex < displayTds; visibleColIndex++) {
    if(this.wtTable.isWorkingOnClone()) {
      width = this.instance.cloneSource.wtTable.columnWidthCache[visibleColIndex];
    }
    else {
      width = this.wtTable.getColumnStrategy().getSize(visibleColIndex);
    }
    if (width !== cache[visibleColIndex]) {
      this.COLGROUP.childNodes[visibleColIndex + this.rowHeaderCount].style.width = width + 'px';
      cache[visibleColIndex] = width;
      cacheChanged = true;
    }
  }
};

WalkontableTableRenderer.prototype.appendToTbody = function (TR) {
  this.TBODY.appendChild(TR);
  this.wtTable.tbodyChildrenLength++;
};

WalkontableTableRenderer.prototype.getTrForRow = function (rowIndex, currentTr) {
  var TR;

  if (rowIndex >= this.wtTable.tbodyChildrenLength) {
    TR = this.createRow();
    this.appendToTbody(TR);
  } else if (rowIndex === 0) {
    TR = this.TBODY.firstChild;
  } else {
    TR = currentTr.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
  }

  return TR;
};

WalkontableTableRenderer.prototype.createRow = function() {
  var TR = document.createElement('TR');
  for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
    TR.appendChild(document.createElement('TH'));
  }

  return TR;
};

WalkontableTableRenderer.prototype.renderRowHeader = function(row, col, TH){
  this.rowHeaders[col](row, TH);
};

WalkontableTableRenderer.prototype.renderRowHeaders = function(row, TR){
  for (var TH = TR.firstChild, visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {

    //If the number of row headers increased we need to create TH or replace an existing TD node with TH
    if (!TH){
      TH = document.createElement('TH');
      TR.appendChild(TH);
    } else if (TH.nodeName == 'TD') {
      TH = this.utils.replaceTdWithTh(TH, TR);
    }

    this.renderRowHeader(row, visibleColIndex, TH);
    TH = TH.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
  }
};

WalkontableTableRenderer.prototype.adjustAvailableNodes = function () {

  this.refreshStretching(); //actually it is wrong position because it assumes rowHeader would be always 50px wide (because we measure before it is filled with text). TODO: debug

  //adjust COLGROUP
  this.adjustColGroups();

  //adjust THEAD
  this.adjustThead();

};

WalkontableTableRenderer.prototype.renderColumnHeaders = function () {
  if (!this.columnHeaders.length) {
    return;
  }

  var columnCount = this.getColumnCount();

  var TR = this.getTrForColumnHeaders();

  for (var columnIndex = 0; columnIndex < columnCount; columnIndex++) {
    if (this.columnHeaders.length) {
     this.renderColumnHeader( this.columnFilter.visibleToSource(columnIndex), TR.childNodes[this.rowHeaderCount + columnIndex]);
    }
  }
};

WalkontableTableRenderer.prototype.adjustColGroups = function () {
  var columnCount = this.getColumnCount();

  //adjust COLGROUP
  while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {
    this.COLGROUP.appendChild(document.createElement('COL'));
    this.wtTable.colgroupChildrenLength++;
  }
  while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {
    this.COLGROUP.removeChild(this.COLGROUP.lastChild);
    this.wtTable.colgroupChildrenLength--;
  }
};

WalkontableTableRenderer.prototype.adjustThead = function () {
  var columnCount = this.getColumnCount();
  var TR = this.THEAD.firstChild;
  if (this.columnHeaders.length) {
    if (!TR) {
      TR = document.createElement('TR');
      this.THEAD.appendChild(TR);
    }

    this.theadChildrenLength = TR.childNodes.length;
    while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {
      TR.appendChild(document.createElement('TH'));
      this.theadChildrenLength++;
    }
    while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {
      TR.removeChild(TR.lastChild);
      this.theadChildrenLength--;
    }
  }
  else if (TR) {
    Handsontable.Dom.empty(TR);
  }
};

WalkontableTableRenderer.prototype.getTrForColumnHeaders = function () {
  var TR = this.THEAD.firstChild;
  if (this.rowHeaderCount) {
    this.renderRowHeaders(-1, TR);
  }

  return TR;
};

WalkontableTableRenderer.prototype.renderColumnHeader = function (col, TR) {
  return this.columnHeaders[0](col, TR);
};

WalkontableTableRenderer.prototype.getColumnCount = function () {
  if (this.wtTable.isWorkingOnClone() && (this.instance.cloneOverlay instanceof WalkontableHorizontalScrollbarNative || this.instance.cloneOverlay instanceof WalkontableCornerScrollbarNative)) {
    return this.instance.getSetting('fixedColumnsLeft');
  }
  else {
    return this.wtTable.getColumnStrategy().cellCount;
  }
};

WalkontableTableRenderer.prototype.renderColGroups = function () {
  for (var colIndex = 0; colIndex < this.wtTable.colgroupChildrenLength; colIndex++) {
    if (colIndex < this.rowHeaderCount) {
      Handsontable.Dom.addClass(this.COLGROUP.childNodes[colIndex], 'rowHeader');
    }
    else {
      Handsontable.Dom.removeClass(this.COLGROUP.childNodes[colIndex], 'rowHeader');
    }
  }
};

WalkontableTableRenderer.prototype.adjustColumns = function (TR, desiredCount) {
  var count = TR.childNodes.length;
  while (count < desiredCount) {
    var TD = document.createElement('TD');
    TR.appendChild(TD);
    count++;
  }
  while (count > desiredCount) {
    TR.removeChild(TR.lastChild);
    count--;
  }
};

WalkontableTableRenderer.prototype.refreshStretching = function () {
  if (this.wtTable.isWorkingOnClone()) {
    return;
  }

  var instance = this.instance
    , stretchH = instance.getSetting('stretchH')
    , totalRows = instance.getSetting('totalRows')
    , totalColumns = instance.getSetting('totalColumns');

  var containerWidthFn = function (cacheWidth) {
    var viewportWidth = that.instance.wtViewport.getViewportWidth(cacheWidth);
    return viewportWidth;
  };

  var that = this;

  var columnWidthFn = function (i) {
    var source_c = that.columnFilter.visibleToSource(i);
    if (source_c < totalColumns) {
      return instance.getSetting('columnWidth', source_c);
    }
  };

  var containerHeightFn = function (cacheHeight) {
    if (that.instance.cloneOverlay instanceof WalkontableDebugOverlay || instance.wtSettings.settings.renderAllRows) {
      return Infinity;
    }
    else {
      return that.instance.wtViewport.getViewportHeight(cacheHeight);
    }
  };

  var rowHeightFn = function (i, TD) {
    return instance.wtSettings.settings.defaultRowHeight;
  };

  this.wtTable.columnStrategy = new WalkontableColumnStrategy(instance, containerWidthFn, columnWidthFn, stretchH);
  this.wtTable.rowStrategy = new WalkontableRowStrategy(instance, containerHeightFn, rowHeightFn);
};

/*
  Helper functions, which does not have any side effects
 */
WalkontableTableRenderer.utils = {};

WalkontableTableRenderer.utils.replaceTdWithTh = function(TD, TR) {
  var TH;
  TH = document.createElement('TH');
  TR.insertBefore(TH, TD);
  TR.removeChild(TD);

  return TH;
};

WalkontableTableRenderer.utils.replaceThWithTd = function(TH, TR) {
  var TD = document.createElement('TD');
  TR.insertBefore(TD, TH);
  TR.removeChild(TH);

  return TD;
};



function WalkontableViewport(instance) {
  this.instance = instance;
  this.resetSettings();

  var that = this;
  $(window).on('resize.walkontable.' + this.instance.guid, function () {
    that.clientHeight = that.getWorkspaceHeight();
  });
}

//used by scrollbar
WalkontableViewport.prototype.getWorkspaceHeight = function (proposedHeight) {
  return this.instance.wtScrollbars.vertical.windowSize;
};

WalkontableViewport.prototype.getWorkspaceWidth = function (proposedWidth) {
  if (this.instance.wtScrollbars.horizontal.scrollHandler === window){
    return Math.min(this.getContainerFillWidth(), document.documentElement.offsetWidth - this.getWorkspaceOffset().left, document.documentElement.offsetWidth);
  }

  return this.instance.wtScrollbars.horizontal.windowSize;

};

WalkontableViewport.prototype.getContainerFillWidth = function() {

  if(this.containerWidth) {
    return this.containerWidth;
  }

  var mainContainer = this.instance.wtTable.holder,
      fillWidth,
      dummyElement;

  while(mainContainer.parentNode != document.body && mainContainer.parentNode != null && mainContainer.className.indexOf('handsontable') === -1) {
    mainContainer = mainContainer.parentNode;
  }

  dummyElement = document.createElement("DIV");
  dummyElement.style.width = "100%";
  dummyElement.style.height = "1px";
  mainContainer.appendChild(dummyElement);
  fillWidth = dummyElement.offsetWidth;

  this.containerWidth = fillWidth;

  mainContainer.removeChild(dummyElement);

  return fillWidth;
}

WalkontableViewport.prototype.getWorkspaceOffset = function () {
  return Handsontable.Dom.offset(this.instance.wtTable.TABLE);
};

WalkontableViewport.prototype.getWorkspaceActualHeight = function () {
  return Handsontable.Dom.outerHeight(this.instance.wtTable.TABLE);
};

WalkontableViewport.prototype.getWorkspaceActualWidth = function () {
  return Handsontable.Dom.outerWidth(this.instance.wtTable.TABLE) || Handsontable.Dom.outerWidth(this.instance.wtTable.TBODY) || Handsontable.Dom.outerWidth(this.instance.wtTable.THEAD); //IE8 reports 0 as <table> offsetWidth;
};

WalkontableViewport.prototype.getColumnHeaderHeight = function () {
  if (isNaN(this.columnHeaderHeight)) {
    var cellOffset = Handsontable.Dom.offset(this.instance.wtTable.TBODY)
      , tableOffset = this.instance.wtTable.tableOffset;
    this.columnHeaderHeight = cellOffset.top - tableOffset.top;
  }
  return this.columnHeaderHeight;
};

WalkontableViewport.prototype.getViewportHeight = function (proposedHeight) {

  var containerHeight = this.getWorkspaceHeight(proposedHeight);

  if (containerHeight === Infinity) {
    return containerHeight;
  }

  var columnHeaderHeight = this.getColumnHeaderHeight();
  if (columnHeaderHeight > 0) {
    containerHeight -= columnHeaderHeight;
  }

  return containerHeight;

};

WalkontableViewport.prototype.getRowHeaderWidth = function () {
  if (this.instance.cloneSource) {
    return this.instance.cloneSource.wtViewport.getRowHeaderWidth();
  }
  if (isNaN(this.rowHeaderWidth)) {
    var rowHeaders = this.instance.getSetting('rowHeaders');
    if (rowHeaders.length) {
      var TH = this.instance.wtTable.TABLE.querySelector('TH');
      this.rowHeaderWidth = 0;
      for (var i = 0, ilen = rowHeaders.length; i < ilen; i++) {
        if (TH) {
          this.rowHeaderWidth += Handsontable.Dom.outerWidth(TH);
          TH = TH.nextSibling;
        }
        else {
          this.rowHeaderWidth += 50; //yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring. TODO: proper fix
        }
      }
    }
    else {
      this.rowHeaderWidth = 0;
    }
  }
  return this.rowHeaderWidth;
};

// Viewport width = Workspace width - Row Headers width
WalkontableViewport.prototype.getViewportWidth = function (proposedWidth) {
  var containerWidth = this.getWorkspaceWidth(proposedWidth);

  if (containerWidth === Infinity) {
    return containerWidth;
  }

  var rowHeaderWidth = this.getRowHeaderWidth();
  if (rowHeaderWidth > 0) {
    return containerWidth - rowHeaderWidth;
  }
  else {
    return containerWidth;
  }
};

WalkontableViewport.prototype.resetSettings = function () {
  this.rowHeaderWidth = NaN;
  this.columnHeaderHeight = NaN;
};
})(jQuery, window, Handsontable);
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;
            
        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);
        
        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };
    
    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }
        
        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }
        
        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';
            
            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            
            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    
    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }        


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this, 
                  inputString ? inputString : defaultFormat, 
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') { 
                return inputString; 
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;            
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);            
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(this);

/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/
(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return"rgb("+[o.r,o.g,o.b].join(",")+")"}else{return"rgba("+[o.r,o.g,o.b,o.a].join(",")+")"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=""&&c!="transparent")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),"body"));if(c=="rgba(0, 0, 0, 0)")c="transparent";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name=="transparent")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);(function($){var hasOwnProperty=Object.prototype.hasOwnProperty;if(!$.fn.detach){$.fn.detach=function(){return this.each(function(){if(this.parentNode){this.parentNode.removeChild(this)}})}}function Canvas(cls,container){var element=container.children("."+cls)[0];if(element==null){element=document.createElement("canvas");element.className=cls;$(element).css({direction:"ltr",position:"absolute",left:0,top:0}).appendTo(container);if(!element.getContext){if(window.G_vmlCanvasManager){element=window.G_vmlCanvasManager.initElement(element)}else{throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.")}}}this.element=element;var context=this.context=element.getContext("2d");var devicePixelRatio=window.devicePixelRatio||1,backingStoreRatio=context.webkitBackingStorePixelRatio||context.mozBackingStorePixelRatio||context.msBackingStorePixelRatio||context.oBackingStorePixelRatio||context.backingStorePixelRatio||1;this.pixelRatio=devicePixelRatio/backingStoreRatio;this.resize(container.width(),container.height());this.textContainer=null;this.text={};this._textCache={}}Canvas.prototype.resize=function(width,height){if(width<=0||height<=0){throw new Error("Invalid dimensions for plot, width = "+width+", height = "+height)}var element=this.element,context=this.context,pixelRatio=this.pixelRatio;if(this.width!=width){element.width=width*pixelRatio;element.style.width=width+"px";this.width=width}if(this.height!=height){element.height=height*pixelRatio;element.style.height=height+"px";this.height=height}context.restore();context.save();context.scale(pixelRatio,pixelRatio)};Canvas.prototype.clear=function(){this.context.clearRect(0,0,this.width,this.height)};Canvas.prototype.render=function(){var cache=this._textCache;for(var layerKey in cache){if(hasOwnProperty.call(cache,layerKey)){var layer=this.getTextLayer(layerKey),layerCache=cache[layerKey];layer.hide();for(var styleKey in layerCache){if(hasOwnProperty.call(layerCache,styleKey)){var styleCache=layerCache[styleKey];for(var key in styleCache){if(hasOwnProperty.call(styleCache,key)){var positions=styleCache[key].positions;for(var i=0,position;position=positions[i];i++){if(position.active){if(!position.rendered){layer.append(position.element);position.rendered=true}}else{positions.splice(i--,1);if(position.rendered){position.element.detach()}}}if(positions.length==0){delete styleCache[key]}}}}}layer.show()}}};Canvas.prototype.getTextLayer=function(classes){var layer=this.text[classes];if(layer==null){if(this.textContainer==null){this.textContainer=$("<div class='flot-text'></div>").css({position:"absolute",top:0,left:0,bottom:0,right:0,"font-size":"smaller",color:"#545454"}).insertAfter(this.element)}layer=this.text[classes]=$("<div></div>").addClass(classes).css({position:"absolute",top:0,left:0,bottom:0,right:0}).appendTo(this.textContainer)}return layer};Canvas.prototype.getTextInfo=function(layer,text,font,angle,width){var textStyle,layerCache,styleCache,info;text=""+text;if(typeof font==="object"){textStyle=font.style+" "+font.variant+" "+font.weight+" "+font.size+"px/"+font.lineHeight+"px "+font.family}else{textStyle=font}layerCache=this._textCache[layer];if(layerCache==null){layerCache=this._textCache[layer]={}}styleCache=layerCache[textStyle];if(styleCache==null){styleCache=layerCache[textStyle]={}}info=styleCache[text];if(info==null){var element=$("<div></div>").html(text).css({position:"absolute","max-width":width,top:-9999}).appendTo(this.getTextLayer(layer));if(typeof font==="object"){element.css({font:textStyle,color:font.color})}else if(typeof font==="string"){element.addClass(font)}info=styleCache[text]={width:element.outerWidth(true),height:element.outerHeight(true),element:element,positions:[]};element.detach()}return info};Canvas.prototype.addText=function(layer,x,y,text,font,angle,width,halign,valign){var info=this.getTextInfo(layer,text,font,angle,width),positions=info.positions;if(halign=="center"){x-=info.width/2}else if(halign=="right"){x-=info.width}if(valign=="middle"){y-=info.height/2}else if(valign=="bottom"){y-=info.height}for(var i=0,position;position=positions[i];i++){if(position.x==x&&position.y==y){position.active=true;return}}position={active:true,rendered:false,element:positions.length?info.element.clone():info.element,x:x,y:y};positions.push(position);position.element.css({top:Math.round(y),left:Math.round(x),"text-align":halign})};Canvas.prototype.removeText=function(layer,x,y,text,font,angle){if(text==null){var layerCache=this._textCache[layer];if(layerCache!=null){for(var styleKey in layerCache){if(hasOwnProperty.call(layerCache,styleKey)){var styleCache=layerCache[styleKey];for(var key in styleCache){if(hasOwnProperty.call(styleCache,key)){var positions=styleCache[key].positions;for(var i=0,position;position=positions[i];i++){position.active=false}}}}}}}else{var positions=this.getTextInfo(layer,text,font,angle).positions;for(var i=0,position;position=positions[i];i++){if(position.x==x&&position.y==y){position.active=false}}}};function Plot(placeholder,data_,options_,plugins){var series=[],options={colors:["#edc240","#afd8f8","#cb4b4b","#4da74d","#9440ed"],legend:{show:true,noColumns:1,labelFormatter:null,labelBoxBorderColor:"#ccc",container:null,position:"ne",margin:5,backgroundColor:null,backgroundOpacity:.85,sorted:null},xaxis:{show:null,position:"bottom",mode:null,font:null,color:null,tickColor:null,transform:null,inverseTransform:null,min:null,max:null,autoscaleMargin:null,ticks:null,tickFormatter:null,labelWidth:null,labelHeight:null,reserveSpace:null,tickLength:null,alignTicksWithAxis:null,tickDecimals:null,tickSize:null,minTickSize:null},yaxis:{autoscaleMargin:.02,position:"left"},xaxes:[],yaxes:[],series:{points:{show:false,radius:3,lineWidth:2,fill:true,fillColor:"#ffffff",symbol:"circle"},lines:{lineWidth:2,fill:false,fillColor:null,steps:false},bars:{show:false,lineWidth:2,barWidth:1,fill:true,fillColor:null,align:"left",horizontal:false,zero:true},shadowSize:3,highlightColor:null},grid:{show:true,aboveData:false,color:"#545454",backgroundColor:null,borderColor:null,tickColor:null,margin:0,labelMargin:5,axisMargin:8,borderWidth:2,minBorderMargin:null,markings:null,markingsColor:"#f4f4f4",markingsLineWidth:2,clickable:false,hoverable:false,autoHighlight:true,mouseActiveRadius:10},interaction:{redrawOverlayInterval:1e3/60},hooks:{}},surface=null,overlay=null,eventHolder=null,ctx=null,octx=null,xaxes=[],yaxes=[],plotOffset={left:0,right:0,top:0,bottom:0},plotWidth=0,plotHeight=0,hooks={processOptions:[],processRawData:[],processDatapoints:[],processOffset:[],drawBackground:[],drawSeries:[],draw:[],bindEvents:[],drawOverlay:[],shutdown:[]},plot=this;plot.setData=setData;plot.setupGrid=setupGrid;plot.draw=draw;plot.getPlaceholder=function(){return placeholder};plot.getCanvas=function(){return surface.element};plot.getPlotOffset=function(){return plotOffset};plot.width=function(){return plotWidth};plot.height=function(){return plotHeight};plot.offset=function(){var o=eventHolder.offset();o.left+=plotOffset.left;o.top+=plotOffset.top;return o};plot.getData=function(){return series};plot.getAxes=function(){var res={},i;$.each(xaxes.concat(yaxes),function(_,axis){if(axis)res[axis.direction+(axis.n!=1?axis.n:"")+"axis"]=axis});return res};plot.getXAxes=function(){return xaxes};plot.getYAxes=function(){return yaxes};plot.c2p=canvasToAxisCoords;plot.p2c=axisToCanvasCoords;plot.getOptions=function(){return options};plot.highlight=highlight;plot.unhighlight=unhighlight;plot.triggerRedrawOverlay=triggerRedrawOverlay;plot.pointOffset=function(point){return{left:parseInt(xaxes[axisNumber(point,"x")-1].p2c(+point.x)+plotOffset.left,10),top:parseInt(yaxes[axisNumber(point,"y")-1].p2c(+point.y)+plotOffset.top,10)}};plot.shutdown=shutdown;plot.destroy=function(){shutdown();placeholder.removeData("plot").empty();series=[];options=null;surface=null;overlay=null;eventHolder=null;ctx=null;octx=null;xaxes=[];yaxes=[];hooks=null;highlights=[];plot=null};plot.resize=function(){var width=placeholder.width(),height=placeholder.height();surface.resize(width,height);overlay.resize(width,height)};plot.hooks=hooks;initPlugins(plot);parseOptions(options_);setupCanvases();setData(data_);setupGrid();draw();bindEvents();function executeHooks(hook,args){args=[plot].concat(args);for(var i=0;i<hook.length;++i)hook[i].apply(this,args)}function initPlugins(){var classes={Canvas:Canvas};for(var i=0;i<plugins.length;++i){var p=plugins[i];p.init(plot,classes);if(p.options)$.extend(true,options,p.options)}}function parseOptions(opts){$.extend(true,options,opts);if(opts&&opts.colors){options.colors=opts.colors}if(options.xaxis.color==null)options.xaxis.color=$.color.parse(options.grid.color).scale("a",.22).toString();if(options.yaxis.color==null)options.yaxis.color=$.color.parse(options.grid.color).scale("a",.22).toString();if(options.xaxis.tickColor==null)options.xaxis.tickColor=options.grid.tickColor||options.xaxis.color;if(options.yaxis.tickColor==null)options.yaxis.tickColor=options.grid.tickColor||options.yaxis.color;if(options.grid.borderColor==null)options.grid.borderColor=options.grid.color;if(options.grid.tickColor==null)options.grid.tickColor=$.color.parse(options.grid.color).scale("a",.22).toString();var i,axisOptions,axisCount,fontSize=placeholder.css("font-size"),fontSizeDefault=fontSize?+fontSize.replace("px",""):13,fontDefaults={style:placeholder.css("font-style"),size:Math.round(.8*fontSizeDefault),variant:placeholder.css("font-variant"),weight:placeholder.css("font-weight"),family:placeholder.css("font-family")};axisCount=options.xaxes.length||1;for(i=0;i<axisCount;++i){axisOptions=options.xaxes[i];if(axisOptions&&!axisOptions.tickColor){axisOptions.tickColor=axisOptions.color}axisOptions=$.extend(true,{},options.xaxis,axisOptions);options.xaxes[i]=axisOptions;if(axisOptions.font){axisOptions.font=$.extend({},fontDefaults,axisOptions.font);if(!axisOptions.font.color){axisOptions.font.color=axisOptions.color}if(!axisOptions.font.lineHeight){axisOptions.font.lineHeight=Math.round(axisOptions.font.size*1.15)}}}axisCount=options.yaxes.length||1;for(i=0;i<axisCount;++i){axisOptions=options.yaxes[i];if(axisOptions&&!axisOptions.tickColor){axisOptions.tickColor=axisOptions.color}axisOptions=$.extend(true,{},options.yaxis,axisOptions);options.yaxes[i]=axisOptions;if(axisOptions.font){axisOptions.font=$.extend({},fontDefaults,axisOptions.font);if(!axisOptions.font.color){axisOptions.font.color=axisOptions.color}if(!axisOptions.font.lineHeight){axisOptions.font.lineHeight=Math.round(axisOptions.font.size*1.15)}}}if(options.xaxis.noTicks&&options.xaxis.ticks==null)options.xaxis.ticks=options.xaxis.noTicks;if(options.yaxis.noTicks&&options.yaxis.ticks==null)options.yaxis.ticks=options.yaxis.noTicks;if(options.x2axis){options.xaxes[1]=$.extend(true,{},options.xaxis,options.x2axis);options.xaxes[1].position="top";if(options.x2axis.min==null){options.xaxes[1].min=null}if(options.x2axis.max==null){options.xaxes[1].max=null}}if(options.y2axis){options.yaxes[1]=$.extend(true,{},options.yaxis,options.y2axis);options.yaxes[1].position="right";if(options.y2axis.min==null){options.yaxes[1].min=null}if(options.y2axis.max==null){options.yaxes[1].max=null}}if(options.grid.coloredAreas)options.grid.markings=options.grid.coloredAreas;if(options.grid.coloredAreasColor)options.grid.markingsColor=options.grid.coloredAreasColor;if(options.lines)$.extend(true,options.series.lines,options.lines);if(options.points)$.extend(true,options.series.points,options.points);if(options.bars)$.extend(true,options.series.bars,options.bars);if(options.shadowSize!=null)options.series.shadowSize=options.shadowSize;if(options.highlightColor!=null)options.series.highlightColor=options.highlightColor;for(i=0;i<options.xaxes.length;++i)getOrCreateAxis(xaxes,i+1).options=options.xaxes[i];for(i=0;i<options.yaxes.length;++i)getOrCreateAxis(yaxes,i+1).options=options.yaxes[i];for(var n in hooks)if(options.hooks[n]&&options.hooks[n].length)hooks[n]=hooks[n].concat(options.hooks[n]);executeHooks(hooks.processOptions,[options])}function setData(d){series=parseData(d);fillInSeriesOptions();processData()}function parseData(d){var res=[];for(var i=0;i<d.length;++i){var s=$.extend(true,{},options.series);if(d[i].data!=null){s.data=d[i].data;delete d[i].data;$.extend(true,s,d[i]);d[i].data=s.data}else s.data=d[i];res.push(s)}return res}function axisNumber(obj,coord){var a=obj[coord+"axis"];if(typeof a=="object")a=a.n;if(typeof a!="number")a=1;return a}function allAxes(){return $.grep(xaxes.concat(yaxes),function(a){return a})}function canvasToAxisCoords(pos){var res={},i,axis;for(i=0;i<xaxes.length;++i){axis=xaxes[i];if(axis&&axis.used)res["x"+axis.n]=axis.c2p(pos.left)}for(i=0;i<yaxes.length;++i){axis=yaxes[i];if(axis&&axis.used)res["y"+axis.n]=axis.c2p(pos.top)}if(res.x1!==undefined)res.x=res.x1;if(res.y1!==undefined)res.y=res.y1;return res}function axisToCanvasCoords(pos){var res={},i,axis,key;for(i=0;i<xaxes.length;++i){axis=xaxes[i];if(axis&&axis.used){key="x"+axis.n;if(pos[key]==null&&axis.n==1)key="x";if(pos[key]!=null){res.left=axis.p2c(pos[key]);break}}}for(i=0;i<yaxes.length;++i){axis=yaxes[i];if(axis&&axis.used){key="y"+axis.n;if(pos[key]==null&&axis.n==1)key="y";if(pos[key]!=null){res.top=axis.p2c(pos[key]);break}}}return res}function getOrCreateAxis(axes,number){if(!axes[number-1])axes[number-1]={n:number,direction:axes==xaxes?"x":"y",options:$.extend(true,{},axes==xaxes?options.xaxis:options.yaxis)};return axes[number-1]}function fillInSeriesOptions(){var neededColors=series.length,maxIndex=-1,i;for(i=0;i<series.length;++i){var sc=series[i].color;if(sc!=null){neededColors--;if(typeof sc=="number"&&sc>maxIndex){maxIndex=sc}}}if(neededColors<=maxIndex){neededColors=maxIndex+1}var c,colors=[],colorPool=options.colors,colorPoolSize=colorPool.length,variation=0;for(i=0;i<neededColors;i++){c=$.color.parse(colorPool[i%colorPoolSize]||"#666");if(i%colorPoolSize==0&&i){if(variation>=0){if(variation<.5){variation=-variation-.2}else variation=0}else variation=-variation}colors[i]=c.scale("rgb",1+variation)}var colori=0,s;for(i=0;i<series.length;++i){s=series[i];if(s.color==null){s.color=colors[colori].toString();++colori}else if(typeof s.color=="number")s.color=colors[s.color].toString();if(s.lines.show==null){var v,show=true;for(v in s)if(s[v]&&s[v].show){show=false;break}if(show)s.lines.show=true}if(s.lines.zero==null){s.lines.zero=!!s.lines.fill}s.xaxis=getOrCreateAxis(xaxes,axisNumber(s,"x"));s.yaxis=getOrCreateAxis(yaxes,axisNumber(s,"y"))}}function processData(){var topSentry=Number.POSITIVE_INFINITY,bottomSentry=Number.NEGATIVE_INFINITY,fakeInfinity=Number.MAX_VALUE,i,j,k,m,length,s,points,ps,x,y,axis,val,f,p,data,format;function updateAxis(axis,min,max){if(min<axis.datamin&&min!=-fakeInfinity)axis.datamin=min;if(max>axis.datamax&&max!=fakeInfinity)axis.datamax=max}$.each(allAxes(),function(_,axis){axis.datamin=topSentry;axis.datamax=bottomSentry;axis.used=false});for(i=0;i<series.length;++i){s=series[i];s.datapoints={points:[]};executeHooks(hooks.processRawData,[s,s.data,s.datapoints])}for(i=0;i<series.length;++i){s=series[i];data=s.data;format=s.datapoints.format;if(!format){format=[];format.push({x:true,number:true,required:true});format.push({y:true,number:true,required:true});if(s.bars.show||s.lines.show&&s.lines.fill){var autoscale=!!(s.bars.show&&s.bars.zero||s.lines.show&&s.lines.zero);format.push({y:true,number:true,required:false,defaultValue:0,autoscale:autoscale});if(s.bars.horizontal){delete format[format.length-1].y;format[format.length-1].x=true}}s.datapoints.format=format}if(s.datapoints.pointsize!=null)continue;s.datapoints.pointsize=format.length;ps=s.datapoints.pointsize;points=s.datapoints.points;var insertSteps=s.lines.show&&s.lines.steps;s.xaxis.used=s.yaxis.used=true;for(j=k=0;j<data.length;++j,k+=ps){p=data[j];var nullify=p==null;if(!nullify){for(m=0;m<ps;++m){val=p[m];f=format[m];if(f){if(f.number&&val!=null){val=+val;if(isNaN(val))val=null;else if(val==Infinity)val=fakeInfinity;else if(val==-Infinity)val=-fakeInfinity}if(val==null){if(f.required)nullify=true;if(f.defaultValue!=null)val=f.defaultValue}}points[k+m]=val}}if(nullify){for(m=0;m<ps;++m){val=points[k+m];if(val!=null){f=format[m];if(f.autoscale!==false){if(f.x){updateAxis(s.xaxis,val,val)}if(f.y){updateAxis(s.yaxis,val,val)}}}points[k+m]=null}}else{if(insertSteps&&k>0&&points[k-ps]!=null&&points[k-ps]!=points[k]&&points[k-ps+1]!=points[k+1]){for(m=0;m<ps;++m)points[k+ps+m]=points[k+m];points[k+1]=points[k-ps+1];k+=ps}}}}for(i=0;i<series.length;++i){s=series[i];executeHooks(hooks.processDatapoints,[s,s.datapoints])}for(i=0;i<series.length;++i){s=series[i];points=s.datapoints.points;ps=s.datapoints.pointsize;format=s.datapoints.format;var xmin=topSentry,ymin=topSentry,xmax=bottomSentry,ymax=bottomSentry;for(j=0;j<points.length;j+=ps){if(points[j]==null)continue;for(m=0;m<ps;++m){val=points[j+m];f=format[m];if(!f||f.autoscale===false||val==fakeInfinity||val==-fakeInfinity)continue;if(f.x){if(val<xmin)xmin=val;if(val>xmax)xmax=val}if(f.y){if(val<ymin)ymin=val;if(val>ymax)ymax=val}}}if(s.bars.show){var delta;switch(s.bars.align){case"left":delta=0;break;case"right":delta=-s.bars.barWidth;break;default:delta=-s.bars.barWidth/2}if(s.bars.horizontal){ymin+=delta;ymax+=delta+s.bars.barWidth}else{xmin+=delta;xmax+=delta+s.bars.barWidth}}updateAxis(s.xaxis,xmin,xmax);updateAxis(s.yaxis,ymin,ymax)}$.each(allAxes(),function(_,axis){if(axis.datamin==topSentry)axis.datamin=null;if(axis.datamax==bottomSentry)axis.datamax=null})}function setupCanvases(){placeholder.css("padding",0).children().filter(function(){return!$(this).hasClass("flot-overlay")&&!$(this).hasClass("flot-base")}).remove();if(placeholder.css("position")=="static")placeholder.css("position","relative");surface=new Canvas("flot-base",placeholder);overlay=new Canvas("flot-overlay",placeholder);ctx=surface.context;octx=overlay.context;eventHolder=$(overlay.element).unbind();var existing=placeholder.data("plot");if(existing){existing.shutdown();overlay.clear()}placeholder.data("plot",plot)}function bindEvents(){if(options.grid.hoverable){eventHolder.mousemove(onMouseMove);eventHolder.bind("mouseleave",onMouseLeave)}if(options.grid.clickable)eventHolder.click(onClick);executeHooks(hooks.bindEvents,[eventHolder])}function shutdown(){if(redrawTimeout)clearTimeout(redrawTimeout);eventHolder.unbind("mousemove",onMouseMove);eventHolder.unbind("mouseleave",onMouseLeave);eventHolder.unbind("click",onClick);executeHooks(hooks.shutdown,[eventHolder])}function setTransformationHelpers(axis){function identity(x){return x}var s,m,t=axis.options.transform||identity,it=axis.options.inverseTransform;if(axis.direction=="x"){s=axis.scale=plotWidth/Math.abs(t(axis.max)-t(axis.min));m=Math.min(t(axis.max),t(axis.min))}else{s=axis.scale=plotHeight/Math.abs(t(axis.max)-t(axis.min));s=-s;m=Math.max(t(axis.max),t(axis.min))}if(t==identity)axis.p2c=function(p){return(p-m)*s};else axis.p2c=function(p){return(t(p)-m)*s};if(!it)axis.c2p=function(c){return m+c/s};else axis.c2p=function(c){return it(m+c/s)}}function measureTickLabels(axis){var opts=axis.options,ticks=axis.ticks||[],labelWidth=opts.labelWidth||0,labelHeight=opts.labelHeight||0,maxWidth=labelWidth||(axis.direction=="x"?Math.floor(surface.width/(ticks.length||1)):null),legacyStyles=axis.direction+"Axis "+axis.direction+axis.n+"Axis",layer="flot-"+axis.direction+"-axis flot-"+axis.direction+axis.n+"-axis "+legacyStyles,font=opts.font||"flot-tick-label tickLabel";for(var i=0;i<ticks.length;++i){var t=ticks[i];if(!t.label)continue;var info=surface.getTextInfo(layer,t.label,font,null,maxWidth);labelWidth=Math.max(labelWidth,info.width);labelHeight=Math.max(labelHeight,info.height)}axis.labelWidth=opts.labelWidth||labelWidth;axis.labelHeight=opts.labelHeight||labelHeight}function allocateAxisBoxFirstPhase(axis){var lw=axis.labelWidth,lh=axis.labelHeight,pos=axis.options.position,isXAxis=axis.direction==="x",tickLength=axis.options.tickLength,axisMargin=options.grid.axisMargin,padding=options.grid.labelMargin,innermost=true,outermost=true,first=true,found=false;$.each(isXAxis?xaxes:yaxes,function(i,a){if(a&&(a.show||a.reserveSpace)){if(a===axis){found=true}else if(a.options.position===pos){if(found){outermost=false}else{innermost=false}}if(!found){first=false}}});if(outermost){axisMargin=0}if(tickLength==null){tickLength=first?"full":5}if(!isNaN(+tickLength))padding+=+tickLength;if(isXAxis){lh+=padding;if(pos=="bottom"){plotOffset.bottom+=lh+axisMargin;axis.box={top:surface.height-plotOffset.bottom,height:lh}}else{axis.box={top:plotOffset.top+axisMargin,height:lh};plotOffset.top+=lh+axisMargin}}else{lw+=padding;if(pos=="left"){axis.box={left:plotOffset.left+axisMargin,width:lw};plotOffset.left+=lw+axisMargin}else{plotOffset.right+=lw+axisMargin;axis.box={left:surface.width-plotOffset.right,width:lw}}}axis.position=pos;axis.tickLength=tickLength;axis.box.padding=padding;axis.innermost=innermost}function allocateAxisBoxSecondPhase(axis){if(axis.direction=="x"){axis.box.left=plotOffset.left-axis.labelWidth/2;axis.box.width=surface.width-plotOffset.left-plotOffset.right+axis.labelWidth}else{axis.box.top=plotOffset.top-axis.labelHeight/2;axis.box.height=surface.height-plotOffset.bottom-plotOffset.top+axis.labelHeight}}function adjustLayoutForThingsStickingOut(){var minMargin=options.grid.minBorderMargin,axis,i;if(minMargin==null){minMargin=0;for(i=0;i<series.length;++i)minMargin=Math.max(minMargin,2*(series[i].points.radius+series[i].points.lineWidth/2))}var margins={left:minMargin,right:minMargin,top:minMargin,bottom:minMargin};$.each(allAxes(),function(_,axis){if(axis.reserveSpace&&axis.ticks&&axis.ticks.length){if(axis.direction==="x"){margins.left=Math.max(margins.left,axis.labelWidth/2);margins.right=Math.max(margins.right,axis.labelWidth/2)}else{margins.bottom=Math.max(margins.bottom,axis.labelHeight/2);margins.top=Math.max(margins.top,axis.labelHeight/2)}}});plotOffset.left=Math.ceil(Math.max(margins.left,plotOffset.left));plotOffset.right=Math.ceil(Math.max(margins.right,plotOffset.right));plotOffset.top=Math.ceil(Math.max(margins.top,plotOffset.top));plotOffset.bottom=Math.ceil(Math.max(margins.bottom,plotOffset.bottom))}function setupGrid(){var i,axes=allAxes(),showGrid=options.grid.show;for(var a in plotOffset){var margin=options.grid.margin||0;plotOffset[a]=typeof margin=="number"?margin:margin[a]||0}executeHooks(hooks.processOffset,[plotOffset]);for(var a in plotOffset){if(typeof options.grid.borderWidth=="object"){plotOffset[a]+=showGrid?options.grid.borderWidth[a]:0}else{plotOffset[a]+=showGrid?options.grid.borderWidth:0}}$.each(axes,function(_,axis){var axisOpts=axis.options;axis.show=axisOpts.show==null?axis.used:axisOpts.show;axis.reserveSpace=axisOpts.reserveSpace==null?axis.show:axisOpts.reserveSpace;setRange(axis)});if(showGrid){var allocatedAxes=$.grep(axes,function(axis){return axis.show||axis.reserveSpace});$.each(allocatedAxes,function(_,axis){setupTickGeneration(axis);setTicks(axis);snapRangeToTicks(axis,axis.ticks);measureTickLabels(axis)});for(i=allocatedAxes.length-1;i>=0;--i)allocateAxisBoxFirstPhase(allocatedAxes[i]);adjustLayoutForThingsStickingOut();$.each(allocatedAxes,function(_,axis){allocateAxisBoxSecondPhase(axis)})}plotWidth=surface.width-plotOffset.left-plotOffset.right;plotHeight=surface.height-plotOffset.bottom-plotOffset.top;$.each(axes,function(_,axis){setTransformationHelpers(axis)});if(showGrid){drawAxisLabels()}insertLegend()}function setRange(axis){var opts=axis.options,min=+(opts.min!=null?opts.min:axis.datamin),max=+(opts.max!=null?opts.max:axis.datamax),delta=max-min;if(delta==0){var widen=max==0?1:.01;if(opts.min==null)min-=widen;if(opts.max==null||opts.min!=null)max+=widen}else{var margin=opts.autoscaleMargin;if(margin!=null){if(opts.min==null){min-=delta*margin;if(min<0&&axis.datamin!=null&&axis.datamin>=0)min=0}if(opts.max==null){max+=delta*margin;if(max>0&&axis.datamax!=null&&axis.datamax<=0)max=0}}}axis.min=min;axis.max=max}function setupTickGeneration(axis){var opts=axis.options;var noTicks;if(typeof opts.ticks=="number"&&opts.ticks>0)noTicks=opts.ticks;else noTicks=.3*Math.sqrt(axis.direction=="x"?surface.width:surface.height);var delta=(axis.max-axis.min)/noTicks,dec=-Math.floor(Math.log(delta)/Math.LN10),maxDec=opts.tickDecimals;if(maxDec!=null&&dec>maxDec){dec=maxDec}var magn=Math.pow(10,-dec),norm=delta/magn,size;if(norm<1.5){size=1}else if(norm<3){size=2;if(norm>2.25&&(maxDec==null||dec+1<=maxDec)){size=2.5;++dec}}else if(norm<7.5){size=5}else{size=10}size*=magn;if(opts.minTickSize!=null&&size<opts.minTickSize){size=opts.minTickSize}axis.delta=delta;axis.tickDecimals=Math.max(0,maxDec!=null?maxDec:dec);axis.tickSize=opts.tickSize||size;if(opts.mode=="time"&&!axis.tickGenerator){throw new Error("Time mode requires the flot.time plugin.")}if(!axis.tickGenerator){axis.tickGenerator=function(axis){var ticks=[],start=floorInBase(axis.min,axis.tickSize),i=0,v=Number.NaN,prev;do{prev=v;v=start+i*axis.tickSize;ticks.push(v);++i}while(v<axis.max&&v!=prev);return ticks};axis.tickFormatter=function(value,axis){var factor=axis.tickDecimals?Math.pow(10,axis.tickDecimals):1;var formatted=""+Math.round(value*factor)/factor;if(axis.tickDecimals!=null){var decimal=formatted.indexOf(".");var precision=decimal==-1?0:formatted.length-decimal-1;if(precision<axis.tickDecimals){return(precision?formatted:formatted+".")+(""+factor).substr(1,axis.tickDecimals-precision)}}return formatted}}if($.isFunction(opts.tickFormatter))axis.tickFormatter=function(v,axis){return""+opts.tickFormatter(v,axis)};if(opts.alignTicksWithAxis!=null){var otherAxis=(axis.direction=="x"?xaxes:yaxes)[opts.alignTicksWithAxis-1];if(otherAxis&&otherAxis.used&&otherAxis!=axis){var niceTicks=axis.tickGenerator(axis);if(niceTicks.length>0){if(opts.min==null)axis.min=Math.min(axis.min,niceTicks[0]);if(opts.max==null&&niceTicks.length>1)axis.max=Math.max(axis.max,niceTicks[niceTicks.length-1])}axis.tickGenerator=function(axis){var ticks=[],v,i;for(i=0;i<otherAxis.ticks.length;++i){v=(otherAxis.ticks[i].v-otherAxis.min)/(otherAxis.max-otherAxis.min);v=axis.min+v*(axis.max-axis.min);ticks.push(v)}return ticks};if(!axis.mode&&opts.tickDecimals==null){var extraDec=Math.max(0,-Math.floor(Math.log(axis.delta)/Math.LN10)+1),ts=axis.tickGenerator(axis);if(!(ts.length>1&&/\..*0$/.test((ts[1]-ts[0]).toFixed(extraDec))))axis.tickDecimals=extraDec}}}}function setTicks(axis){var oticks=axis.options.ticks,ticks=[];if(oticks==null||typeof oticks=="number"&&oticks>0)ticks=axis.tickGenerator(axis);else if(oticks){if($.isFunction(oticks))ticks=oticks(axis);else ticks=oticks}var i,v;axis.ticks=[];for(i=0;i<ticks.length;++i){var label=null;var t=ticks[i];if(typeof t=="object"){v=+t[0];if(t.length>1)label=t[1]}else v=+t;if(label==null)label=axis.tickFormatter(v,axis);if(!isNaN(v))axis.ticks.push({v:v,label:label})}}function snapRangeToTicks(axis,ticks){if(axis.options.autoscaleMargin&&ticks.length>0){if(axis.options.min==null)axis.min=Math.min(axis.min,ticks[0].v);if(axis.options.max==null&&ticks.length>1)axis.max=Math.max(axis.max,ticks[ticks.length-1].v)}}function draw(){surface.clear();executeHooks(hooks.drawBackground,[ctx]);var grid=options.grid;if(grid.show&&grid.backgroundColor)drawBackground();if(grid.show&&!grid.aboveData){drawGrid()}for(var i=0;i<series.length;++i){executeHooks(hooks.drawSeries,[ctx,series[i]]);drawSeries(series[i])}executeHooks(hooks.draw,[ctx]);if(grid.show&&grid.aboveData){drawGrid()}surface.render();triggerRedrawOverlay()}function extractRange(ranges,coord){var axis,from,to,key,axes=allAxes();for(var i=0;i<axes.length;++i){axis=axes[i];if(axis.direction==coord){key=coord+axis.n+"axis";if(!ranges[key]&&axis.n==1)key=coord+"axis";if(ranges[key]){from=ranges[key].from;to=ranges[key].to;break}}}if(!ranges[key]){axis=coord=="x"?xaxes[0]:yaxes[0];from=ranges[coord+"1"];to=ranges[coord+"2"]}if(from!=null&&to!=null&&from>to){var tmp=from;from=to;to=tmp}return{from:from,to:to,axis:axis}}function drawBackground(){ctx.save();ctx.translate(plotOffset.left,plotOffset.top);ctx.fillStyle=getColorOrGradient(options.grid.backgroundColor,plotHeight,0,"rgba(255, 255, 255, 0)");ctx.fillRect(0,0,plotWidth,plotHeight);ctx.restore()}function drawGrid(){var i,axes,bw,bc;ctx.save();ctx.translate(plotOffset.left,plotOffset.top);var markings=options.grid.markings;if(markings){if($.isFunction(markings)){axes=plot.getAxes();axes.xmin=axes.xaxis.min;axes.xmax=axes.xaxis.max;axes.ymin=axes.yaxis.min;axes.ymax=axes.yaxis.max;markings=markings(axes)}for(i=0;i<markings.length;++i){var m=markings[i],xrange=extractRange(m,"x"),yrange=extractRange(m,"y");if(xrange.from==null)xrange.from=xrange.axis.min;if(xrange.to==null)xrange.to=xrange.axis.max;
if(yrange.from==null)yrange.from=yrange.axis.min;if(yrange.to==null)yrange.to=yrange.axis.max;if(xrange.to<xrange.axis.min||xrange.from>xrange.axis.max||yrange.to<yrange.axis.min||yrange.from>yrange.axis.max)continue;xrange.from=Math.max(xrange.from,xrange.axis.min);xrange.to=Math.min(xrange.to,xrange.axis.max);yrange.from=Math.max(yrange.from,yrange.axis.min);yrange.to=Math.min(yrange.to,yrange.axis.max);var xequal=xrange.from===xrange.to,yequal=yrange.from===yrange.to;if(xequal&&yequal){continue}xrange.from=Math.floor(xrange.axis.p2c(xrange.from));xrange.to=Math.floor(xrange.axis.p2c(xrange.to));yrange.from=Math.floor(yrange.axis.p2c(yrange.from));yrange.to=Math.floor(yrange.axis.p2c(yrange.to));if(xequal||yequal){var lineWidth=m.lineWidth||options.grid.markingsLineWidth,subPixel=lineWidth%2?.5:0;ctx.beginPath();ctx.strokeStyle=m.color||options.grid.markingsColor;ctx.lineWidth=lineWidth;if(xequal){ctx.moveTo(xrange.to+subPixel,yrange.from);ctx.lineTo(xrange.to+subPixel,yrange.to)}else{ctx.moveTo(xrange.from,yrange.to+subPixel);ctx.lineTo(xrange.to,yrange.to+subPixel)}ctx.stroke()}else{ctx.fillStyle=m.color||options.grid.markingsColor;ctx.fillRect(xrange.from,yrange.to,xrange.to-xrange.from,yrange.from-yrange.to)}}}axes=allAxes();bw=options.grid.borderWidth;for(var j=0;j<axes.length;++j){var axis=axes[j],box=axis.box,t=axis.tickLength,x,y,xoff,yoff;if(!axis.show||axis.ticks.length==0)continue;ctx.lineWidth=1;if(axis.direction=="x"){x=0;if(t=="full")y=axis.position=="top"?0:plotHeight;else y=box.top-plotOffset.top+(axis.position=="top"?box.height:0)}else{y=0;if(t=="full")x=axis.position=="left"?0:plotWidth;else x=box.left-plotOffset.left+(axis.position=="left"?box.width:0)}if(!axis.innermost){ctx.strokeStyle=axis.options.color;ctx.beginPath();xoff=yoff=0;if(axis.direction=="x")xoff=plotWidth+1;else yoff=plotHeight+1;if(ctx.lineWidth==1){if(axis.direction=="x"){y=Math.floor(y)+.5}else{x=Math.floor(x)+.5}}ctx.moveTo(x,y);ctx.lineTo(x+xoff,y+yoff);ctx.stroke()}ctx.strokeStyle=axis.options.tickColor;ctx.beginPath();for(i=0;i<axis.ticks.length;++i){var v=axis.ticks[i].v;xoff=yoff=0;if(isNaN(v)||v<axis.min||v>axis.max||t=="full"&&(typeof bw=="object"&&bw[axis.position]>0||bw>0)&&(v==axis.min||v==axis.max))continue;if(axis.direction=="x"){x=axis.p2c(v);yoff=t=="full"?-plotHeight:t;if(axis.position=="top")yoff=-yoff}else{y=axis.p2c(v);xoff=t=="full"?-plotWidth:t;if(axis.position=="left")xoff=-xoff}if(ctx.lineWidth==1){if(axis.direction=="x")x=Math.floor(x)+.5;else y=Math.floor(y)+.5}ctx.moveTo(x,y);ctx.lineTo(x+xoff,y+yoff)}ctx.stroke()}if(bw){bc=options.grid.borderColor;if(typeof bw=="object"||typeof bc=="object"){if(typeof bw!=="object"){bw={top:bw,right:bw,bottom:bw,left:bw}}if(typeof bc!=="object"){bc={top:bc,right:bc,bottom:bc,left:bc}}if(bw.top>0){ctx.strokeStyle=bc.top;ctx.lineWidth=bw.top;ctx.beginPath();ctx.moveTo(0-bw.left,0-bw.top/2);ctx.lineTo(plotWidth,0-bw.top/2);ctx.stroke()}if(bw.right>0){ctx.strokeStyle=bc.right;ctx.lineWidth=bw.right;ctx.beginPath();ctx.moveTo(plotWidth+bw.right/2,0-bw.top);ctx.lineTo(plotWidth+bw.right/2,plotHeight);ctx.stroke()}if(bw.bottom>0){ctx.strokeStyle=bc.bottom;ctx.lineWidth=bw.bottom;ctx.beginPath();ctx.moveTo(plotWidth+bw.right,plotHeight+bw.bottom/2);ctx.lineTo(0,plotHeight+bw.bottom/2);ctx.stroke()}if(bw.left>0){ctx.strokeStyle=bc.left;ctx.lineWidth=bw.left;ctx.beginPath();ctx.moveTo(0-bw.left/2,plotHeight+bw.bottom);ctx.lineTo(0-bw.left/2,0);ctx.stroke()}}else{ctx.lineWidth=bw;ctx.strokeStyle=options.grid.borderColor;ctx.strokeRect(-bw/2,-bw/2,plotWidth+bw,plotHeight+bw)}}ctx.restore()}function drawAxisLabels(){$.each(allAxes(),function(_,axis){var box=axis.box,legacyStyles=axis.direction+"Axis "+axis.direction+axis.n+"Axis",layer="flot-"+axis.direction+"-axis flot-"+axis.direction+axis.n+"-axis "+legacyStyles,font=axis.options.font||"flot-tick-label tickLabel",tick,x,y,halign,valign;surface.removeText(layer);if(!axis.show||axis.ticks.length==0)return;for(var i=0;i<axis.ticks.length;++i){tick=axis.ticks[i];if(!tick.label||tick.v<axis.min||tick.v>axis.max)continue;if(axis.direction=="x"){halign="center";x=plotOffset.left+axis.p2c(tick.v);if(axis.position=="bottom"){y=box.top+box.padding}else{y=box.top+box.height-box.padding;valign="bottom"}}else{valign="middle";y=plotOffset.top+axis.p2c(tick.v);if(axis.position=="left"){x=box.left+box.width-box.padding;halign="right"}else{x=box.left+box.padding}}surface.addText(layer,x,y,tick.label,font,null,null,halign,valign)}})}function drawSeries(series){if(series.lines.show)drawSeriesLines(series);if(series.bars.show)drawSeriesBars(series);if(series.points.show)drawSeriesPoints(series)}function drawSeriesLines(series){function plotLine(datapoints,xoffset,yoffset,axisx,axisy){var points=datapoints.points,ps=datapoints.pointsize,prevx=null,prevy=null;ctx.beginPath();for(var i=ps;i<points.length;i+=ps){var x1=points[i-ps],y1=points[i-ps+1],x2=points[i],y2=points[i+1];if(x1==null||x2==null)continue;if(y1<=y2&&y1<axisy.min){if(y2<axisy.min)continue;x1=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.min}else if(y2<=y1&&y2<axisy.min){if(y1<axisy.min)continue;x2=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.min}if(y1>=y2&&y1>axisy.max){if(y2>axisy.max)continue;x1=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.max}else if(y2>=y1&&y2>axisy.max){if(y1>axisy.max)continue;x2=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.max}if(x1<=x2&&x1<axisx.min){if(x2<axisx.min)continue;y1=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.min}else if(x2<=x1&&x2<axisx.min){if(x1<axisx.min)continue;y2=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.min}if(x1>=x2&&x1>axisx.max){if(x2>axisx.max)continue;y1=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.max}else if(x2>=x1&&x2>axisx.max){if(x1>axisx.max)continue;y2=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.max}if(x1!=prevx||y1!=prevy)ctx.moveTo(axisx.p2c(x1)+xoffset,axisy.p2c(y1)+yoffset);prevx=x2;prevy=y2;ctx.lineTo(axisx.p2c(x2)+xoffset,axisy.p2c(y2)+yoffset)}ctx.stroke()}function plotLineArea(datapoints,axisx,axisy){var points=datapoints.points,ps=datapoints.pointsize,bottom=Math.min(Math.max(0,axisy.min),axisy.max),i=0,top,areaOpen=false,ypos=1,segmentStart=0,segmentEnd=0;while(true){if(ps>0&&i>points.length+ps)break;i+=ps;var x1=points[i-ps],y1=points[i-ps+ypos],x2=points[i],y2=points[i+ypos];if(areaOpen){if(ps>0&&x1!=null&&x2==null){segmentEnd=i;ps=-ps;ypos=2;continue}if(ps<0&&i==segmentStart+ps){ctx.fill();areaOpen=false;ps=-ps;ypos=1;i=segmentStart=segmentEnd+ps;continue}}if(x1==null||x2==null)continue;if(x1<=x2&&x1<axisx.min){if(x2<axisx.min)continue;y1=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.min}else if(x2<=x1&&x2<axisx.min){if(x1<axisx.min)continue;y2=(axisx.min-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.min}if(x1>=x2&&x1>axisx.max){if(x2>axisx.max)continue;y1=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x1=axisx.max}else if(x2>=x1&&x2>axisx.max){if(x1>axisx.max)continue;y2=(axisx.max-x1)/(x2-x1)*(y2-y1)+y1;x2=axisx.max}if(!areaOpen){ctx.beginPath();ctx.moveTo(axisx.p2c(x1),axisy.p2c(bottom));areaOpen=true}if(y1>=axisy.max&&y2>=axisy.max){ctx.lineTo(axisx.p2c(x1),axisy.p2c(axisy.max));ctx.lineTo(axisx.p2c(x2),axisy.p2c(axisy.max));continue}else if(y1<=axisy.min&&y2<=axisy.min){ctx.lineTo(axisx.p2c(x1),axisy.p2c(axisy.min));ctx.lineTo(axisx.p2c(x2),axisy.p2c(axisy.min));continue}var x1old=x1,x2old=x2;if(y1<=y2&&y1<axisy.min&&y2>=axisy.min){x1=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.min}else if(y2<=y1&&y2<axisy.min&&y1>=axisy.min){x2=(axisy.min-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.min}if(y1>=y2&&y1>axisy.max&&y2<=axisy.max){x1=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y1=axisy.max}else if(y2>=y1&&y2>axisy.max&&y1<=axisy.max){x2=(axisy.max-y1)/(y2-y1)*(x2-x1)+x1;y2=axisy.max}if(x1!=x1old){ctx.lineTo(axisx.p2c(x1old),axisy.p2c(y1))}ctx.lineTo(axisx.p2c(x1),axisy.p2c(y1));ctx.lineTo(axisx.p2c(x2),axisy.p2c(y2));if(x2!=x2old){ctx.lineTo(axisx.p2c(x2),axisy.p2c(y2));ctx.lineTo(axisx.p2c(x2old),axisy.p2c(y2))}}}ctx.save();ctx.translate(plotOffset.left,plotOffset.top);ctx.lineJoin="round";var lw=series.lines.lineWidth,sw=series.shadowSize;if(lw>0&&sw>0){ctx.lineWidth=sw;ctx.strokeStyle="rgba(0,0,0,0.1)";var angle=Math.PI/18;plotLine(series.datapoints,Math.sin(angle)*(lw/2+sw/2),Math.cos(angle)*(lw/2+sw/2),series.xaxis,series.yaxis);ctx.lineWidth=sw/2;plotLine(series.datapoints,Math.sin(angle)*(lw/2+sw/4),Math.cos(angle)*(lw/2+sw/4),series.xaxis,series.yaxis)}ctx.lineWidth=lw;ctx.strokeStyle=series.color;var fillStyle=getFillStyle(series.lines,series.color,0,plotHeight);if(fillStyle){ctx.fillStyle=fillStyle;plotLineArea(series.datapoints,series.xaxis,series.yaxis)}if(lw>0)plotLine(series.datapoints,0,0,series.xaxis,series.yaxis);ctx.restore()}function drawSeriesPoints(series){function plotPoints(datapoints,radius,fillStyle,offset,shadow,axisx,axisy,symbol){var points=datapoints.points,ps=datapoints.pointsize;for(var i=0;i<points.length;i+=ps){var x=points[i],y=points[i+1];if(x==null||x<axisx.min||x>axisx.max||y<axisy.min||y>axisy.max)continue;ctx.beginPath();x=axisx.p2c(x);y=axisy.p2c(y)+offset;if(symbol=="circle")ctx.arc(x,y,radius,0,shadow?Math.PI:Math.PI*2,false);else symbol(ctx,x,y,radius,shadow);ctx.closePath();if(fillStyle){ctx.fillStyle=fillStyle;ctx.fill()}ctx.stroke()}}ctx.save();ctx.translate(plotOffset.left,plotOffset.top);var lw=series.points.lineWidth,sw=series.shadowSize,radius=series.points.radius,symbol=series.points.symbol;if(lw==0)lw=1e-4;if(lw>0&&sw>0){var w=sw/2;ctx.lineWidth=w;ctx.strokeStyle="rgba(0,0,0,0.1)";plotPoints(series.datapoints,radius,null,w+w/2,true,series.xaxis,series.yaxis,symbol);ctx.strokeStyle="rgba(0,0,0,0.2)";plotPoints(series.datapoints,radius,null,w/2,true,series.xaxis,series.yaxis,symbol)}ctx.lineWidth=lw;ctx.strokeStyle=series.color;plotPoints(series.datapoints,radius,getFillStyle(series.points,series.color),0,false,series.xaxis,series.yaxis,symbol);ctx.restore()}function drawBar(x,y,b,barLeft,barRight,fillStyleCallback,axisx,axisy,c,horizontal,lineWidth){var left,right,bottom,top,drawLeft,drawRight,drawTop,drawBottom,tmp;if(horizontal){drawBottom=drawRight=drawTop=true;drawLeft=false;left=b;right=x;top=y+barLeft;bottom=y+barRight;if(right<left){tmp=right;right=left;left=tmp;drawLeft=true;drawRight=false}}else{drawLeft=drawRight=drawTop=true;drawBottom=false;left=x+barLeft;right=x+barRight;bottom=b;top=y;if(top<bottom){tmp=top;top=bottom;bottom=tmp;drawBottom=true;drawTop=false}}if(right<axisx.min||left>axisx.max||top<axisy.min||bottom>axisy.max)return;if(left<axisx.min){left=axisx.min;drawLeft=false}if(right>axisx.max){right=axisx.max;drawRight=false}if(bottom<axisy.min){bottom=axisy.min;drawBottom=false}if(top>axisy.max){top=axisy.max;drawTop=false}left=axisx.p2c(left);bottom=axisy.p2c(bottom);right=axisx.p2c(right);top=axisy.p2c(top);if(fillStyleCallback){c.fillStyle=fillStyleCallback(bottom,top);c.fillRect(left,top,right-left,bottom-top)}if(lineWidth>0&&(drawLeft||drawRight||drawTop||drawBottom)){c.beginPath();c.moveTo(left,bottom);if(drawLeft)c.lineTo(left,top);else c.moveTo(left,top);if(drawTop)c.lineTo(right,top);else c.moveTo(right,top);if(drawRight)c.lineTo(right,bottom);else c.moveTo(right,bottom);if(drawBottom)c.lineTo(left,bottom);else c.moveTo(left,bottom);c.stroke()}}function drawSeriesBars(series){function plotBars(datapoints,barLeft,barRight,fillStyleCallback,axisx,axisy){var points=datapoints.points,ps=datapoints.pointsize;for(var i=0;i<points.length;i+=ps){if(points[i]==null)continue;drawBar(points[i],points[i+1],points[i+2],barLeft,barRight,fillStyleCallback,axisx,axisy,ctx,series.bars.horizontal,series.bars.lineWidth)}}ctx.save();ctx.translate(plotOffset.left,plotOffset.top);ctx.lineWidth=series.bars.lineWidth;ctx.strokeStyle=series.color;var barLeft;switch(series.bars.align){case"left":barLeft=0;break;case"right":barLeft=-series.bars.barWidth;break;default:barLeft=-series.bars.barWidth/2}var fillStyleCallback=series.bars.fill?function(bottom,top){return getFillStyle(series.bars,series.color,bottom,top)}:null;plotBars(series.datapoints,barLeft,barLeft+series.bars.barWidth,fillStyleCallback,series.xaxis,series.yaxis);ctx.restore()}function getFillStyle(filloptions,seriesColor,bottom,top){var fill=filloptions.fill;if(!fill)return null;if(filloptions.fillColor)return getColorOrGradient(filloptions.fillColor,bottom,top,seriesColor);var c=$.color.parse(seriesColor);c.a=typeof fill=="number"?fill:.4;c.normalize();return c.toString()}function insertLegend(){if(options.legend.container!=null){$(options.legend.container).html("")}else{placeholder.find(".legend").remove()}if(!options.legend.show){return}var fragments=[],entries=[],rowStarted=false,lf=options.legend.labelFormatter,s,label;for(var i=0;i<series.length;++i){s=series[i];if(s.label){label=lf?lf(s.label,s):s.label;if(label){entries.push({label:label,color:s.color})}}}if(options.legend.sorted){if($.isFunction(options.legend.sorted)){entries.sort(options.legend.sorted)}else if(options.legend.sorted=="reverse"){entries.reverse()}else{var ascending=options.legend.sorted!="descending";entries.sort(function(a,b){return a.label==b.label?0:a.label<b.label!=ascending?1:-1})}}for(var i=0;i<entries.length;++i){var entry=entries[i];if(i%options.legend.noColumns==0){if(rowStarted)fragments.push("</tr>");fragments.push("<tr>");rowStarted=true}fragments.push('<td class="legendColorBox"><div style="border:1px solid '+options.legend.labelBoxBorderColor+';padding:1px"><div style="width:4px;height:0;border:5px solid '+entry.color+';overflow:hidden"></div></div></td>'+'<td class="legendLabel">'+entry.label+"</td>")}if(rowStarted)fragments.push("</tr>");if(fragments.length==0)return;var table='<table style="font-size:smaller;color:'+options.grid.color+'">'+fragments.join("")+"</table>";if(options.legend.container!=null)$(options.legend.container).html(table);else{var pos="",p=options.legend.position,m=options.legend.margin;if(m[0]==null)m=[m,m];if(p.charAt(0)=="n")pos+="top:"+(m[1]+plotOffset.top)+"px;";else if(p.charAt(0)=="s")pos+="bottom:"+(m[1]+plotOffset.bottom)+"px;";if(p.charAt(1)=="e")pos+="right:"+(m[0]+plotOffset.right)+"px;";else if(p.charAt(1)=="w")pos+="left:"+(m[0]+plotOffset.left)+"px;";var legend=$('<div class="legend">'+table.replace('style="','style="position:absolute;'+pos+";")+"</div>").appendTo(placeholder);if(options.legend.backgroundOpacity!=0){var c=options.legend.backgroundColor;if(c==null){c=options.grid.backgroundColor;if(c&&typeof c=="string")c=$.color.parse(c);else c=$.color.extract(legend,"background-color");c.a=1;c=c.toString()}var div=legend.children();$('<div style="position:absolute;width:'+div.width()+"px;height:"+div.height()+"px;"+pos+"background-color:"+c+';"> </div>').prependTo(legend).css("opacity",options.legend.backgroundOpacity)}}}var highlights=[],redrawTimeout=null;function findNearbyItem(mouseX,mouseY,seriesFilter){var maxDistance=options.grid.mouseActiveRadius,smallestDistance=maxDistance*maxDistance+1,item=null,foundPoint=false,i,j,ps;for(i=series.length-1;i>=0;--i){if(!seriesFilter(series[i]))continue;var s=series[i],axisx=s.xaxis,axisy=s.yaxis,points=s.datapoints.points,mx=axisx.c2p(mouseX),my=axisy.c2p(mouseY),maxx=maxDistance/axisx.scale,maxy=maxDistance/axisy.scale;ps=s.datapoints.pointsize;if(axisx.options.inverseTransform)maxx=Number.MAX_VALUE;if(axisy.options.inverseTransform)maxy=Number.MAX_VALUE;if(s.lines.show||s.points.show){for(j=0;j<points.length;j+=ps){var x=points[j],y=points[j+1];if(x==null)continue;if(x-mx>maxx||x-mx<-maxx||y-my>maxy||y-my<-maxy)continue;var dx=Math.abs(axisx.p2c(x)-mouseX),dy=Math.abs(axisy.p2c(y)-mouseY),dist=dx*dx+dy*dy;if(dist<smallestDistance){smallestDistance=dist;item=[i,j/ps]}}}if(s.bars.show&&!item){var barLeft,barRight;switch(s.bars.align){case"left":barLeft=0;break;case"right":barLeft=-s.bars.barWidth;break;default:barLeft=-s.bars.barWidth/2}barRight=barLeft+s.bars.barWidth;for(j=0;j<points.length;j+=ps){var x=points[j],y=points[j+1],b=points[j+2];if(x==null)continue;if(series[i].bars.horizontal?mx<=Math.max(b,x)&&mx>=Math.min(b,x)&&my>=y+barLeft&&my<=y+barRight:mx>=x+barLeft&&mx<=x+barRight&&my>=Math.min(b,y)&&my<=Math.max(b,y))item=[i,j/ps]}}}if(item){i=item[0];j=item[1];ps=series[i].datapoints.pointsize;return{datapoint:series[i].datapoints.points.slice(j*ps,(j+1)*ps),dataIndex:j,series:series[i],seriesIndex:i}}return null}function onMouseMove(e){if(options.grid.hoverable)triggerClickHoverEvent("plothover",e,function(s){return s["hoverable"]!=false})}function onMouseLeave(e){if(options.grid.hoverable)triggerClickHoverEvent("plothover",e,function(s){return false})}function onClick(e){triggerClickHoverEvent("plotclick",e,function(s){return s["clickable"]!=false})}function triggerClickHoverEvent(eventname,event,seriesFilter){var offset=eventHolder.offset(),canvasX=event.pageX-offset.left-plotOffset.left,canvasY=event.pageY-offset.top-plotOffset.top,pos=canvasToAxisCoords({left:canvasX,top:canvasY});pos.pageX=event.pageX;pos.pageY=event.pageY;var item=findNearbyItem(canvasX,canvasY,seriesFilter);if(item){item.pageX=parseInt(item.series.xaxis.p2c(item.datapoint[0])+offset.left+plotOffset.left,10);item.pageY=parseInt(item.series.yaxis.p2c(item.datapoint[1])+offset.top+plotOffset.top,10)}if(options.grid.autoHighlight){for(var i=0;i<highlights.length;++i){var h=highlights[i];if(h.auto==eventname&&!(item&&h.series==item.series&&h.point[0]==item.datapoint[0]&&h.point[1]==item.datapoint[1]))unhighlight(h.series,h.point)}if(item)highlight(item.series,item.datapoint,eventname)}placeholder.trigger(eventname,[pos,item])}function triggerRedrawOverlay(){var t=options.interaction.redrawOverlayInterval;if(t==-1){drawOverlay();return}if(!redrawTimeout)redrawTimeout=setTimeout(drawOverlay,t)}function drawOverlay(){redrawTimeout=null;octx.save();overlay.clear();octx.translate(plotOffset.left,plotOffset.top);var i,hi;for(i=0;i<highlights.length;++i){hi=highlights[i];if(hi.series.bars.show)drawBarHighlight(hi.series,hi.point);else drawPointHighlight(hi.series,hi.point)}octx.restore();executeHooks(hooks.drawOverlay,[octx])}function highlight(s,point,auto){if(typeof s=="number")s=series[s];if(typeof point=="number"){var ps=s.datapoints.pointsize;point=s.datapoints.points.slice(ps*point,ps*(point+1))}var i=indexOfHighlight(s,point);if(i==-1){highlights.push({series:s,point:point,auto:auto});triggerRedrawOverlay()}else if(!auto)highlights[i].auto=false}function unhighlight(s,point){if(s==null&&point==null){highlights=[];triggerRedrawOverlay();return}if(typeof s=="number")s=series[s];if(typeof point=="number"){var ps=s.datapoints.pointsize;point=s.datapoints.points.slice(ps*point,ps*(point+1))}var i=indexOfHighlight(s,point);if(i!=-1){highlights.splice(i,1);triggerRedrawOverlay()}}function indexOfHighlight(s,p){for(var i=0;i<highlights.length;++i){var h=highlights[i];if(h.series==s&&h.point[0]==p[0]&&h.point[1]==p[1])return i}return-1}function drawPointHighlight(series,point){var x=point[0],y=point[1],axisx=series.xaxis,axisy=series.yaxis,highlightColor=typeof series.highlightColor==="string"?series.highlightColor:$.color.parse(series.color).scale("a",.5).toString();if(x<axisx.min||x>axisx.max||y<axisy.min||y>axisy.max)return;var pointRadius=series.points.radius+series.points.lineWidth/2;octx.lineWidth=pointRadius;octx.strokeStyle=highlightColor;var radius=1.5*pointRadius;x=axisx.p2c(x);y=axisy.p2c(y);octx.beginPath();if(series.points.symbol=="circle")octx.arc(x,y,radius,0,2*Math.PI,false);else series.points.symbol(octx,x,y,radius,false);octx.closePath();octx.stroke()}function drawBarHighlight(series,point){var highlightColor=typeof series.highlightColor==="string"?series.highlightColor:$.color.parse(series.color).scale("a",.5).toString(),fillStyle=highlightColor,barLeft;switch(series.bars.align){case"left":barLeft=0;break;case"right":barLeft=-series.bars.barWidth;break;default:barLeft=-series.bars.barWidth/2}octx.lineWidth=series.bars.lineWidth;octx.strokeStyle=highlightColor;drawBar(point[0],point[1],point[2]||0,barLeft,barLeft+series.bars.barWidth,function(){return fillStyle},series.xaxis,series.yaxis,octx,series.bars.horizontal,series.bars.lineWidth)}function getColorOrGradient(spec,bottom,top,defaultColor){if(typeof spec=="string")return spec;else{var gradient=ctx.createLinearGradient(0,top,0,bottom);for(var i=0,l=spec.colors.length;i<l;++i){var c=spec.colors[i];if(typeof c!="string"){var co=$.color.parse(defaultColor);if(c.brightness!=null)co=co.scale("rgb",c.brightness);if(c.opacity!=null)co.a*=c.opacity;c=co.toString()}gradient.addColorStop(i/(l-1),c)}return gradient}}}$.plot=function(placeholder,data,options){var plot=new Plot($(placeholder),data,options,$.plot.plugins);return plot};$.plot.version="0.8.3";$.plot.plugins=[];$.fn.plot=function(data,options){return this.each(function(){$.plot(this,data,options)})};function floorInBase(n,base){return base*Math.floor(n/base)}})(jQuery);
/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/
(function($){var options={canvas:true};var render,getTextInfo,addText;var hasOwnProperty=Object.prototype.hasOwnProperty;function init(plot,classes){var Canvas=classes.Canvas;if(render==null){getTextInfo=Canvas.prototype.getTextInfo,addText=Canvas.prototype.addText,render=Canvas.prototype.render}Canvas.prototype.render=function(){if(!plot.getOptions().canvas){return render.call(this)}var context=this.context,cache=this._textCache;context.save();context.textBaseline="middle";for(var layerKey in cache){if(hasOwnProperty.call(cache,layerKey)){var layerCache=cache[layerKey];for(var styleKey in layerCache){if(hasOwnProperty.call(layerCache,styleKey)){var styleCache=layerCache[styleKey],updateStyles=true;for(var key in styleCache){if(hasOwnProperty.call(styleCache,key)){var info=styleCache[key],positions=info.positions,lines=info.lines;if(updateStyles){context.fillStyle=info.font.color;context.font=info.font.definition;updateStyles=false}for(var i=0,position;position=positions[i];i++){if(position.active){for(var j=0,line;line=position.lines[j];j++){context.fillText(lines[j].text,line[0],line[1])}}else{positions.splice(i--,1)}}if(positions.length==0){delete styleCache[key]}}}}}}}context.restore()};Canvas.prototype.getTextInfo=function(layer,text,font,angle,width){if(!plot.getOptions().canvas){return getTextInfo.call(this,layer,text,font,angle,width)}var textStyle,layerCache,styleCache,info;text=""+text;if(typeof font==="object"){textStyle=font.style+" "+font.variant+" "+font.weight+" "+font.size+"px "+font.family}else{textStyle=font}layerCache=this._textCache[layer];if(layerCache==null){layerCache=this._textCache[layer]={}}styleCache=layerCache[textStyle];if(styleCache==null){styleCache=layerCache[textStyle]={}}info=styleCache[text];if(info==null){var context=this.context;if(typeof font!=="object"){var element=$("<div>&nbsp;</div>").css("position","absolute").addClass(typeof font==="string"?font:null).appendTo(this.getTextLayer(layer));font={lineHeight:element.height(),style:element.css("font-style"),variant:element.css("font-variant"),weight:element.css("font-weight"),family:element.css("font-family"),color:element.css("color")};font.size=element.css("line-height",1).height();element.remove()}textStyle=font.style+" "+font.variant+" "+font.weight+" "+font.size+"px "+font.family;info=styleCache[text]={width:0,height:0,positions:[],lines:[],font:{definition:textStyle,color:font.color}};context.save();context.font=textStyle;var lines=(text+"").replace(/<br ?\/?>|\r\n|\r/g,"\n").split("\n");for(var i=0;i<lines.length;++i){var lineText=lines[i],measured=context.measureText(lineText);info.width=Math.max(measured.width,info.width);info.height+=font.lineHeight;info.lines.push({text:lineText,width:measured.width,height:font.lineHeight})}context.restore()}return info};Canvas.prototype.addText=function(layer,x,y,text,font,angle,width,halign,valign){if(!plot.getOptions().canvas){return addText.call(this,layer,x,y,text,font,angle,width,halign,valign)}var info=this.getTextInfo(layer,text,font,angle,width),positions=info.positions,lines=info.lines;y+=info.height/lines.length/2;if(valign=="middle"){y=Math.round(y-info.height/2)}else if(valign=="bottom"){y=Math.round(y-info.height)}else{y=Math.round(y)}if(!!(window.opera&&window.opera.version().split(".")[0]<12)){y-=2}for(var i=0,position;position=positions[i];i++){if(position.x==x&&position.y==y){position.active=true;return}}position={active:true,lines:[],x:x,y:y};positions.push(position);for(var i=0,line;line=lines[i];i++){if(halign=="center"){position.lines.push([Math.round(x-line.width/2),y])}else if(halign=="right"){position.lines.push([Math.round(x-line.width),y])}else{position.lines.push([Math.round(x),y])}y+=line.height}}}$.plot.plugins.push({init:init,options:options,name:"canvas",version:"1.0"})})(jQuery);
/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/
(function($){var REDRAW_ATTEMPTS=10;var REDRAW_SHRINK=.95;function init(plot){var canvas=null,target=null,options=null,maxRadius=null,centerLeft=null,centerTop=null,processed=false,ctx=null;var highlights=[];plot.hooks.processOptions.push(function(plot,options){if(options.series.pie.show){options.grid.show=false;if(options.series.pie.label.show=="auto"){if(options.legend.show){options.series.pie.label.show=false}else{options.series.pie.label.show=true}}if(options.series.pie.radius=="auto"){if(options.series.pie.label.show){options.series.pie.radius=3/4}else{options.series.pie.radius=1}}if(options.series.pie.tilt>1){options.series.pie.tilt=1}else if(options.series.pie.tilt<0){options.series.pie.tilt=0}}});plot.hooks.bindEvents.push(function(plot,eventHolder){var options=plot.getOptions();if(options.series.pie.show){if(options.grid.hoverable){eventHolder.unbind("mousemove").mousemove(onMouseMove)}if(options.grid.clickable){eventHolder.unbind("click").click(onClick)}}});plot.hooks.processDatapoints.push(function(plot,series,data,datapoints){var options=plot.getOptions();if(options.series.pie.show){processDatapoints(plot,series,data,datapoints)}});plot.hooks.drawOverlay.push(function(plot,octx){var options=plot.getOptions();if(options.series.pie.show){drawOverlay(plot,octx)}});plot.hooks.draw.push(function(plot,newCtx){var options=plot.getOptions();if(options.series.pie.show){draw(plot,newCtx)}});function processDatapoints(plot,series,datapoints){if(!processed){processed=true;canvas=plot.getCanvas();target=$(canvas).parent();options=plot.getOptions();plot.setData(combine(plot.getData()))}}function combine(data){var total=0,combined=0,numCombined=0,color=options.series.pie.combine.color,newdata=[];for(var i=0;i<data.length;++i){var value=data[i].data;if($.isArray(value)&&value.length==1){value=value[0]}if($.isArray(value)){if(!isNaN(parseFloat(value[1]))&&isFinite(value[1])){value[1]=+value[1]}else{value[1]=0}}else if(!isNaN(parseFloat(value))&&isFinite(value)){value=[1,+value]}else{value=[1,0]}data[i].data=[value]}for(var i=0;i<data.length;++i){total+=data[i].data[0][1]}for(var i=0;i<data.length;++i){var value=data[i].data[0][1];if(value/total<=options.series.pie.combine.threshold){combined+=value;numCombined++;if(!color){color=data[i].color}}}for(var i=0;i<data.length;++i){var value=data[i].data[0][1];if(numCombined<2||value/total>options.series.pie.combine.threshold){newdata.push($.extend(data[i],{data:[[1,value]],color:data[i].color,label:data[i].label,angle:value*Math.PI*2/total,percent:value/(total/100)}))}}if(numCombined>1){newdata.push({data:[[1,combined]],color:color,label:options.series.pie.combine.label,angle:combined*Math.PI*2/total,percent:combined/(total/100)})}return newdata}function draw(plot,newCtx){if(!target){return}var canvasWidth=plot.getPlaceholder().width(),canvasHeight=plot.getPlaceholder().height(),legendWidth=target.children().filter(".legend").children().width()||0;ctx=newCtx;processed=false;maxRadius=Math.min(canvasWidth,canvasHeight/options.series.pie.tilt)/2;centerTop=canvasHeight/2+options.series.pie.offset.top;centerLeft=canvasWidth/2;if(options.series.pie.offset.left=="auto"){if(options.legend.position.match("w")){centerLeft+=legendWidth/2}else{centerLeft-=legendWidth/2}if(centerLeft<maxRadius){centerLeft=maxRadius}else if(centerLeft>canvasWidth-maxRadius){centerLeft=canvasWidth-maxRadius}}else{centerLeft+=options.series.pie.offset.left}var slices=plot.getData(),attempts=0;do{if(attempts>0){maxRadius*=REDRAW_SHRINK}attempts+=1;clear();if(options.series.pie.tilt<=.8){drawShadow()}}while(!drawPie()&&attempts<REDRAW_ATTEMPTS);if(attempts>=REDRAW_ATTEMPTS){clear();target.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>")}if(plot.setSeries&&plot.insertLegend){plot.setSeries(slices);plot.insertLegend()}function clear(){ctx.clearRect(0,0,canvasWidth,canvasHeight);target.children().filter(".pieLabel, .pieLabelBackground").remove()}function drawShadow(){var shadowLeft=options.series.pie.shadow.left;var shadowTop=options.series.pie.shadow.top;var edge=10;var alpha=options.series.pie.shadow.alpha;var radius=options.series.pie.radius>1?options.series.pie.radius:maxRadius*options.series.pie.radius;if(radius>=canvasWidth/2-shadowLeft||radius*options.series.pie.tilt>=canvasHeight/2-shadowTop||radius<=edge){return}ctx.save();ctx.translate(shadowLeft,shadowTop);ctx.globalAlpha=alpha;ctx.fillStyle="#000";ctx.translate(centerLeft,centerTop);ctx.scale(1,options.series.pie.tilt);for(var i=1;i<=edge;i++){ctx.beginPath();ctx.arc(0,0,radius,0,Math.PI*2,false);ctx.fill();radius-=i}ctx.restore()}function drawPie(){var startAngle=Math.PI*options.series.pie.startAngle;var radius=options.series.pie.radius>1?options.series.pie.radius:maxRadius*options.series.pie.radius;ctx.save();ctx.translate(centerLeft,centerTop);ctx.scale(1,options.series.pie.tilt);ctx.save();var currentAngle=startAngle;for(var i=0;i<slices.length;++i){slices[i].startAngle=currentAngle;drawSlice(slices[i].angle,slices[i].color,true)}ctx.restore();if(options.series.pie.stroke.width>0){ctx.save();ctx.lineWidth=options.series.pie.stroke.width;currentAngle=startAngle;for(var i=0;i<slices.length;++i){drawSlice(slices[i].angle,options.series.pie.stroke.color,false)}ctx.restore()}drawDonutHole(ctx);ctx.restore();if(options.series.pie.label.show){return drawLabels()}else return true;function drawSlice(angle,color,fill){if(angle<=0||isNaN(angle)){return}if(fill){ctx.fillStyle=color}else{ctx.strokeStyle=color;ctx.lineJoin="round"}ctx.beginPath();if(Math.abs(angle-Math.PI*2)>1e-9){ctx.moveTo(0,0)}ctx.arc(0,0,radius,currentAngle,currentAngle+angle/2,false);ctx.arc(0,0,radius,currentAngle+angle/2,currentAngle+angle,false);ctx.closePath();currentAngle+=angle;if(fill){ctx.fill()}else{ctx.stroke()}}function drawLabels(){var currentAngle=startAngle;var radius=options.series.pie.label.radius>1?options.series.pie.label.radius:maxRadius*options.series.pie.label.radius;for(var i=0;i<slices.length;++i){if(slices[i].percent>=options.series.pie.label.threshold*100){if(!drawLabel(slices[i],currentAngle,i)){return false}}currentAngle+=slices[i].angle}return true;function drawLabel(slice,startAngle,index){if(slice.data[0][1]==0){return true}var lf=options.legend.labelFormatter,text,plf=options.series.pie.label.formatter;if(lf){text=lf(slice.label,slice)}else{text=slice.label}if(plf){text=plf(text,slice)}var halfAngle=(startAngle+slice.angle+startAngle)/2;var x=centerLeft+Math.round(Math.cos(halfAngle)*radius);var y=centerTop+Math.round(Math.sin(halfAngle)*radius)*options.series.pie.tilt;var html="<span class='pieLabel' id='pieLabel"+index+"' style='position:absolute;top:"+y+"px;left:"+x+"px;'>"+text+"</span>";target.append(html);var label=target.children("#pieLabel"+index);var labelTop=y-label.height()/2;var labelLeft=x-label.width()/2;label.css("top",labelTop);label.css("left",labelLeft);if(0-labelTop>0||0-labelLeft>0||canvasHeight-(labelTop+label.height())<0||canvasWidth-(labelLeft+label.width())<0){return false}if(options.series.pie.label.background.opacity!=0){var c=options.series.pie.label.background.color;if(c==null){c=slice.color}var pos="top:"+labelTop+"px;left:"+labelLeft+"px;";$("<div class='pieLabelBackground' style='position:absolute;width:"+label.width()+"px;height:"+label.height()+"px;"+pos+"background-color:"+c+";'></div>").css("opacity",options.series.pie.label.background.opacity).insertBefore(label)}return true}}}}function drawDonutHole(layer){if(options.series.pie.innerRadius>0){layer.save();var innerRadius=options.series.pie.innerRadius>1?options.series.pie.innerRadius:maxRadius*options.series.pie.innerRadius;layer.globalCompositeOperation="destination-out";layer.beginPath();layer.fillStyle=options.series.pie.stroke.color;layer.arc(0,0,innerRadius,0,Math.PI*2,false);layer.fill();layer.closePath();layer.restore();layer.save();layer.beginPath();layer.strokeStyle=options.series.pie.stroke.color;layer.arc(0,0,innerRadius,0,Math.PI*2,false);layer.stroke();layer.closePath();layer.restore()}}function isPointInPoly(poly,pt){for(var c=false,i=-1,l=poly.length,j=l-1;++i<l;j=i)(poly[i][1]<=pt[1]&&pt[1]<poly[j][1]||poly[j][1]<=pt[1]&&pt[1]<poly[i][1])&&pt[0]<(poly[j][0]-poly[i][0])*(pt[1]-poly[i][1])/(poly[j][1]-poly[i][1])+poly[i][0]&&(c=!c);return c}function findNearbySlice(mouseX,mouseY){var slices=plot.getData(),options=plot.getOptions(),radius=options.series.pie.radius>1?options.series.pie.radius:maxRadius*options.series.pie.radius,x,y;for(var i=0;i<slices.length;++i){var s=slices[i];if(s.pie.show){ctx.save();ctx.beginPath();ctx.moveTo(0,0);ctx.arc(0,0,radius,s.startAngle,s.startAngle+s.angle/2,false);ctx.arc(0,0,radius,s.startAngle+s.angle/2,s.startAngle+s.angle,false);ctx.closePath();x=mouseX-centerLeft;y=mouseY-centerTop;if(ctx.isPointInPath){if(ctx.isPointInPath(mouseX-centerLeft,mouseY-centerTop)){ctx.restore();return{datapoint:[s.percent,s.data],dataIndex:0,series:s,seriesIndex:i}}}else{var p1X=radius*Math.cos(s.startAngle),p1Y=radius*Math.sin(s.startAngle),p2X=radius*Math.cos(s.startAngle+s.angle/4),p2Y=radius*Math.sin(s.startAngle+s.angle/4),p3X=radius*Math.cos(s.startAngle+s.angle/2),p3Y=radius*Math.sin(s.startAngle+s.angle/2),p4X=radius*Math.cos(s.startAngle+s.angle/1.5),p4Y=radius*Math.sin(s.startAngle+s.angle/1.5),p5X=radius*Math.cos(s.startAngle+s.angle),p5Y=radius*Math.sin(s.startAngle+s.angle),arrPoly=[[0,0],[p1X,p1Y],[p2X,p2Y],[p3X,p3Y],[p4X,p4Y],[p5X,p5Y]],arrPoint=[x,y];if(isPointInPoly(arrPoly,arrPoint)){ctx.restore();return{datapoint:[s.percent,s.data],dataIndex:0,series:s,seriesIndex:i}}}ctx.restore()}}return null}function onMouseMove(e){triggerClickHoverEvent("plothover",e)}function onClick(e){triggerClickHoverEvent("plotclick",e)}function triggerClickHoverEvent(eventname,e){var offset=plot.offset();var canvasX=parseInt(e.pageX-offset.left);var canvasY=parseInt(e.pageY-offset.top);var item=findNearbySlice(canvasX,canvasY);if(options.grid.autoHighlight){for(var i=0;i<highlights.length;++i){var h=highlights[i];if(h.auto==eventname&&!(item&&h.series==item.series)){unhighlight(h.series)}}}if(item){highlight(item.series,eventname)}var pos={pageX:e.pageX,pageY:e.pageY};target.trigger(eventname,[pos,item])}function highlight(s,auto){var i=indexOfHighlight(s);if(i==-1){highlights.push({series:s,auto:auto});plot.triggerRedrawOverlay()}else if(!auto){highlights[i].auto=false}}function unhighlight(s){if(s==null){highlights=[];plot.triggerRedrawOverlay()}var i=indexOfHighlight(s);if(i!=-1){highlights.splice(i,1);plot.triggerRedrawOverlay()}}function indexOfHighlight(s){for(var i=0;i<highlights.length;++i){var h=highlights[i];if(h.series==s)return i}return-1}function drawOverlay(plot,octx){var options=plot.getOptions();var radius=options.series.pie.radius>1?options.series.pie.radius:maxRadius*options.series.pie.radius;octx.save();octx.translate(centerLeft,centerTop);octx.scale(1,options.series.pie.tilt);for(var i=0;i<highlights.length;++i){drawHighlight(highlights[i].series)}drawDonutHole(octx);octx.restore();function drawHighlight(series){if(series.angle<=0||isNaN(series.angle)){return}octx.fillStyle="rgba(255, 255, 255, "+options.series.pie.highlight.opacity+")";octx.beginPath();if(Math.abs(series.angle-Math.PI*2)>1e-9){octx.moveTo(0,0)}octx.arc(0,0,radius,series.startAngle,series.startAngle+series.angle/2,false);octx.arc(0,0,radius,series.startAngle+series.angle/2,series.startAngle+series.angle,false);octx.closePath();octx.fill()}}}var options={series:{pie:{show:false,radius:"auto",innerRadius:0,startAngle:3/2,tilt:1,shadow:{left:5,top:15,alpha:.02},offset:{top:0,left:"auto"},stroke:{color:"#fff",width:1},label:{show:"auto",formatter:function(label,slice){return"<div style='font-size:x-small;text-align:center;padding:2px;color:"+slice.color+";'>"+label+"<br/>"+Math.round(slice.percent)+"%</div>"},radius:1,background:{color:null,opacity:0},threshold:0},combine:{threshold:-1,color:null,label:"Other"},highlight:{opacity:.5}}}};$.plot.plugins.push({init:init,options:options,name:"pie",version:"1.1"})})(jQuery);
/*
Axis Labels Plugin for flot.
http://github.com/markrcote/flot-axislabels

Original code is Copyright (c) 2010 Xuan Luo.
Original code was released under the GPLv3 license by Xuan Luo, September 2010.
Original code was rereleased under the MIT license by Xuan Luo, April 2012.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function ($) {
    var options = {
      axisLabels: {
        show: true
      }
    };

    function canvasSupported() {
        return !!document.createElement('canvas').getContext;
    }

    function canvasTextSupported() {
        if (!canvasSupported()) {
            return false;
        }
        var dummy_canvas = document.createElement('canvas');
        var context = dummy_canvas.getContext('2d');
        return typeof context.fillText == 'function';
    }

    function css3TransitionSupported() {
        var div = document.createElement('div');
        return typeof div.style.MozTransition != 'undefined'    // Gecko
            || typeof div.style.OTransition != 'undefined'      // Opera
            || typeof div.style.webkitTransition != 'undefined' // WebKit
            || typeof div.style.transition != 'undefined';
    }


    function AxisLabel(axisName, position, padding, plot, opts) {
        this.axisName = axisName;
        this.position = position;
        this.padding = padding;
        this.plot = plot;
        this.opts = opts;
        this.width = 0;
        this.height = 0;
    }

    AxisLabel.prototype.cleanup = function() {
    };


    CanvasAxisLabel.prototype = new AxisLabel();
    CanvasAxisLabel.prototype.constructor = CanvasAxisLabel;
    function CanvasAxisLabel(axisName, position, padding, plot, opts) {
        AxisLabel.prototype.constructor.call(this, axisName, position, padding,
                                             plot, opts);
    }

    CanvasAxisLabel.prototype.calculateSize = function() {
        if (!this.opts.axisLabelFontSizePixels)
            this.opts.axisLabelFontSizePixels = 14;
        if (!this.opts.axisLabelFontFamily)
            this.opts.axisLabelFontFamily = 'sans-serif';

        var textWidth = this.opts.axisLabelFontSizePixels + this.padding;
        var textHeight = this.opts.axisLabelFontSizePixels + this.padding;
        if (this.position == 'left' || this.position == 'right') {
            this.width = this.opts.axisLabelFontSizePixels + this.padding;
            this.height = 0;
        } else {
            this.width = 0;
            this.height = this.opts.axisLabelFontSizePixels + this.padding;
        }
    };

    CanvasAxisLabel.prototype.draw = function(box) {
        if (!this.opts.axisLabelColour)
            this.opts.axisLabelColour = 'black';
        var ctx = this.plot.getCanvas().getContext('2d');
        ctx.save();
        ctx.font = this.opts.axisLabelFontSizePixels + 'px ' +
            this.opts.axisLabelFontFamily;
        ctx.fillStyle = this.opts.axisLabelColour;
        var width = ctx.measureText(this.opts.axisLabel).width;
        var height = this.opts.axisLabelFontSizePixels;
        var x, y, angle = 0;
        if (this.position == 'top') {
            x = box.left + box.width/2 - width/2;
            y = box.top + height*0.72;
        } else if (this.position == 'bottom') {
            x = box.left + box.width/2 - width/2;
            y = box.top + box.height - height*0.72;
        } else if (this.position == 'left') {
            x = box.left + height*0.72;
            y = box.height/2 + box.top + width/2;
            angle = -Math.PI/2;
        } else if (this.position == 'right') {
            x = box.left + box.width - height*0.72;
            y = box.height/2 + box.top - width/2;
            angle = Math.PI/2;
        }
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillText(this.opts.axisLabel, 0, 0);
        ctx.restore();
    };


    HtmlAxisLabel.prototype = new AxisLabel();
    HtmlAxisLabel.prototype.constructor = HtmlAxisLabel;
    function HtmlAxisLabel(axisName, position, padding, plot, opts) {
        AxisLabel.prototype.constructor.call(this, axisName, position,
                                             padding, plot, opts);
        this.elem = null;
    }

    HtmlAxisLabel.prototype.calculateSize = function() {
        var elem = $('<div class="axisLabels" style="position:absolute;">' +
                     this.opts.axisLabel + '</div>');
        this.plot.getPlaceholder().append(elem);
        // store height and width of label itself, for use in draw()
        this.labelWidth = elem.outerWidth(true);
        this.labelHeight = elem.outerHeight(true);
        elem.remove();

        this.width = this.height = 0;
        if (this.position == 'left' || this.position == 'right') {
            this.width = this.labelWidth + this.padding;
        } else {
            this.height = this.labelHeight + this.padding;
        }
    };

    HtmlAxisLabel.prototype.cleanup = function() {
        if (this.elem) {
            this.elem.remove();
        }
    };

    HtmlAxisLabel.prototype.draw = function(box) {
        this.plot.getPlaceholder().find('#' + this.axisName + 'Label').remove();
        this.elem = $('<div id="' + this.axisName +
                      'Label" " class="axisLabels" style="position:absolute;">'
                      + this.opts.axisLabel + '</div>');
        this.plot.getPlaceholder().append(this.elem);
        if (this.position == 'top') {
            this.elem.css('left', box.left + box.width/2 - this.labelWidth/2 +
                          'px');
            this.elem.css('top', box.top + 'px');
        } else if (this.position == 'bottom') {
            this.elem.css('left', box.left + box.width/2 - this.labelWidth/2 +
                          'px');
            this.elem.css('top', box.top + box.height - this.labelHeight +
                          'px');
        } else if (this.position == 'left') {
            this.elem.css('top', box.top + box.height/2 - this.labelHeight/2 +
                          'px');
            this.elem.css('left', box.left + 'px');
        } else if (this.position == 'right') {
            this.elem.css('top', box.top + box.height/2 - this.labelHeight/2 +
                          'px');
            this.elem.css('left', box.left + box.width - this.labelWidth +
                          'px');
        }
    };


    CssTransformAxisLabel.prototype = new HtmlAxisLabel();
    CssTransformAxisLabel.prototype.constructor = CssTransformAxisLabel;
    function CssTransformAxisLabel(axisName, position, padding, plot, opts) {
        HtmlAxisLabel.prototype.constructor.call(this, axisName, position,
                                                 padding, plot, opts);
    }

    CssTransformAxisLabel.prototype.calculateSize = function() {
        HtmlAxisLabel.prototype.calculateSize.call(this);
        this.width = this.height = 0;
        if (this.position == 'left' || this.position == 'right') {
            this.width = this.labelHeight + this.padding;
        } else {
            this.height = this.labelHeight + this.padding;
        }
    };

    CssTransformAxisLabel.prototype.transforms = function(degrees, x, y) {
        var stransforms = {
            '-moz-transform': '',
            '-webkit-transform': '',
            '-o-transform': '',
            '-ms-transform': ''
        };
        if (x != 0 || y != 0) {
            var stdTranslate = ' translate(' + x + 'px, ' + y + 'px)';
            stransforms['-moz-transform'] += stdTranslate;
            stransforms['-webkit-transform'] += stdTranslate;
            stransforms['-o-transform'] += stdTranslate;
            stransforms['-ms-transform'] += stdTranslate;
        }
        if (degrees != 0) {
            var rotation = degrees / 90;
            var stdRotate = ' rotate(' + degrees + 'deg)';
            stransforms['-moz-transform'] += stdRotate;
            stransforms['-webkit-transform'] += stdRotate;
            stransforms['-o-transform'] += stdRotate;
            stransforms['-ms-transform'] += stdRotate;
        }
        var s = 'top: 0; left: 0; ';
        for (var prop in stransforms) {
            if (stransforms[prop]) {
                s += prop + ':' + stransforms[prop] + ';';
            }
        }
        s += ';';
        return s;
    };

    CssTransformAxisLabel.prototype.calculateOffsets = function(box) {
        var offsets = { x: 0, y: 0, degrees: 0 };
        if (this.position == 'bottom') {
            offsets.x = box.left + box.width/2 - this.labelWidth/2;
            offsets.y = box.top + box.height - this.labelHeight;
        } else if (this.position == 'top') {
            offsets.x = box.left + box.width/2 - this.labelWidth/2;
            offsets.y = box.top;
        } else if (this.position == 'left') {
            offsets.degrees = -90;
            offsets.x = box.left - this.labelWidth/2 + this.labelHeight/2;
            offsets.y = box.height/2 + box.top;
        } else if (this.position == 'right') {
            offsets.degrees = 90;
            offsets.x = box.left + box.width - this.labelWidth/2
                        - this.labelHeight/2;
            offsets.y = box.height/2 + box.top;
        }
        return offsets;
    };

    CssTransformAxisLabel.prototype.draw = function(box) {
        this.plot.getPlaceholder().find("." + this.axisName + "Label").remove();
        var offsets = this.calculateOffsets(box);
        this.elem = $('<div class="axisLabels ' + this.axisName +
                      'Label" style="position:absolute; ' +
                      this.transforms(offsets.degrees, offsets.x, offsets.y) +
                      '">' + this.opts.axisLabel + '</div>');
        this.plot.getPlaceholder().append(this.elem);
    };


    IeTransformAxisLabel.prototype = new CssTransformAxisLabel();
    IeTransformAxisLabel.prototype.constructor = IeTransformAxisLabel;
    function IeTransformAxisLabel(axisName, position, padding, plot, opts) {
        CssTransformAxisLabel.prototype.constructor.call(this, axisName,
                                                         position, padding,
                                                         plot, opts);
        this.requiresResize = false;
    }

    IeTransformAxisLabel.prototype.transforms = function(degrees, x, y) {
        // I didn't feel like learning the crazy Matrix stuff, so this uses
        // a combination of the rotation transform and CSS positioning.
        var s = '';
        if (degrees != 0) {
            var rotation = degrees/90;
            while (rotation < 0) {
                rotation += 4;
            }
            s += ' filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=' + rotation + '); ';
            // see below
            this.requiresResize = (this.position == 'right');
        }
        if (x != 0) {
            s += 'left: ' + x + 'px; ';
        }
        if (y != 0) {
            s += 'top: ' + y + 'px; ';
        }
        return s;
    };

    IeTransformAxisLabel.prototype.calculateOffsets = function(box) {
        var offsets = CssTransformAxisLabel.prototype.calculateOffsets.call(
                          this, box);
        // adjust some values to take into account differences between
        // CSS and IE rotations.
        if (this.position == 'top') {
            // FIXME: not sure why, but placing this exactly at the top causes
            // the top axis label to flip to the bottom...
            offsets.y = box.top + 1;
        } else if (this.position == 'left') {
            offsets.x = box.left;
            offsets.y = box.height/2 + box.top - this.labelWidth/2;
        } else if (this.position == 'right') {
            offsets.x = box.left + box.width - this.labelHeight;
            offsets.y = box.height/2 + box.top - this.labelWidth/2;
        }
        return offsets;
    };

    IeTransformAxisLabel.prototype.draw = function(box) {
        CssTransformAxisLabel.prototype.draw.call(this, box);
        if (this.requiresResize) {
            this.elem = this.plot.getPlaceholder().find("." + this.axisName +
                                                        "Label");
            // Since we used CSS positioning instead of transforms for
            // translating the element, and since the positioning is done
            // before any rotations, we have to reset the width and height
            // in case the browser wrapped the text (specifically for the
            // y2axis).
            this.elem.css('width', this.labelWidth);
            this.elem.css('height', this.labelHeight);
        }
    };


    function init(plot) {
        plot.hooks.processOptions.push(function (plot, options) {

            if (!options.axisLabels.show)
                return;

            // This is kind of a hack. There are no hooks in Flot between
            // the creation and measuring of the ticks (setTicks, measureTickLabels
            // in setupGrid() ) and the drawing of the ticks and plot box
            // (insertAxisLabels in setupGrid() ).
            //
            // Therefore, we use a trick where we run the draw routine twice:
            // the first time to get the tick measurements, so that we can change
            // them, and then have it draw it again.
            var secondPass = false;

            var axisLabels = {};
            var axisOffsetCounts = { left: 0, right: 0, top: 0, bottom: 0 };

            var defaultPadding = 2;  // padding between axis and tick labels
            plot.hooks.draw.push(function (plot, ctx) {
                var hasAxisLabels = false;
                if (!secondPass) {
                    // MEASURE AND SET OPTIONS
                    $.each(plot.getAxes(), function(axisName, axis) {
                        var opts = axis.options // Flot 0.7
                            || plot.getOptions()[axisName]; // Flot 0.6

                        // Handle redraws initiated outside of this plug-in.
                        if (axisName in axisLabels) {
                            axis.labelHeight = axis.labelHeight -
                                axisLabels[axisName].height;
                            axis.labelWidth = axis.labelWidth -
                                axisLabels[axisName].width;
                            opts.labelHeight = axis.labelHeight;
                            opts.labelWidth = axis.labelWidth;
                            axisLabels[axisName].cleanup();
                            delete axisLabels[axisName];
                        }

                        if (!opts || !opts.axisLabel || !axis.show)
                            return;

                        hasAxisLabels = true;
                        var renderer = null;

                        if (!opts.axisLabelUseHtml &&
                            navigator.appName == 'Microsoft Internet Explorer') {
                            var ua = navigator.userAgent;
                            var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
                            if (re.exec(ua) != null) {
                                rv = parseFloat(RegExp.$1);
                            }
                            if (rv >= 9 && !opts.axisLabelUseCanvas && !opts.axisLabelUseHtml) {
                                renderer = CssTransformAxisLabel;
                            } else if (!opts.axisLabelUseCanvas && !opts.axisLabelUseHtml) {
                                renderer = IeTransformAxisLabel;
                            } else if (opts.axisLabelUseCanvas) {
                                renderer = CanvasAxisLabel;
                            } else {
                                renderer = HtmlAxisLabel;
                            }
                        } else {
                            if (opts.axisLabelUseHtml || (!css3TransitionSupported() && !canvasTextSupported()) && !opts.axisLabelUseCanvas) {
                                renderer = HtmlAxisLabel;
                            } else if (opts.axisLabelUseCanvas || !css3TransitionSupported()) {
                                renderer = CanvasAxisLabel;
                            } else {
                                renderer = CssTransformAxisLabel;
                            }
                        }

                        var padding = opts.axisLabelPadding === undefined ?
                                      defaultPadding : opts.axisLabelPadding;

                        axisLabels[axisName] = new renderer(axisName,
                                                            axis.position, padding,
                                                            plot, opts);

                        // flot interprets axis.labelHeight and .labelWidth as
                        // the height and width of the tick labels. We increase
                        // these values to make room for the axis label and
                        // padding.

                        axisLabels[axisName].calculateSize();

                        // AxisLabel.height and .width are the size of the
                        // axis label and padding.
                        // Just set opts here because axis will be sorted out on
                        // the redraw.

                        opts.labelHeight = axis.labelHeight +
                            axisLabels[axisName].height;
                        opts.labelWidth = axis.labelWidth +
                            axisLabels[axisName].width;
                    });

                    // If there are axis labels, re-draw with new label widths and
                    // heights.

                    if (hasAxisLabels) {
                        secondPass = true;
                        plot.setupGrid();
                        plot.draw();
                    }
                } else {
                    secondPass = false;
                    // DRAW
                    $.each(plot.getAxes(), function(axisName, axis) {
                        var opts = axis.options // Flot 0.7
                            || plot.getOptions()[axisName]; // Flot 0.6
                        if (!opts || !opts.axisLabel || !axis.show)
                            return;

                        axisLabels[axisName].draw(axis.box);
                    });
                }
            });
        });
    }


    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'axisLabels',
        version: '2.0'
    });
})(jQuery);

/* Javascript plotting library for jQuery, version 0.8.3.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

*/
(function($){var options={series:{stack:null}};function init(plot){function findMatchingSeries(s,allseries){var res=null;for(var i=0;i<allseries.length;++i){if(s==allseries[i])break;if(allseries[i].stack==s.stack)res=allseries[i]}return res}function stackData(plot,s,datapoints){if(s.stack==null||s.stack===false)return;var other=findMatchingSeries(s,plot.getData());if(!other)return;var ps=datapoints.pointsize,points=datapoints.points,otherps=other.datapoints.pointsize,otherpoints=other.datapoints.points,newpoints=[],px,py,intery,qx,qy,bottom,withlines=s.lines.show,horizontal=s.bars.horizontal,withbottom=ps>2&&(horizontal?datapoints.format[2].x:datapoints.format[2].y),withsteps=withlines&&s.lines.steps,fromgap=true,keyOffset=horizontal?1:0,accumulateOffset=horizontal?0:1,i=0,j=0,l,m;while(true){if(i>=points.length)break;l=newpoints.length;if(points[i]==null){for(m=0;m<ps;++m)newpoints.push(points[i+m]);i+=ps}else if(j>=otherpoints.length){if(!withlines){for(m=0;m<ps;++m)newpoints.push(points[i+m])}i+=ps}else if(otherpoints[j]==null){for(m=0;m<ps;++m)newpoints.push(null);fromgap=true;j+=otherps}else{px=points[i+keyOffset];py=points[i+accumulateOffset];qx=otherpoints[j+keyOffset];qy=otherpoints[j+accumulateOffset];bottom=0;if(px==qx){for(m=0;m<ps;++m)newpoints.push(points[i+m]);newpoints[l+accumulateOffset]+=qy;bottom=qy;i+=ps;j+=otherps}else if(px>qx){if(withlines&&i>0&&points[i-ps]!=null){intery=py+(points[i-ps+accumulateOffset]-py)*(qx-px)/(points[i-ps+keyOffset]-px);newpoints.push(qx);newpoints.push(intery+qy);for(m=2;m<ps;++m)newpoints.push(points[i+m]);bottom=qy}j+=otherps}else{if(fromgap&&withlines){i+=ps;continue}for(m=0;m<ps;++m)newpoints.push(points[i+m]);if(withlines&&j>0&&otherpoints[j-otherps]!=null)bottom=qy+(otherpoints[j-otherps+accumulateOffset]-qy)*(px-qx)/(otherpoints[j-otherps+keyOffset]-qx);newpoints[l+accumulateOffset]+=bottom;i+=ps}fromgap=false;if(l!=newpoints.length&&withbottom)newpoints[l+2]+=bottom}if(withsteps&&l!=newpoints.length&&l>0&&newpoints[l]!=null&&newpoints[l]!=newpoints[l-ps]&&newpoints[l+1]!=newpoints[l-ps+1]){for(m=0;m<ps;++m)newpoints[l+ps+m]=newpoints[l+m];newpoints[l+1]=newpoints[l-ps+1]}}datapoints.points=newpoints}plot.hooks.processDatapoints.push(stackData)}$.plot.plugins.push({init:init,options:options,name:"stack",version:"1.2"})})(jQuery);
/* Flot plugin for automatically redrawing plots as the placeholder resizes.

Copyright (c) 2007-2014 IOLA and Ole Laursen.
Licensed under the MIT license.

It works by listening for changes on the placeholder div (through the jQuery
resize event plugin) - if the size changes, it will redraw the plot.

There are no options. If you need to disable the plugin for some plots, you
can just fix the size of their placeholders.

*/

/* Inline dependency:
 * jQuery resize event - v1.1 - 3/14/2010
 * http://benalman.com/projects/jquery-resize-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($,e,t){"$:nomunge";var i=[],n=$.resize=$.extend($.resize,{}),a,r=false,s="setTimeout",u="resize",m=u+"-special-event",o="pendingDelay",l="activeDelay",f="throttleWindow";n[o]=200;n[l]=20;n[f]=true;$.event.special[u]={setup:function(){if(!n[f]&&this[s]){return false}var e=$(this);i.push(this);e.data(m,{w:e.width(),h:e.height()});if(i.length===1){a=t;h()}},teardown:function(){if(!n[f]&&this[s]){return false}var e=$(this);for(var t=i.length-1;t>=0;t--){if(i[t]==this){i.splice(t,1);break}}e.removeData(m);if(!i.length){if(r){cancelAnimationFrame(a)}else{clearTimeout(a)}a=null}},add:function(e){if(!n[f]&&this[s]){return false}var i;function a(e,n,a){var r=$(this),s=r.data(m)||{};s.w=n!==t?n:r.width();s.h=a!==t?a:r.height();i.apply(this,arguments)}if($.isFunction(e)){i=e;return a}else{i=e.handler;e.handler=a}}};function h(t){if(r===true){r=t||1}for(var s=i.length-1;s>=0;s--){var l=$(i[s]);if(l[0]==e||l.is(":visible")){var f=l.width(),c=l.height(),d=l.data(m);if(d&&(f!==d.w||c!==d.h)){l.trigger(u,[d.w=f,d.h=c]);r=t||true}}else{d=l.data(m);d.w=0;d.h=0}}if(a!==null){if(r&&(t==null||t-r<1e3)){a=e.requestAnimationFrame(h)}else{a=setTimeout(h,n[o]);r=false}}}if(!e.requestAnimationFrame){e.requestAnimationFrame=function(){return e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(t,i){return e.setTimeout(function(){t((new Date).getTime())},n[l])}}()}if(!e.cancelAnimationFrame){e.cancelAnimationFrame=function(){return e.webkitCancelRequestAnimationFrame||e.mozCancelRequestAnimationFrame||e.oCancelRequestAnimationFrame||e.msCancelRequestAnimationFrame||clearTimeout}()}})(jQuery,this);

(function ($) {
    var options = { }; // no options

    function init(plot) {
        function onResize() {
            var placeholder = plot.getPlaceholder();

            // somebody might have hidden us and we can't plot
            // when we don't have the dimensions
            if (placeholder.width() == 0 || placeholder.height() == 0)
                return;

            plot.resize();
            plot.setupGrid();
            plot.draw();
        }
        
        function bindEvents(plot, eventHolder) {
            plot.getPlaceholder().resize(onResize);
        }

        function shutdown(plot, eventHolder) {
            plot.getPlaceholder().unbind("resize", onResize);
        }
        
        plot.hooks.bindEvents.push(bindEvents);
        plot.hooks.shutdown.push(shutdown);
    }
    
    $.plot.plugins.push({
        init: init,
        options: options,
        name: 'resize',
        version: '1.0'
    });
})(jQuery);

/*
Klasse Language
(c) Alexander Herzog

Diese Klasse dient zur Internationalisierung von Javascript-Projekten auf Basis von GetText-po-Dateien.

Methoden:
Language.load(LangID,URL)
Language.setActive(LangID)
Language.info()
Language.tr(ID)
Language.trAll=(ID,testValue)

Variablen:
Language.decimalSeparator
Language.groupSeparator
(Die beiden Variablen werden nicht automatisch beim Aufruf von setActive verndert.)

Notwendige Bibliotheken:
jQuery
*/

'use strict';

function Language() {
  this.loadingLanguage="";
  this.data={};
  this.activeLanguage="en";
  this.decimalSeparator=".";
  this.groupSeparator=",";
}

Language.prototype.processPOString=function(line) {
  line=line.replace(//g,"&auml;"); 
  line=line.replace(//g,"&ouml;"); 
  line=line.replace(//g,"&uuml;"); 
  line=line.replace(//g,"&szlig;"); 
  line=line.replace(//g,"&Auml;"); 
  line=line.replace(//g,"&Ouml;"); 
  line=line.replace(//g,"&Uuml;"); 
  line=line.replace(/\\n/g,"\n");   
  line=line.replace(/</g,"&lt;");
  line=line.replace(/>/g,"&gt;");
  line=line.replace(/\\"/g,"\"");
  
  return line;
}

Language.prototype.processPO=function(data) {
  var language={};
  var msgID=null;
  var msgStr="";
  var lines=data.split("\n");
  for (var i=0;i<lines.length;i++) {
    var line=lines[i].trim();
    if (line=="") {if (msgID!=null) language[msgID]=this.processPOString(msgStr); msgID=null; msgStr=""; continue;}
    if (line[0]=="#") continue;	
    if (msgID==null) {
      if (line.substr(0,6)!="msgid ") {console.log("Error in po line "+i+". Line does not start with msgid. Line: "+line); continue;}
      line=line.substr(6);
      if (line=="" || line[0]!='"' || line.substr(-1,1)!='"') {console.log("Error in po line "+(i+1)+". Line: "+line); continue;}
      msgID=line.substr(1,line.length-2);
    } else {
      if (line.substr(0,7)=="msgstr ") line=line.substr(7);
      if (line=="" || line[0]!='"' || line.substr(-1,1)!='"') {console.log("Error in po line "+(i+1)+". Line: "+line); continue;}
      msgStr+=line.substr(1,line.length-2);
    }  
  }
  if (msgID!=null) language[msgID]=this.processPOString(msgStr);
  return language;
}

Language.prototype.load=function(LangID,URL) {
  this.loadingLanguage=LangID.toLowerCase();
  var that=this;
  $.ajax({
    url: URL,
    async: false,
    mimeType: "text/Plain",  
    success: function(data,textStatus,jqXHR) {that.data[that.loadingLanguage]=that.processPO(data);}
  });
}

Language.prototype.loadFromString=function(LangID,data) {
  this.data[LangID.toLowerCase()]=this.processPO(data);
}

Language.prototype.ajaxResults=function(data,textStatus,jqXHR) {
  this.data[this.loadingLanguage]=this.processPO(data);
}

Language.prototype.setActive=function(LangID) {
  LangID=LangID.toLowerCase();
  if (typeof this.data[LangID]=='undefined') return;
  this.activeLanguage=LangID;
}

Language.prototype.info=function() {
  console.log(Object.keys(this.data).length+" languages");
  for (var langName in this.data) {
    console.log("Language \""+langName+"\": "+Object.keys(this.data[langName]).length+" strings");
  }
}

Language.prototype.addKey=function(ID,obj) {
  for (var langName in this.data) {
    var s=obj[langName];
    if (typeof s!='undefined') this.data[langName][ID]=s;
  }
}

Language.prototype.tr=function(ID) {
  if (typeof ID=='undefined') {
    console.log("Requesting language string for undefined ID value."); return "";
  }
  var lang=this.data[this.activeLanguage];
  if (typeof lang=='undefined') lang=this.data['en'];
  if (typeof lang=='undefined') return "";
  
  var str=lang[ID];
  if (typeof str=='undefined') {
    console.log("Unknown language string: "+ID); str=""+ID;
  }
  return str;
}

Language.prototype.trAllList=function(ID) {
  var list=this.tr(ID).split(";");
  for (var langName in this.data) if (langName!=this.activeLanguage) {
    var a=this.data[langName][ID].split(";");
    for (var i=0;i<a.length;i++) if (list.indexOf(a[i])<0) list.push(a[i]);
  }
  return list;
}

Language.prototype.trAll=function(ID,testValue) {
  var list=this.trAllList(ID);
  if (typeof testValue=='undefined') return list;
  testValue=testValue.toLowerCase();
  for (var i=0;i<list.length;i++) if (list[i].toLowerCase()===testValue) return true;
  return false;
}

function initLanguageDirect(langData,viewerLanguage) {
  var lang=new Language();
  
  lang.loadFromString("en",langData.en);
  lang.loadFromString("de",langData.de);

  initLanguageObject(lang,viewerLanguage);
  return lang;
}

function initLanguage(langFolder,viewerLanguage) {
  var lang=new Language();
  
  lang.load("en",langFolder+"gettext_en.po");
  lang.load("de",langFolder+"gettext_de.po");

  initLanguageObject(lang,viewerLanguage);
  return lang;
}
    
function initLanguageObject(language,viewerLanguage) {
  if (typeof viewerLanguage=='undefined') var viewerLanguage="en";
  
  
  language.setActive(viewerLanguage);
  
  if (viewerLanguage.toLowerCase()=='de') {
    language.decimalSeparator=",";
    language.groupSeparator=".";
  }
  
  language.addKey('HTMLViewer.Information',{de: "Information", en: "Information"});
  language.addKey('HTMLViewer.Save',{de: "%s speichern", en: "Save %s"});
  language.addKey('HTMLViewer.Save.Tooltip',{de: "Aktuelle Ansicht oder gesamte Statistik speichern", en: "Save current page or the whole statistics"});
  language.addKey('HTMLViewer.Save.Data',{de: "Daten", en: "Data"});
  language.addKey('HTMLViewer.Save.XML',{de: "Statistik-XML-Datei", en: "Statistic XML file"});
  language.addKey('HTMLViewer.Print',{de: "Aktuelle Ansicht ausdrucken (bzw. als pdf speichern)", en: "Print current page (or save as pdf)"});
  language.addKey('HTMLViewer.ShowHideTree',{de: "Baumansicht ein-/ausblenden", en: "Show/hide tree"});
  language.addKey('HTMLViewer.ProgramInfo',{de: "Programminfo", en: "Program information"});
  language.addKey('HTMLViewer.EmptyViewer',{de: "W&auml;hlen Sie <b>links</b> in der Baumstruktur ein Element aus, um die zugeh&ouml;rigen Statistik-Informationen angezeigt zu bekommen.", en: "Please select from the tree structure on the <b>left</b> the node for which you want to get information."});
  language.addKey('HTMLViewer.Main.FileAPI.NotAvailable',{de: "Ihr Browser untersttzt leider den Zugriff auf lokale Dateien nicht. Sie knnen momentan lediglich die Beispieldateien direkt vom Server aufrufen.", en: "Your browser does not support accessing local files. You can only load the two example models from the server."});
  language.addKey('HTMLViewer.Main.FileAPI.ErrorDropFileNumber', {de: "Bitte ziehen Sie genau eine Datei auf das Ladefeld.", en: "Please drop exactly one file to the load area."});
  language.addKey('HTMLViewer.Main.Loading',{de: "Analysiere Statistikdaten...", en: "Analyzing statistic data..."});
  language.addKey('HTMLViewer.Main.Loading.Error',{de: "Beim Laden der Statistik-Daten ist folgender Fehler aufgetreten:", en: "While loading the statistic data the following error occured:"});
  language.addKey('HTMLViewer.Main.InitTree', {de: "Baue Statistik-Baum auf...", en: "Initializing the statistic tree..."});
  language.addKey('HTMLViewer.Main.LoadingFromServer',{de: "Lade Statistikdatei vom Server...", en: "Loading statistic file from server..."});
  language.addKey('HTMLViewer.Loader.NoClients',{de: "Es sind keine Kunden-Daten vorhanden.", en: "There are no client data available."});
  language.addKey('HTMLViewer.Loader.NoAgents',{de: "Es sind keine Agenten-Daten vorhanden.", en: "There are no agents data available. "});
  language.addKey('HTMLViewer.Loader.Clients.NoCount',{de: "Der Kundentyp \"%s\" besitzt keine Kundenanzahl-Informationen.", en: "Client type \"%s\" has got no information about the number of clients."});
  language.addKey('HTMLViewer.Loader.Calls.NoCount',{de: "Der Kundentyp \"%s\" besitzt keine Anrufanzahl-Informationen.", en: "Client type \"%s\" has got no information about the number of calls."});
  language.addKey('HTMLViewer.Loader.Clients.NoCarryOver',{de: "Der Kundentyp \"%s\" besitzt keine &Uuml;bertrags-Informationen.", en: "Client type \"%s\" has got no information about carring over canceled clients."});
  language.addKey('HTMLViewer.Loader.Clients.NoWaitingTime',{de: "Der Kundentyp \"%s\" besitzt keine Wartezeit-Informationen.", en: "Client type \"%s\" has got no waiting time information."});
  language.addKey('HTMLViewer.Loader.Clients.NoResidenceTime',{de: "Der Kundentyp \"%s\" besitzt keine Verweilzeit-Informationen.", en: "Client type \"%s\" has got no residence time information."});
  language.addKey('HTMLViewer.Loader.Clients.NoCancelTime',{de: "Der Kundentyp \"%s\" besitzt keine Abbruchzeit-Informationen.", en: "Client type \"%s\" has got no cancel time information."});
  language.addKey('HTMLViewer.Loader.Clients.NoServiceLevel',{de: "Der Kundentyp \"%s\" besitzt keine Service-Level-Informationen.", en: "Client type \"%s\" has got no service level information."});
  language.addKey('HTMLViewer.Loader.Clients.NoForwarding',{de: "Der Kundentyp \"%s\" besitzt keine Weiterleitungs-Informationen.", en: "Client type \"%s\" has got no forwarding information."});
  language.addKey('HTMLViewer.Loader.Clients.NoRetry',{de: "Der Kundentyp \"%s\" besitzt keine Wiederhol-Informationen.", en: "Client type \"%s\" has got no retrx information."});  
  language.addKey('HTMLViewer.Loader.Agents.Incomplete',{de: "Der Agentendatensatz ist unvollst&auml;ndig.", en: "The agents record is incomplete."});
  language.addKey('HTMLViewer.Loader.Agents.InvalidGrossTime',{de: "Die Brutto-Agentenarbeitszeit %s ist ungltig.", en: "The gross agents working hours %s are invalid."});
  language.addKey('HTMLViewer.Loader.Agents.InvalidNetTime',{de: "Die Netto-Agentenarbeitszeit %s ist ungltig.", en: "The net agents working hours %s are invalid."});
  language.addKey('HTMLViewer.Loader.Model.NoFreshCalls',{de: "Das Kunden-Element enth&auml;lt keiner Informationen &uuml;ber die Erstanrufer.", en: "The clients element contains no information on the fresh calls."});
  language.addKey('HTMLViewer.Loader.Model.NoRetry',{de: "Das Kunden-Element enth&auml;lt keine Informationen &uuml;ber Wahlwiederholungen.", en: "The clients element contains no information on retrying clients."});
  language.addKey('HTMLViewer.Loader.Model.InvalidRetry',{de: "Die Wahlwiederholungs-Angaben sind ung&uuml;ltig.", en: "The retry data are invalid."});
  language.addKey('HTMLViewer.Loader.Model.NoForwarding',{de: "Das Kunden-Element enth&auml;lt keine Informationen &uuml;ber Weiterleitungen.", en: "The clients element contains no information on forwarding clients."});
  language.addKey('HTMLViewer.Loader.Model.NoHoldingTimes',{de: "Es sind keine Bedienzeiten definiert.", en: "No holding times were defined."});
  language.addKey('HTMLViewer.Loader.Model.NoPostProcessingTimes',{de: "Es sind keine Nachbearbeitungszeiten definiert.", en: "No post processing times were defined."});
}
/*
Klasse Format
(c) Alexander Herzog
*/

'use strict';

String.prototype.format=function() {
  var formatStr=this, nextValueIndex=0, result="";
  while (formatStr!="") {
    var i=formatStr.indexOf("%");
    if (i<0) {result+=formatStr; formatStr=""; continue;}
    if (i>0) {result+=formatStr.substr(0,i); formatStr=formatStr.substr(i);}
    if (formatStr.substr(0,2)=='%s' || formatStr.substr(0,2)=='%d') {
      if (nextValueIndex<arguments.length) result+=arguments[nextValueIndex];
      nextValueIndex++;
      formatStr=formatStr.substr(2);
    } else {
      result+=formatStr.substr(0,1); formatStr=formatStr.substr(1);
    }
  }
  return result;
}
/*
Klasse CallcenterSimulatorLoader
(c) Alexander Herzog

Diese Klasse dient zum Laden von Callcenter Simulator Modell- und Statistik-
daten aus XML- oder JSON-Daten.

Methoden:
CallcenterSimulatorLoader.loadModelFromXML(xml)
CallcenterSimulatorLoader.loadModelFromRawJSON(data)
CallcenterSimulatorLoader.loadStatistikFromXML(xml)
CallcenterSimulatorLoader.loadStatistikFromRawJSON(xml)
Bei den "xml"-Parametern muss es sich um ein xml-Objekt (wie es z.B. $.ajax
liefert) handeln. Bei den "data"-Parametern muss es sich um ein JSON-Objekt,
welches unmittelbar auf einem XML-Objet aus einer Callcenter Simulator
XML-Datei basiert, handeln.
Im Erfolgsfall liefern die Funktionen jeweils ein JSON-Objekt. Im Fehlerfall
einen String mit der Fehlermeldung.

Notwendige Bibliotheken:
jQuery, jquery.xml2json
*/

'use strict';

function CallcenterSimulatorLoader(language) {
  this.language=language;
}

CallcenterSimulatorLoader.prototype.tr=function(ID) {
  return this.language(tr);
}

CallcenterSimulatorLoader.prototype.trAll=function(ID,testValue) {
  return (typeof testValue=='undefined')?this.language.thAll(ID):this.language.trAll(ID,testValue);
}

CallcenterSimulatorLoader.prototype.asArray=function(data) {
  if (Object.prototype.toString.call(data)!=='[object Array]') return [data]; else return data;
}

CallcenterSimulatorLoader.prototype.zeroDistribution=function(size){
  if (typeof size=='undefined') size=48;
  var s="0";
  for (var i=2;i<=size;i++) s+=";0";
  return s;
}

CallcenterSimulatorLoader.prototype.loadDistribution=function(text) {
  var dist=[];
  var arr=text.split(";");
  for (var i=0;i<arr.length;i++) {
    var num=parseFloat(arr[i]);
	if (isNaN(num)) return null;
	dist.push(num);
  }
  return dist;
}

CallcenterSimulatorLoader.prototype.getLangData=function(parent,languageID) {
  if (typeof parent=='undefined') return parent;
  var list=this.language.trAll(languageID);
  var result;
  for (var i=0;i<list.length;i++) {
    result=parent[list[i]];
    if (typeof result!='undefined') break;
  }
  return result;
}

CallcenterSimulatorLoader.prototype.conditionalLoad=function(field,defaultValue) {
  return (typeof field==='undefined')?defaultValue:field;
}

CallcenterSimulatorLoader.prototype.conditionalLangLoad=function(parent,languageID,defaultValue) {
  return this.conditionalLoad(this.getLangData(parent,languageID),defaultValue);
}

CallcenterSimulatorLoader.prototype.conditionalLoadInt=function(field,defaultValue) {
  if (typeof defaultValue==='undefined') defaultValue=0;
  var num=parseInt(this.conditionalLoad(field,defaultValue));
  if (isNaN(num)) return null;
  return num;
}

CallcenterSimulatorLoader.prototype.conditionalLangLoadInt=function(parent,languageID,defaultValue) {
  return this.conditionalLoadInt(this.getLangData(parent,languageID),defaultValue);
}

CallcenterSimulatorLoader.prototype.conditionalLoadNonNegativeInt=function(field,defaultValue) {
  if (typeof defaultValue==='undefined') defaultValue=0;
  var num=parseInt(this.conditionalLoad(field,defaultValue));
  if (isNaN(num) || num<0) return null;
  return num;
}

CallcenterSimulatorLoader.prototype.conditionalLangLoadNonNegativeInt=function(parent,languageID,defaultValue) {
  return this.conditionalLoadNonNegativeInt(this.getLangData(parent,languageID),defaultValue);
}

CallcenterSimulatorLoader.prototype.conditionalLoadFloat=function(field,defaultValue) {
  if (typeof defaultValue==='undefined') defaultValue=0;
  var str=""+this.conditionalLoad(field,defaultValue);
  var percent=false;
  if (str!="" && str.substr(-1,1)=='%') {percent=true; str=str.substr(0,str.length-1);}
  var num=parseFloat(str.trim());  
  if (isNaN(num)) return null;
  if (percent) num=num/100;
  return num;
}

CallcenterSimulatorLoader.prototype.conditionalLangLoadFloat=function(parent,languageID,defaultValue) {
  return this.conditionalLoadFloat(this.getLangData(parent,languageID),defaultValue);
}

CallcenterSimulatorLoader.prototype.conditionalLoadNonNegativeFloat=function(field,defaultValue) {
  if (typeof defaultValue==='undefined') defaultValue=0;
  var str=""+this.conditionalLoad(field,defaultValue);
  var percent=false;
  if (str!='' && str.substr(-1,1)=='%') {
  percent=true; str=str.substr(0,str.length-1);
  }
  var num=parseFloat(str.trim());
  if (isNaN(num) || num<0) return null;
  if (percent) num=num/100;
  return num;
}

CallcenterSimulatorLoader.prototype.conditionalLangLoadNonNegativeFloat=function(parent,languageID,defaultValue) {
  return this.conditionalLoadNonNegativeFloat(this.getLangData(parent,languageID),defaultValue);
}

CallcenterSimulatorLoader.prototype.conditionalLoadDistribution=function(field,size) {
  return this.loadDistribution(this.conditionalLoad(field,this.zeroDistribution(size)));
}

CallcenterSimulatorLoader.prototype.conditionalLangLoadDistribution=function(parent,languageID,size) {
  return this.conditionalLoadDistribution(this.getLangData(parent,languageID),size);
}

CallcenterSimulatorLoader.prototype.conditionalLoadBool=function(field) {
  var s=this.conditionalLoad(field,'1');
  if (this.trAll("XML.General.BoolFalse",s)) return false;
  return true;
}

CallcenterSimulatorLoader.prototype.conditionalLangLoadBool=function(parent,languageID) {
  return this.conditionalLoadBool(this.getLangData(parent,languageID));
}

CallcenterSimulatorLoader.prototype.conditionalLoadTime=function(field,defaultValue) {
  if (typeof defaultValue==='undefined') defaultValue=0;
  var s=""+this.conditionalLoad(field,defaultValue);
  
  if (s=="") return null;
  var negative=false;

  if (s.substring(0,1)=="-") {negative=true; s=s.substring(1);}

  var i1=s.indexOf('.'), i2=s.indexOf(','), i=-1;
  if (i1>=0 || i2>=0) {if (i1<0) i=i2; else {if (i2<0) i=i1; else i=Math.min(i1,i2);}}
  var frac=0;
  if (i>=0) {
    var frac=parseFloat("0."+s.substring(i+1));
    if (isNaN(frac) || frac<0) return null;
  }
  
  var l=s.split(":");
  if (l.length!=3) return null;

  var result=0;
  for (var i=0;i<3;i++) {
    if (l[i].length>0 && l[i][0]==='0') l[i]=l[i].substring(1);
    if (l[i]=='') l[i]="0";
    var v=parseInt(l[i]);
    if (v==null) return null;
    result*=60;
    result+=v;
  }
  
  var t=result+frac;
  if (negative) t=-t;
  return t;
}

CallcenterSimulatorLoader.prototype.loadModelFromXML=function(xml) {
  return this.loadModelFromRawJSON($.xml2json(xml));
}

CallcenterSimulatorLoader.prototype.loadModelCallerRetryFromRawJSON=function(data) {
  var arr=[[],[]];
  var list=this.getLangData(data,"XML.Model.ClientType.Retry.ClientType.NewClientType");
  if (typeof list==='undefined') return arr;
  var d=this.asArray(list);
  for (var i=0;i<d.length;i++) {
    var rec=d[i];
	arr[0].push(this.conditionalLangLoad(rec,"XML.Model.GeneralAttributes.Name",''));
	var num=this.conditionalLoadNonNegativeFloat(rec); if (num===null) return null;
	arr[1].push(num);
  }  
  return arr;
}

CallcenterSimulatorLoader.prototype.loadModelCallerFromRawJSON=function(data) {
  var dataSub, dataSub2;
  var caller={};
  
  caller.name=this.conditionalLangLoad(data,"XML.Model.GeneralAttributes.Name",'');
  caller.active=this.conditionalLangLoadBool(data,"XML.Model.GeneralAttributes.Active",true);
  
  caller.blocksLine=this.conditionalLangLoadBool(data,"XML.Model.ClientType.BlocksLine",true); 
  caller.serviceLevelSeconds=this.conditionalLangLoadNonNegativeInt(data,"XML.Model.ClientType.ServiceLevel"); if (caller.serviceLevelSeconds===null) return this.language.tr("XML.Model.ClientType.ServiceLevel.Error").format(this.conditionalLangLoad(data,"XML.Model.ClientType.ServiceLevel"));
  
  /* Erstanrufer */
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.FreshCalls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Model.NoFreshCalls");
  caller.freshCallsCountMean=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Model.ClientType.FreshCalls.Count"); if (caller.freshCallsCountMean===null) return this.language.tr("XML.Model.ClientType.FreshCalls.Count.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.FreshCalls.Count"));
  caller.freshCallsCountSD=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Model.ClientType.FreshCalls.StandardDeviation"); if (caller.freshCallsCountSD===null) return this.language.tr("XML.Model.ClientType.FreshCalls.StandardDeviation.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.FreshCalls.StandardDeviation"));
  var dist=this.conditionalLangLoadDistribution(dataSub,"XML.Model.ClientType.FreshCalls.Distribution"); if (dist===null) return this.language.tr("XML.Model.ClientType.FreshCalls.Distribution.Error");
  caller.freshCallsDist24=null;
  caller.freshCallsDist48=null;
  caller.freshCallsDist96=null;
  switch (dist.length) {
    case 24: caller.freshCallsDist24=dist; break;
	case 48: caller.freshCallsDist48=dist; break;
	case 96: caller.freshCallsDist96=dist; break;
	default: return this.language.tr("XML.Model.ClientType.FreshCalls.Distribution.Error");
  }
  
  /* Score */
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.ClientsScore");
  if (typeof dataSub==='undefined') {
    caller.scoreBase=1;
    caller.scoreSecond=0;
    caller.scoreContinued=0;
  } else {
    caller.scoreBase=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.ClientsScore.Base"); if (caller.scoreBase===null) return this.language.tr("XML.Model.ClientType.ClientsScore.Base.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.ClientsScore.Base"));
    caller.scoreSecond=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.ClientsScore.PerWaitingSecond"); if (caller.scoreSecond===null) return this.language.tr("XML.Model.ClientType.ClientsScore.PerWaitingSecond.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.ClientsScore.PerWaitingSecond"));
    caller.scoreContinued=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.ClientsScore.Forwarding"); if (caller.scoreContinued===null) return this.language.tr("XML.Model.ClientType.ClientsScore.Forwarding.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.ClientsScore.Forwarding"));
  }
  
  /* Wartezeittoleranz */
  caller.WAITING_TIME_MODE_OFF=0;
  caller.WAITING_TIME_MODE_SHORT=1;
  caller.WAITING_TIME_MODE_LONG=2;
  caller.WAITING_TIME_MODE_CALC=3;
  caller.waitingTimeDist='';
  caller.waitingTimeDistLong='';
  caller.waitingTimeMode=caller.WAITING_TIME_MODE_OFF;  
  caller.waitingTimeCalcMeanWaitingTime=15;
  caller.waitingTimeCalcCancelProbability=0.05;
  caller.waitingTimeCalcAdd=0;
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.WaitingTimeTolerance.Normal");
  if (typeof dataSub!=='undefined') {
    caller.waitingTimeMode=caller.WAITING_TIME_MODE_SHORT;
	caller.waitingTimeDist=dataSub;
  }
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.WaitingTimeTolerance.Long");
  if (typeof dataSub!=='undefined') {
    caller.waitingTimeMode=caller.WAITING_TIME_MODE_LONG;
	caller.waitingTimeDistLong=dataSub;
  }
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.WaitingTimeTolerance.Estimation");
  if (typeof dataSub!=='undefined') {
    caller.waitingTimeMode=caller.WAITING_TIME_MODE_CALC;
    caller.waitingTimeCalcMeanWaitingTime=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.WaitingTimeTolerance.Estimation.WaitingTime"); if (caller.waitingTimeCalcMeanWaitingTime===null) return this.language.tr("XML.Model.ClientType.WaitingTimeTolerance.Estimation.WaitingTime.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.WaitingTimeTolerance.Estimation.WaitingTime"));
    caller.waitingTimeCalcCancelProbability=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.WaitingTimeTolerance.Estimation.CancelRate"); if (caller.waitingTimeCalcCancelProbability===null) return this.language.tr("XML.Model.ClientType.WaitingTimeTolerance.Estimation.CancelRate.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.WaitingTimeTolerance.Estimation.CancelRate"));
    caller.waitingTimeCalcAdd=this.conditionalLangLoadFloat(dataSub,"XML.Model.ClientType.WaitingTimeTolerance.Estimation.Correction",0); if (caller.waitingTimeCalcAdd===null) return this.language.tr("XML.Model.ClientType.WaitingTimeTolerance.Estimation.Correction.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.WaitingTimeTolerance.Estimation.Correction"));
  }

  /* Wiederholer */
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.Retry");
  if (typeof dataSub==='undefined') return this.language.tr(HTMLViewer.Loader.Model.NoRetry);
  caller.retryTimeDist=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.Distribution",'');
  caller.retryProbabiltyAfterBlockedFirstRetry=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.Retry.Probability.BlockedFirst",0.9); if (caller.retryProbabiltyAfterBlockedFirstRetry===null) return this.language.tr("XML.Model.ClientType.Retry.Probability.BlockedFirst.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.Probability.BlockedFirst"));
  caller.retryProbabiltyAfterBlocked=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.Retry.Probability.Blocked",0.8); if (caller.retryProbabiltyAfterBlocked===null) return this.language.tr("XML.Model.ClientType.Retry.Probability.Blocked.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.Probability.Blocked"));
  caller.retryProbabiltyAfterGiveUpFirstRetry=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.Retry.Probability.CanceledFirst",0.9); if (caller.retryProbabiltyAfterGiveUpFirstRetry===null) return this.language.tr("XML.Model.ClientType.Retry.Probability.CanceledFirst.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.Probability.CanceledFirst"));
  caller.retryProbabiltyAfterGiveUp=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.Retry.Probability.Canceled",0.8); if (caller.retryProbabiltyAfterGiveUp===null) return this.language.tr("XML.Model.ClientType.Retry.Probability.Canceled.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.Probability.Canceled"));
  dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.ClientType.BlockedFirst");
  if (typeof dataSub2!=='undefined') {
    var arr=this.loadModelCallerRetryFromRawJSON(dataSub2);
	if (arr===null) return this.langauge.tr("HTMLViewer.Loader.Model.InvalidRetry");
	caller.retryCallerTypeAfterBlockedFirstRetry=arr[0];
	caller.retryCallerTypeRateAfterBlockedFirstRetry=arr[1];
  }
  dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.ClientType.Blocked");
  if (typeof dataSub2!=='undefined') {
    var arr=this.loadModelCallerRetryFromRawJSON(dataSub2);
	if (arr===null) return this.langauge.tr("HTMLViewer.Loader.Model.InvalidRetry");
	caller.retryCallerTypeAfterBlocked=arr[0];
	caller.retryCallerTypeRateAfterBlocked=arr[1];
  }
  dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.ClientType.CanceledFirst");
  if (typeof dataSub2!=='undefined') {
    var arr=this.loadModelCallerRetryFromRawJSON(dataSub2);
	if (arr===null) return this.langauge.tr("HTMLViewer.Loader.Model.InvalidRetry");
	caller.retryCallerTypeAfterGiveUpFirstRetry=arr[0];
	caller.retryCallerTypeRateAfterGiveUpFirstRetry=arr[1];
  }
  dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Retry.ClientType.Canceled");
  if (typeof dataSub2!=='undefined') {
    var arr=this.loadModelCallerRetryFromRawJSON(dataSub2);
	if (arr===null) return this.langauge.tr("HTMLViewer.Loader.Model.InvalidRetry");
	caller.retryCallerTypeAfterGiveUp=arr[0];
	caller.retryCallerTypeRateAfterGiveUp=arr[1];
  }
  
  /* Weiterleitungen */
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.Forwarding");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Model.NoForwarding");
  caller.continueProbability=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.Forwarding.Probability"); if (caller.continueProbability===null) return this.language.tr("XML.Model.ClientType.Forwarding.Probability.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Forwarding.Probability"));
  caller.continueTypeName=[];
  caller.continueTypeRate=[];
  dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Forwarding.NewClientType");
  if (typeof dataSub2!=='undefined') {
    var d=this.asArray(dataSub2);
    for (var i=0;i<d.length;i++) {
      var rec=d[i];
	  var s=this.conditionalLangLoad(rec,"XML.Model.GeneralAttributes.Name"); caller.continueTypeName.push(s);
	  var num=this.conditionalLoadNonNegativeFloat(rec); if (rec===null) return  this.language.tr("XML.Model.ClientType.Forwarding.NewClientType.Error").format(s);
	  caller.continueTypeRate.push(num);
	}
  }
  caller.continueTypeSkillType=[];
  caller.continueTypeSkillTypeProbability=[];
  caller.continueTypeSkillTypeName=[];
  caller.continueTypeSkillTypeRate=[];
  dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Forwarding.SkillLevelDepending");
  if (typeof dataSub2!=='undefined') {
    var d=this.asArray(dataSub2);
    for (var i=0;i<d.length;i++) {
      var rec=d[i];
	  var name=this.conditionalLangLoad(rec,"XML.Model.ClientType.Forwarding.SkillLevel");
	  caller.continueTypeSkillType.push(name);
	  var num=this.conditionalLangLoadNonNegativeFloat(rec,"XML.Model.ClientType.Forwarding.Probability"); if (typeof num=='undefined') return this.language.tr("XML.Model.ClientType.Forwarding.Probability.Error").format(this.conditionalLangLoad(rec,"XML.Model.ClientType.Forwarding.Probability"));
	  caller.continueTypeSkillTypeProbability.push(num);
	  var rec2=this.conditionalLangLoad(rec,"XML.Model.ClientType.Forwarding.NewClientType");
	  if (typeof rec2!=='undefined') {
	    var list1=[];
	    var list2=[];
	    var e=this.asArray(rec2);
	    for (var j=0;j<e.length;j++) {	
	      var s=this.conditionalLangLoad(e[j],"XML.Model.GeneralAttributes.Name"); list1.push(s);
	      var num=this.conditionalLoadNonNegativeFloat(e[j]); if (rec===null) return  this.language.tr("XML.Model.ClientType.Forwarding.NewClientType.Error").format(s);
	      list2.push(num);
	    }
	    caller.continueTypeSkillTypeName.push(list1);
	    caller.continueTypeSkillTypeRate.push(list2);
	  }
	}
  }
  
  /* Wiederanrufer */
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.Recall");
  if (typeof dataSub==='undefined') {
    caller.continueProbability=0;
    caller.continueTypeName=[];
    caller.continueTypeRate=[];
    caller.continueTypeSkillType=[];
    caller.continueTypeSkillTypeProbability=[];
    caller.continueTypeSkillTypeName=[];
    caller.continueTypeSkillTypeRate=[];  
  } else {
    caller.recallProbability=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.Recall.Probability"); if (caller.recallProbability===null) return this.language.tr("XML.Model.ClientType.Recall.Probability.Error").format(this.conditionalLangLoad(data,"XML.Model.ClientType.Recall.Probability"));
	caller.recallTimeDist=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Recall.IntervalDistribution",'');
    caller.recallTypeName=[];
    caller.recallTypeRate=[];
	dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Recall.NewClientType");
    if (typeof dataSub2!=='undefined') {
      var d=this.asArray(dataSub2);
      for (var i=0;i<d.length;i++) {
        var rec=d[i];
	    var s=this.conditionalLangLoad(rec,"XML.Model.GeneralAttributes.Name"); caller.recallTypeName.push(s);
	    var num=this.conditionalLoadNonNegativeFloat(rec); if (rec===null) return  this.language.tr("XML.Model.ClientType.Recall.NewClientType.Error").format(s);
	    caller.recallTypeRate.push(num);
	  }
    }
    caller.recallTypeSkillType=[];
    caller.recallTypeSkillTypeProbability=[];
    caller.recallTypeSkillTypeName=[];
    caller.recallTypeSkillTypeRate=[];
	dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.ClientType.Recall.SkillLevelDepending");
    if (typeof dataSub2!=='undefined') {
      var d=this.asArray(dataSub2);
      for (var i=0;i<d.length;i++) {
        var rec=d[i];
	    var name=this.conditionalLangLoad(rec,"XML.Model.ClientType.Recall.SkillLevel");
	    caller.recallTypeSkillType.push(name);
	    var num=this.conditionalLangLoadNonNegativeFloat(rec,"XML.Model.ClientType.Recall.Probability"); if (typeof num=='undefined') return this.language.tr("XML.Model.ClientType.Recall.Probability.Error").format(this.conditionalLangLoad(rec,"XML.Model.ClientType.Recall.Probability"));
	    caller.recallTypeSkillTypeProbability.push(num);
		var rec2=this.conditionalLangLoad(rec,"XML.Model.ClientType.Recall.NewClientType");
	    if (typeof rec2!=='undefined') {
	      var list1=[];
	      var list2=[];
	      var e=this.asArray(rec2);
	      for (var j=0;j<e.length;j++) {	
  	        var s=this.conditionalLangLoad(e[j],"XML.Model.GeneralAttributes.Name"); list1.push(s);
	        var num=this.conditionalLoadNonNegativeFloat(e[j]); if (rec===null) return this.language.tr(XML.Model.ClientType.Recall.NewClientType.Error).format(s);
	        list2.push(num);
	      }
	      caller.recallTypeSkillTypeName.push(list1);
	      caller.recallTypeSkillTypeRate.push(list2);
		}
	  }
    }
  }

  /* Gewinn und Kosten */
  this.revenuePerClient=this.conditionalLangLoadNonNegativeFloat(data,"XML.Model.ClientType.YieldPerClient"); if (this.revenuePerClient===null) return this.language.tr("XML.Model.ClientType.YieldPerClient.Error").format(this.conditionalLangLoad(data,"XML.Model.ClientType.YieldPerClient"));
  dataSub=this.conditionalLangLoad(data,"XML.Model.ClientType.CostPerCaller");
  if (typeof dataSub==='undefined') {
    this.costPerCancel=0;
    this.costPerWaitingSec=0;
  } else {
    this.costPerCancel=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.CostPerCaller.Canceling"); if (this.costPerCancel===null) return this.language.tr("XML.Model.ClientType.CostPerCaller.Canceling.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.CostPerCaller.Canceling"));
    this.costPerWaitingSec=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.ClientType.CostPerCaller.WaitingSecond"); if (this.costPerWaitingSec===null) return this.language.tr("XML.Model.ClientType.CostPerCaller.WaitingSecond.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.ClientType.CostPerCaller.WaitingSecond"));
  }
  
  return caller;
}

CallcenterSimulatorLoader.prototype.loadModelAgentsFromRawJSON=function(data) {
  var dataSub;
  var agents={};
  
  agents.active=this.conditionalLangLoadBool(data,"XML.Model.GeneralAttributes.Active",true);
  
  /* Anzahl pro Intervall */
  agents.count=this.conditionalLangLoadInt(data,"XML.Model.AgentsGroup.Count"); if (agents.count===null || agents.count<-3) return this.language.tr("XML.Model.AgentsGroup.Count.Error").format(this.conditionalLangLoad(data,"XML.Model.AgentsGroup.Count"));
  agents.countPerInterval=null;
  
  agents.workingTimeStart=this.conditionalLoad(data,"XML.Model.AgentsGroup.WorkingTimeBegin",'');
  agents.workingTimeEnd=this.conditionalLoad(data,"XML.Model.AgentsGroup.WorkingTimeEnd",'');
  agents.workingNoEndTime=(agents.workingTimeEnd!="");
  
  agents.countPerInterval=null;
  agents.lastShiftIsOpenEnd=false; 
  dataSub=this.conditionalLangLoad(data,"XML.Model.AgentsGroup.Distribution");
  if (typeof dataSub!=='undefined') {
    agents.countPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.AgentsGroup.Distribution"); if (agents.countPerInterval===null) return this.language.tr("XML.Model.AgentsGroup.Distribution.Error");
	var s=this.conditionalLangLoad(dataSub,"XML.Model.AgentsGroup.Distribution.LastShiftIsOpenEnd");
	agents.lastShiftIsOpenEnd=(typeof s!='undefined') && this.language.trAll("XML.General.BoolTrue",s);
	agents.count=-1;
  }
  
  agents.byCallers=null;
  dataSub=this.conditionalLangLoad(data,"XML.Model.AgentsGroup.ByClients");
  if (typeof dataSub!=='undefined') {
    agents.byCallersAvailableHalfhours=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Model.AgentsGroup.ByClients.AgentsHalfHours"); if (agents.byCallersAvailableHalfhours===null) return this.language.tr("XML.Model.AgentsGroup.ByClients.AgentsHalfHours.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.AgentsGroup.ByClients.AgentsHalfHours"));
    agents.byCallers=[];
    agents.byCallersRate=[];
	agents.count=-2;
	dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.AgentsGroup.ByClients.Group");
	if (typeof dataSub2!=='undefined') {
	  var d=this.asArray(dataSub2);
	  for (var i=0;i<d.length;i++) {
	    var rec=d[i];
	    var num=this.conditionalLangLoadNonNegativeFloat(rec,"XML.Model.AgentsGroup.ByClients.Rate"); if (num===null) return this.language.tr("XML.Model.AgentsGroup.ByClients.Rate.Error").format(this.conditionalLangLoad(rec,"XML.Model.AgentsGroup.ByClients.Rate"));
	    agents.byCallersRate.push(num);
	    agents.byCallers.push(this.conditionalLoad(rec));
	  }
	}  
  }

  /* Skill-Level */
  agents.skillLevel=this.conditionalLoad(data,"XML.Model.AgentsGroup.SkillLevel","");
  
  /* Kosten */
  agents.costPerWorkingHour=this.conditionalLangLoadNonNegativeFloat(data,"XML.Model.AgentsGroup.CostsPerHour"); if (agents.costPerWorkingHour===null) return this.language.tr("XML.Model.AgentsGroup.CostsPerHour.Error").format(this.conditionalLangLoad(data,"XML.Model.AgentsGroup.CostsPerHour"));
  agents.costCallerTypes=[];
  agents.costPerCall=[];
  agents.costPerCallMinute=[];
  dataSub=this.conditionalLangLoad(data,"XML.Model.AgentsGroup.CostsPerClientType");
  if (typeof dataSub!=='undefined') {
    var d=this.asArray(dataSub);
    for (var i=0;i<d.length;i++) {
      var rec=d[i];
	  var s1=this.conditionalLangLoad(rec,"XML.Model.AgentsGroup.CostsPerClientType.ClientType"); if (s1===null || s1=='') return this.language.tr("XML.Model.AgentsGroup.CostsPerClientType.ClientType.Error");
	  var s2=this.conditionalLangLoadNonNegativeFloat(rec,"XML.Model.AgentsGroup.CostsPerClientType.PerCall"); if (s2===null) return this.language.tr("XML.Model.AgentsGroup.CostsPerClientType.PerCall.Error1").format(s1);
	  var s3=this.conditionalLangLoadNonNegativeFloat(rec,"XML.Model.AgentsGroup.CostsPerClientType.PerMinute"); if (s3===null) return this.language.tr("XML.Model.AgentsGroup.CostsPerClientType.PerMinute.Error1").format(s1);
	  costCallerTypes.push(s1);
	  agents.costPerCall.push(s2);
      agents.costPerCallMinute.push(s3);
	}
  }

  /* Schichtlnge */
  agents.preferredShiftLength=this.conditionalLangLoadInt(data,"XML.Model.PreferredShiftLength",-1);
  if (agents.preferredShiftLength===null || agents.preferredShiftLength==0) return this.language.tr("XML.Model.PreferredShiftLength.Error");
  if (agents.preferredShiftLength<0) agents.preferredShiftLength=-1;
  
  /* Produktivitt */
  agents.efficiencyPerInterval=null;
  if (typeof this.conditionalLangLoad(data,"XML.Model.Productivity")!=='undefined') {
    agents.efficiencyPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.Productivity"); if (agents.efficiencyPerInterval===null) return this.language.tr("XML.Model.Productivity.ErrorAgents");
  }
  
  /* Zuschlag */
  agents.additionPerInterval=null;
  if (typeof this.conditionalLangLoad(data,"XML.Model.Surcharge")!=='undefined') {
    agents.additionPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.Surcharge"); if (agents.additionPerInterval===null) return this.language.tr("XML.Model.Surcharge.ErrorAgents");
  }
  
  if (agents.count==-1 && agents.countPerInterval==null && agents.byCallers==null) return this.language.tr("XML.Model.AgentsGroup.ErrorDistribution");
  
  return agents;
}

CallcenterSimulatorLoader.prototype.loadModelCallcenterFromRawJSON=function(data) {
  var dataSub;
  var callcenter={};
  
  callcenter.name=this.conditionalLangLoad(data,"XML.Model.GeneralAttributes.Name",'');
  callcenter.active=this.conditionalLangLoadBool(data,"XML.Model.GeneralAttributes.Active",true);
  
  /* Agentengruppen */
  callcenter.agents=[];
  dataSub=this.conditionalLangLoad(data,"XML.Model.AgentsGroup");
  if (typeof dataSub!=='undefined') {
    var d=this.asArray(dataSub);
    for (var i=0;i<d.length;i++) {
      var agent=this.loadModelAgentsFromRawJSON(d[i]);
	  if (typeof agent==='string') return agent;
	  callcenter.agents.push(agent);
    }
  }
  
  /* Allgemeine Parameter */
  callcenter.technicalFreeTime=this.conditionalLangLoadNonNegativeInt(data,"XML.Model.CallCenter.TechnicalFreeTime"); if (callcenter.technicalFreeTime===null) return this.language.tr("XML.Model.CallCenter.TechnicalFreeTime.Error").format(this.conditionalLangLoad(data,"XML.Model.CallCenter.TechnicalFreeTime"));
  callcenter.technicalFreeTimeIsWaitingTime=this.conditionalLangLoadBool(this.conditionalLangLoad(data,"XML.Model.CallCenter.TechnicalFreeTime"),"XML.Model.CallCenter.TechnicalFreeTime.IsWaitingTime");
  
  /* Score */
  callcenter.score=this.conditionalLangLoadNonNegativeInt(data,"XML.Model.CallCenter.Score"); if (callcenter.score===null) return this.language.tr("XML.Model.CallCenter.Score.Error").format(this.conditionalLangLoad(data,"XML.Model.CallCenter.Score"));
  dataSub=this.conditionalLangLoad(data,"XML.Model.CallCenter.AgentsScore");
  if (typeof dataSub==='undefined') {
    callcenter.agentScoreFreeTimeSinceLastCall=1;
    callcenter.agentScoreFreeTimePart=0;
  } else {
    callcenter.agentScoreFreeTimeSinceLastCall=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.CallCenter.AgentsScore.FactorSinceLastCall"); if (callcenter.agentScoreFreeTimeSinceLastCall===null) return this.language.tr("XML.Model.CallCenter.AgentsScore.FactorSinceLastCall.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.CallCenter.AgentsScore.FactorSinceLastCall"));
    callcenter.agentScoreFreeTimePart=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Model.CallCenter.AgentsScore.FactorFreeTimePart"); if (callcenter.agentScoreFreeTimePart===null) return this.language.tr("XML.Model.CallCenter.AgentsScore.FactorFreeTimePart.Error").format(this.conditionalLangLoad(dataSub,"XML.Model.CallCenter.AgentsScore.FactorFreeTimePart"));
  }
  
  /* Mindestwartezeiten */
  callcenter.callerMinWaitingTimeName=[];
  callcenter.callerMinWaitingTime=[];
  dataSub=this.conditionalLangLoad(data,"XML.Model.CallCenter.MinimumWaitingTime");
  if (typeof dataSub!='undefined') {
    var dataSub2=this.conditionalLangLoad(dataSub,"XML.Model.CallCenter.MinimumWaitingTime.ClientType");
    if (typeof dataSub2!=='undefined') {
      var d=this.asArray(dataSub2);
      for (var i=0;i<d.length;i++) {
	    var rec=d[i];
	    callcenter.callerMinWaitingTimeName.push(this.conditionalLangLoad(rec,"XML.Model.GeneralAttributes.Name"));
	    var num=this.conditionalLoadNonNegativeInt(rec); if (num===null) return this.language.tr("XML.Model.CallCenter.MinimumWaitingTime.ClientType.Error").format(this.conditionalLoad(rec));
	    callcenter.callerMinWaitingTime.push(num);
	  }
	}
  }  

  /* Produktivitt */
  callcenter.efficiencyPerInterval=null;
  if (typeof this.conditionalLangLoad(data,"XML.Model.Productivity")!=='undefined') {
    callcenter.efficiencyPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.Productivity"); if (callcenter.efficiencyPerInterval===null) return this.language.tr("XML.Model.Productivity.ErrorCallCenter");
  }
  
  /* Zuschlag */
  callcenter.additionPerInterval=null;
  if (typeof this.conditionalLangLoad(data,"XML.Model.Surcharge")!=='undefined') {
    callcenter.additionPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.Surcharge"); if (callcenter.additionPerInterval===null) return this.language.tr("XML.Model.Surcharge.ErrorCallCenter");
  }
  
  return callcenter;
}

CallcenterSimulatorLoader.prototype.loadModelSkillFromRawJSON=function(data) {
  var dataSub, dataSub2, rec, e, interval;
  var skill={};

  skill.callerTypeWorkingTimeMaxX=3600;
  skill.callerTypePostProcessingTimeMaxX=3600;
  
  skill.name=this.conditionalLangLoad(data,"XML.Model.GeneralAttributes.Name",'');
  
  skill.callerTypeName=[];
  skill.callerTypeWorkingTimeAddOn=[];
  skill.callerTypeIntervalWorkingTimeAddOn=[];
  skill.callerTypeWorkingTime=[];
  skill.callerTypeIntervalWorkingTime=[];
  skill.callerTypePostProcessingTime=[];
  skill.callerTypeIntervalPostProcessingTime=[];
  skill.callerTypeScore=[];
  dataSub=this.conditionalLangLoad(data,"XML.Model.SkillLevel.ClientType");
  if (typeof dataSub!=='undefined') {
    var d=this.asArray(dataSub);
    for (var i=0;i<d.length;i++) {
      var level=d[i];
	  skill.callerTypeName.push(this.conditionalLangLoad(level,"XML.Model.GeneralAttributes.Name",""));
	  
	  var intervalData=[];
	  for (var j=0;j<48;j++) intervalData.push(null);
	  dataSub2=this.conditionalLangLoad(level,"XML.Model.SkillLevel.ClientType.HoldingTimeAddOn");
	  if (typeof dataSub2=='undefined') dataSub2="0";
	  e=this.asArray(dataSub2);
	  for (var j=0;j<e.length;j++) {
	    rec=e[j];
		interval=this.conditionalLangLoadInt(rec,"XML.Model.SkillLevel.Interval","-1");
		if (interval>=0 && interval<=47) intervalData[interval]=rec; else skill.callerTypeWorkingTimeAddOn.push(rec);	    
	  }
	  skill.callerTypeIntervalWorkingTimeAddOn.push(intervalData);
	  
	  var intervalData=[];
	  for (var j=0;j<48;j++) intervalData.push(null);
	  dataSub2=this.conditionalLangLoad(level,"XML.Model.SkillLevel.ClientType.HoldingTimeDistribution");
	  if (typeof dataSub2=='undefined') return this.language.tr("HTMLViewer.Loader.Model.NoHoldingTimes");
	  e=this.asArray(dataSub2);
	  for (var j=0;j<e.length;j++) {
	    rec=e[j];
		interval=this.conditionalLangLoadInt(rec,"XML.Model.SkillLevel.Interval","-1");
		if (interval>=0 && interval<=47) intervalData[interval]=rec; else skill.callerTypeWorkingTime.push(rec);	    
	  }
	  skill.callerTypeIntervalWorkingTime.push(intervalData);

	  intervalData=[];
	  for (var j=0;j<48;j++) intervalData.push(null);

	  dataSub2=this.conditionalLangLoad(level,"XML.Model.SkillLevel.ClientType.PostProcessingTimeDistribution");
	  if (typeof dataSub2=='undefined') return this.language.tr("HTMLViewer.Loader.Model.NoPostProcessingTimes");
	  e=this.asArray(dataSub2);
	  for (var j=0;j<e.length;j++) {
	    rec=e[j];
		interval=this.conditionalLangLoadInt(rec,"XML.Model.SkillLevel.Interval","-1");
		if (interval>=0 && interval<=47) intervalData[interval]=rec; else skill.callerTypePostProcessingTime.push(rec);	    
	  }
	  skill.callerTypeIntervalPostProcessingTime.push(intervalData);

	  var num;
	  skill.callerTypeScore.push(num=this.conditionalLangLoadNonNegativeFloat(level,"XML.Model.SkillLevel.ClientType.Score")); if (num===null) return this.language.tr("XML.Model.SkillLevel.ClientType.Score.Error").format(skill.callerTypeName.length+1);
	}
  }

  return skill;
}


CallcenterSimulatorLoader.prototype.loadWarningFromRawJSON=function(data,withStatistics) {
  var warning={};
    
  warning.WARNING_TYPE_WAITINGTIME_CALL=0;
  warning.WARNING_TYPE_WAITINGTIME_CLIENT=1;
  warning.WARNING_TYPE_RESIDENCETIME_CALL=2;
  warning.WARNING_TYPE_RESIDENCETIME_CLIENT=3;
  warning.WARNING_TYPE_SUCCESSPART_CALL=4;
  warning.WARNING_TYPE_SUCCESSPART_CLIENT=5;
  warning.WARNING_TYPE_SERVICELEVEL_CALL_SUCCESSFUL=6;
  warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_SUCCESSFUL=7;
  warning.WARNING_TYPE_SERVICELEVEL_CALL_ALL=8;
  warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_ALL=9;
  warning.WARNING_TYPE_WORKLOAD=10;
    
  warning.WARNING_MODE_AVERAGE=0;
  warning.WARNING_MODE_EACH=1;
  warning.WARNING_MODE_SELECTED=2;
    
  warning.WARNING_STATUS_OK=0;
  warning.WARNING_STATUS_YELLOW=1;
  warning.WARNING_STATUS_RED=2;
    
  /* Typ */    
  var typeString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.Type",'');
  warning.type=-1;
  if (this.trAll("XML.Model.Warnings.Record.Type.WaitingTimeCalls",typeString)) warning.type=warning.WARNING_TYPE_WAITINGTIME_CALL;
  if (this.trAll("XML.Model.Warnings.Record.Type.WaitingTimeClients",typeString)) warning.type=warning.WARNING_TYPE_WAITINGTIME_CLIENT;
  if (this.trAll("XML.Model.Warnings.Record.Type.ResidenceTimeCalls",typeString)) warning.type=warning.WARNING_TYPE_RESIDENCETIME_CALL;
  if (this.trAll("XML.Model.Warnings.Record.Type.ResidenceTimeClients",typeString)) warning.type=warning.WARNING_TYPE_RESIDENCETIME_CLIENT;
  if (this.trAll("XML.Model.Warnings.Record.Type.SuccessPartCalls",typeString)) warning.type=warning.WARNING_TYPE_SUCCESSPART_CALL;
  if (this.trAll("XML.Model.Warnings.Record.Type.SuccessPartClients",typeString)) warning.type=warning.WARNING_TYPE_SUCCESSPART_CLIENT;
  if (this.trAll("XML.Model.Warnings.Record.Type.ServiceLevelOnSuccessfulCalls",typeString)) warning.type=warning.WARNING_TYPE_SERVICELEVEL_CALL_SUCCESSFUL;
  if (this.trAll("XML.Model.Warnings.Record.Type.ServiceLevelOnSuccessfulClients",typeString)) warning.type=warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_SUCCESSFUL;
  if (this.trAll("XML.Model.Warnings.Record.Type.ServiceLevelOnAllCalls",typeString)) warning.type=warning.WARNING_TYPE_SERVICELEVEL_CALL_ALL;
  if (this.trAll("XML.Model.Warnings.Record.Type.ServiceLevelOnAllClients",typeString)) warning.type=warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_ALL;
  if (this.trAll("XML.Model.Warnings.Record.Type.Workload",typeString)) warning.type=warning.WARNING_TYPE_WORKLOAD;
  if (warning.type==-1) return this.language.tr("XML.Model.Warnings.Record.Type.Error.NoType");

  /* Intervalle */
  warning.modeTime=-1;
  var intervalsString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.Intervals",'');
  if (this.trAll("XML.Model.Warnings.Record.Intervals.Average",intervalsString)) warning.modeTime=warning.WARNING_MODE_AVERAGE;
  if (this.trAll("XML.Model.Warnings.Record.Intervals.Each",intervalsString)) warning.modeTime=warning.WARNING_MODE_EACH;
  if (warning.modeTime==-1) {
    var dist=this.loadDistribution(intervalsString); if (dist===null || dist.length!=48) return this.language.tr("XML.Model.Warnings.Record.Intervals.Error.NoInterval");
	warning.modeTime=warning.WARNING_MODE_SELECTED;
	warning.intervals=dist;
  }

  /* Gruppen */
  warning.modeGroup=-1;
  var groupsString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.Groups",'');
  if (this.trAll("XML.Model.Warnings.Record.Groups.Average",groupsString)) warning.modeGroup=warning.WARNING_MODE_AVERAGE;
  if (this.trAll("XML.Model.Warnings.Record.Groups.Each",groupsString)) warning.modeGroup=warning.WARNING_MODE_EACH;
  if (warning.modeGroup==-1) {
	if (groupsString.trim()=='') return this.language.tr("XML.Model.Warnings.Record.Groups.Error.NoGroup");
	warning.modeGroup=warning.WARNING_MODE_SELECTED;
	warning.group=groupsString;
  }

  /* Wertebereich */
  var warningYellowString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.WarningYellow",'');
  var warningRedString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.WarningRed",'');
  if (warningYellowString.trim()=='') return this.language.tr("XML.Model.Warnings.Record.WarningYellow.Error.NoValue");
  if (warningRedString.trim()=='') return this.language.tr("XML.Model.Warnings.Record.WarningRed.Error.NoValue");

  var D;
  switch (warning.type) {
    case warning.WARNING_TYPE_WAITINGTIME_CALL:
    case warning.WARNING_TYPE_WAITINGTIME_CLIENT:
    case warning.WARNING_TYPE_RESIDENCETIME_CALL:
    case warning.WARNING_TYPE_RESIDENCETIME_CLIENT:
      D=this.conditionalLoadTime(warningYellowString);
      if (D==null || D<0) return this.language.tr("XML.Model.Warnings.Record.WarningYellow.Error.InvalidValue");
      warning.warningYellow=D;
      D=this.conditionalLoadTime(warningRedString);
      if (D==null || D<0) return this.language.tr("XML.Model.Warnings.Record.WarningRed.Error.InvalidValue");
	  warning.warningRed=D;
      break;
    case warning.WARNING_TYPE_SUCCESSPART_CALL:
    case warning.WARNING_TYPE_SUCCESSPART_CLIENT:
    case warning.WARNING_TYPE_SERVICELEVEL_CALL_SUCCESSFUL:
    case warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_SUCCESSFUL:
    case warning.WARNING_TYPE_SERVICELEVEL_CALL_ALL:
    case warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_ALL:
    case warning.WARNING_TYPE_WORKLOAD:
      D=this.conditionalLoadNonNegativeFloat(warningYellowString);
      if (D==null || D<0) return this.language.tr("XML.Model.Warnings.Record.WarningYellow.Error.InvalidValue");
      warning.warningYellow=D;
      D=this.conditionalLoadNonNegativeFloat(warningRedString);
      if (D==null || D<0) return this.language.tr("XML.Model.Warnings.Record.WarningRed.Error.InvalidValue");
      warning.warningRed=D;
      break;
  }

  /* Wert */
  if (withStatistics) {
    var valueString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.Value",'');
    if (valueString.trim()=='') return this.language.tr("XML.Model.Warnings.Record.Value.Error.NoValue");
    switch (warning. type) {
      case warning.WARNING_TYPE_WAITINGTIME_CALL:
      case warning.WARNING_TYPE_WAITINGTIME_CLIENT:
      case warning.WARNING_TYPE_RESIDENCETIME_CALL:
      case warning.WARNING_TYPE_RESIDENCETIME_CLIENT:
        D=this.conditionalLoadTime(valueString);
		if (D==null || D<0) return this.language.tr("XML.Model.Warnings.Record.Value.Error.InvalidValue");
		warning.value=D;
        break;
      case warning.WARNING_TYPE_SUCCESSPART_CALL:
      case warning.WARNING_TYPE_SUCCESSPART_CLIENT:
      case warning.WARNING_TYPE_SERVICELEVEL_CALL_SUCCESSFUL:
      case warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_SUCCESSFUL:
      case warning.WARNING_TYPE_SERVICELEVEL_CALL_ALL:
      case warning.WARNING_TYPE_SERVICELEVEL_CLIENTS_ALL:
      case warning.WARNING_TYPE_WORKLOAD:
        D=this.conditionalLoadNonNegativeFloat(valueString);
        if (D==null || D<0) return this.language.tr("XML.Model.Warnings.Record.Value.Error.InvalidValue");
        warning.value=D;
        break;
    }
  }

  /* Warnungsstatus */
  if (withStatistics) {
    warning.warningStatus=-1;
    var warningStatusString=this.conditionalLangLoad(data,"XML.Model.Warnings.Record.Status",'');
    if (this.trAll("XML.Model.Warnings.Record.Status.Ok",warningStatusString)) warning.warningStatus=warning.WARNING_STATUS_OK;
    if (this.trAll("XML.Model.Warnings.Record.Status.Yellow",warningStatusString)) warning.warningStatus=warning.WARNING_STATUS_YELLOW;
    if (this.trAll("XML.Model.Warnings.Record.Status.Red",warningStatusString)) warning.warningStatus=warning.WARNING_STATUS_RED;
    if (warning.warningStatus==-1) return Language.tr("XML.Model.Warnings.Record.Status.Error.NoData");
  }

  return warning;
}

CallcenterSimulatorLoader.prototype.loadModelFromRawJSON=function(data) {
  var model={};
  
  model.name=this.conditionalLangLoad(data,"XML.Model.Name",'');
  model.date=this.conditionalLangLoad(data,"XML.Model.Date",'');
  model.description=this.conditionalLangLoad(data,"XML.Model.Description",'');
  model.version=this.conditionalLangLoad(data,"XML.Model.Version",'');  
  model.maxQueueLength=this.conditionalLangLoad(data,"XML.Model.MaxQueueLength");  
  model.days=this.conditionalLangLoadNonNegativeInt(data,"XML.Model.Days"); if (model.days===null) return this.language.tr("XML.Model.Days.Error");
  model.preferredShiftLength=this.conditionalLangLoadNonNegativeInt(data,"XML.Model.PreferredShiftLength"); if (model.preferredShiftLength===null) return this.language.tr("XML.Model.PreferredShiftLength.Error");
  model.serviceLevelSeconds=this.conditionalLangLoadNonNegativeInt(data,"XML.Model.ServiceLevel"); if (model.serviceLevelSeconds===null) return this.language.tr("XML.Model.ServiceLevel.Error");  
  model.efficiencyPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.Productivity"); if (model.efficiencyPerInterval===null) return this.language.tr("XML.Model.Productivity.Error");
  model.additionPerInterval=this.conditionalLangLoadDistribution(data,"XML.Model.Surcharge"); if (model.additionPerInterval===null) return this.language.tr("XML.Model.Surcharge.Error");
  
  model.caller=[];
  if (typeof this.conditionalLangLoad(data,"XML.Model.ClientType")!=='undefined') {
    var d=this.asArray(this.conditionalLangLoad(data,"XML.Model.ClientType"));
    for (var i=0;i<d.length;i++) {
      var obj=this.loadModelCallerFromRawJSON(d[i]);
	  if (typeof obj==='string') return obj+' '+this.language.tr("XML.Model.ClientType.Error").format(model.caller.length+1);
	  model.caller.push(obj);
	}
  }
  
  model.callcenter=[];
  if (typeof this.conditionalLangLoad(data,"XML.Model.CallCenter")!=='undefined') {
    var d=this.asArray(this.conditionalLangLoad(data,"XML.Model.CallCenter"));
    for (var i=0;i<d.length;i++)  {
      var obj=this.loadModelCallcenterFromRawJSON(d[i]);
	  if (typeof obj==='string') return obj+' '+this.language.tr("XML.Model.CallCenter.Error").format(model.callcenter.length+1);
	  model.callcenter.push(obj);
	}
  }
  
  model.skills=[];
  if (typeof this.conditionalLangLoad(data,"XML.Model.SkillLevel")!=='undefined') {    
    var d=this.asArray(this.conditionalLangLoad(data,"XML.Model.SkillLevel"));
    for (var i=0;i<d.length;i++)  {
      var obj=this.loadModelSkillFromRawJSON(d[i]);
	  if (typeof obj==='string') return obj+' '+this.language.tr("XML.Model.SkillLevel.Error").format(model.skills.length+1);
	  model.skills.push(obj);
	}
  }
  
  model.warnings=[];
  if (typeof this.conditionalLangLoad(data,"XML.Model.Warnings")!=='undefined') {
    var sub=this.conditionalLangLoad(data,"XML.Model.Warnings");
    if (typeof this.conditionalLangLoad(sub,"XML.Model.Warnings.Record")!=='undefined') {      
      var d=this.asArray(this.conditionalLangLoad(sub,"XML.Model.Warnings.Record"));
      for (var i=0;i<d.length;i++)  {
        var obj=this.loadWarningFromRawJSON(d[i],false);
	    if (typeof obj==='string') return obj+' '+this.language.tr("XML.Model.Warnings.Error").format(model.warnings.length+1);
	    model.warnings.push(obj);
      }
    }
  }

  return model;
}

CallcenterSimulatorLoader.prototype.loadStatistikFromXML=function(xml) {
  return this.loadStatistikFromRawJSON($.xml2json(xml));
}

CallcenterSimulatorLoader.prototype.loadStatistikFromRawJSON=function(data) {
  var statistik={};
  
  /* Allgemeine Daten */
  statistik.editModel=(typeof this.conditionalLangLoad(data,"XML.Model.BaseElement")==='undefined')?{}:this.loadModelFromRawJSON(this.conditionalLangLoad(data,"XML.Model.BaseElement")); if (typeof statistik.editModel==='string') return statistik.editModel;
  statistik.runDate=this.conditionalLangLoad(data,"XML.Statistic.Info.RunDate",'');
  statistik.runUser=this.conditionalLangLoad(data,"XML.Statistic.Info.User",'');
  statistik.runServer=this.conditionalLangLoad(data,"XML.Statistic.Info.Server",'');
  statistik.runServerOS=this.conditionalLangLoad(data,"XML.Statistic.Info.ServerOS",'');
  statistik.runTime=this.conditionalLangLoadNonNegativeInt(data,"XML.Statistic.Info.RunTime"); if (statistik.runTime===null) return this.language.tr("XML.Statistic.Info.RunTime.Error").format(this.conditionalLangLoad(data,"XML.Statistic.Info.RunTime"));
  statistik.runThreads=this.conditionalLangLoadNonNegativeInt(data,"XML.Statistic.Info.Threads"); if (statistik.runThreads===null) return this.language.tr("XML.Statistic.Info.Threads.Error").format(this.conditionalLangLoad(data,"XML.Statistic.Info.Threads"));
  statistik.simDays=this.conditionalLangLoadNonNegativeInt(data,"XML.Statistic.Info.SimulatedDays"); if (statistik.simDays===null) return this.language.tr("XML.Statistic.Info.SimulatedDays.Error").format(this.conditionalLangLoad(data,"XML.Statistic.Info.SimulatedDays"));
  statistik.simEvents=this.conditionalLangLoadNonNegativeInt(data,"XML.Statistic.Info.SimulatedEvents"); if (statistik.simEvents===null) return this.language.tr("XML.Statistic.Info.SimulatedEvents.Error").format(this.conditionalLangLoad(data,"XML.Statistic.Info.SimulatedEvents"));
  
  /* Kunden */
  if (typeof this.conditionalLangLoad(data,"XML.Statistic.Clients")==='undefined') return this.language.tr("HTMLViewer.Loader.NoClients");
  statistik.kundenProTyp=[]; 
  var d=this.asArray(this.conditionalLangLoad(data,"XML.Statistic.Clients")); 
  for (var i=0;i<d.length;i++) {
    var k=this.loadStatistikKundenFromRawJSON(d[i],statistik.simDays);
	if (typeof k==='string') return k;
    if (k.name=='') statistik.kundenGlobal=k; else statistik.kundenProTyp.push(k);
  }
  
  /* Agenten */
  if (typeof this.conditionalLangLoad(data,"XML.Statistic.Agents")==='undefined') return this.language.tr("HTMLViewer.Loader.NoAgents");
  statistik.agentenProCallcenter=[];
  statistik.agentenProSkilllevel=[]; 
  var d=this.asArray(this.conditionalLangLoad(data,"XML.Statistic.Agents"));
  for (var i=0;i<d.length;i++) {
    var a=this.loadStatistikAgentenFromRawJSON(d[i]);
	if (typeof a==='string') return a;
    if (a.name=='') statistik.agentenGlobal=a; else {
	  if (a.type=="Callcenter") statistik.agentenProCallcenter.push(a); else statistik.agentenProSkilllevel.push(a);
	}
  }
  
  /* Warteschlangenlnge */
  var ws={};
  if (typeof this.conditionalLangLoad(data,"XML.Statistic.Queue")==='undefined') {
    statistik.meanQueueLength=0;
	statistik.meanQueueLengthProIntervall=this.loadDistribution(this.zeroDistribution());
	statistik.maxQueueLength=0;
  } else {
    var dataQueue=this.conditionalLangLoad(data,"XML.Statistic.Queue");
    statistik.meanQueueLength=this.conditionalLangLoadNonNegativeFloat(dataQueue,"XML.Statistic.Queue.Average");
	if (statistik.meanQueueLength===null) return this.language.tr("XML.Statistic.Queue.Average.Error").format(this.conditionalLangLoad(dataQueue,"XML.Statistic.Queue.Average"));
	statistik.meanQueueLengthProIntervall=this.conditionalLangLoadDistribution(dataQueue,"XML.Statistic.Queue.AveragePerInterval");
	if (statistik.meanQueueLengthProIntervall===null) return this.language.tr("XML.Statistic.Queue.AveragePerInterval.Error").format(this.conditionalLangLoad(dataQueue,"XML.Statistic.Queue.AveragePerInterval"));
	statistik.maxQueueLength=this.conditionalLangLoadNonNegativeInt(dataQueue,"XML.Statistic.Queue.Maximum");
	if (statistik.maxQueueLength===null) return this.language.tr("XML.Statistic.Queue.Maximum.Error").format(this.conditionalLangLoad(dataQueue,"XML.Statistic.Queue.Maximum"));
  }
  
  /* Agenten gem Modell */
  if (typeof this.conditionalLangLoad(data,"XML.Statistic.ModelAgents")==='undefined') {
    statistik.agentenModellGlobal={};
	statistik.agentenModellGlobal.name="";
	statistik.agentenModellGlobal.type="";
	statistik.agentenModellGlobal.simAgents=this.loadDistribution(this.zeroDistribution());
	statistik.agentenModellGlobal.modelAgents=this.loadDistribution(this.zeroDistribution());
	statistik.agentenModellGlobal.fullAgents=this.loadDistribution(this.zeroDistribution());
	statistik.agentenModellProGruppe=[];
	statistik.agentenModellProGruppe.push(statistik.agentenModellGlobal);	
  } else {
    statistik.agentenModellProGruppe=[];
	var d=this.asArray(this.conditionalLangLoad(data,"XML.Statistic.ModelAgents"));
    for (var i=0;i<d.length;i++) {
	  var a=this.loadStatistikModelAgentenFromRawJSON(d[i]);
	  if (typeof a==='string') return a;
	  if (a.name=='') statistik.agentenModellGlobal=a; else statistik.agentenModellProGruppe.push(a);
	}
  }
  
  /* Erlang-C Daten */
  var erlangData;  
  statistik.erlangC1={};
  erlangData=this.conditionalLangLoad(data,"XML.Statistic.ErlangC.ModeSimple");
  if (typeof erlangData==='undefined') {
    statistik.erlangC1.agenten=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.freshCalls=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.Success=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.WaitingTime=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.ServiceLevel=this.loadDistribution(this.zeroDistribution());
  } else {
    statistik.erlangC1.agenten=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.Agents"); if (statistik.erlangC1.agenten==null) statistik.erlangC1.agenten=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.freshCalls=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.FreshCalls"); if (statistik.erlangC1.freshCalls==null) statistik.erlangC1.freshCalls=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.Success=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.Success"); if (statistik.erlangC1.Success==null) statistik.erlangC1.Success=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.WaitingTime=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.WaitingTime"); if (statistik.erlangC1.WaitingTime==null) statistik.erlangC1.WaitingTime=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC1.ServiceLevel=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.ServiceLevel"); if (statistik.erlangC1.ServiceLevel==null) statistik.erlangC1.ServiceLevel=this.loadDistribution(this.zeroDistribution());
  }  
  statistik.erlangC2={};
  erlangData=this.conditionalLangLoad(data,"XML.Statistic.ErlangC.ModeComplex");
  if (typeof erlangData==='undefined') {
    statistik.erlangC2.agenten=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.freshCalls=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.retryCalls=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.Success=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.WaitingTime=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.ServiceLevel=this.loadDistribution(this.zeroDistribution());
  } else {
    statistik.erlangC2.agenten=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.Agents"); if (statistik.erlangC2.agenten==null) statistik.erlangC2.agenten=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.freshCalls=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.FreshCalls"); if (statistik.erlangC2.freshCalls==null) statistik.erlangC2.freshCalls=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.retryCalls=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.RetryCalls"); if (statistik.erlangC2.retryCalls==null) statistik.erlangC2.retryCalls=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.Success=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.Success"); if (statistik.erlangC2.Success==null) statistik.erlangC2.Success=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.WaitingTime=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.WaitingTime"); if (statistik.erlangC2.WaitingTime==null) statistik.erlangC2.WaitingTime=this.loadDistribution(this.zeroDistribution());
	statistik.erlangC2.ServiceLevel=this.conditionalLangLoadDistribution(erlangData,"XML.Statistic.ErlangC.ServiceLevel"); if (statistik.erlangC2.ServiceLevel==null) statistik.erlangC2.ServiceLevel=this.loadDistribution(this.zeroDistribution());
  }
  
  /* Warnungen */
  statistik.warnings=[];
  if (typeof this.conditionalLangLoad(data,"XML.Statistic.Warnings")!=='undefined') {
    var sub=this.conditionalLangLoad(data,"XML.Statistic.Warnings");
    if (typeof this.conditionalLangLoad(sub,"XML.Model.Warnings.Record")!=='undefined') {      
      var d=this.asArray(this.conditionalLangLoad(sub,"XML.Model.Warnings.Record"));
      for (var i=0;i<d.length;i++)  {
        var obj=this.loadWarningFromRawJSON(d[i],true);
	    if (typeof obj==='string') return obj+' '+this.language.tr("XML.Model.Warnings.Error").format(statistik.warnings.length+1);
	    statistik.warnings.push(obj);
      }
    }
  }

  return statistik;
}

CallcenterSimulatorLoader.prototype.loadStatistikKundenFromRawJSON=function(data,simDays) {
  var kunden={};
  kunden.name=this.conditionalLangLoad(data,"XML.Statistic.GeneralAttributes.Name",'');
  
  kunden.DistMax=1800;
  kunden.DistMaxLong=3240000;
  
  var dataSub,dataSub2;

  /* Daten pro Kunde */
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.Count");
  if (typeof dataSub==='undefined') return this.language.tr(HTMLViewer.Loader.Clients.NoCount).format(kunden.name);
  kunden.kunden=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Count"); if (kunden.kunden===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Count.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Count"));
  kunden.kundenErfolg=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Success"); if (kunden.kundenErfolg===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Success.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Success"));
  kunden.kundenBlocked=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Blocked"); if (kunden.kundenBlocked===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Blocked.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Blocked"));
  kunden.kundenAbbruch=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Canceled"); if (kunden.kundenAbbruch===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Canceled.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Canceled"));
  kunden.kundenUebertrag=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CarryOver",0); if (kunden.kundenUebertrag===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.CarryOver.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CarryOver"));

  kunden.kundenProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CountPerInterval"); if (kunden.kundenProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.CountPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CountPerInterval"));
  kunden.kundenErfolgProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.SuccessPerInterval"); if (kunden.kundenErfolgProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.SuccessPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.SuccessPerInterval"));
  kunden.kundenBlockedProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.BlockedPerInterval"); if (kunden.kundenBlockedProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.BlockedPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.BlockedPerInterval"));
  kunden.kundenAbbruchProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CanceledPerInterval"); if (kunden.kundenAbbruchProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.CanceledPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CanceledPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CarryOver");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoCarryOver").format(kunden.name);
  kunden.kundenAbbruchProSimDay=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.CarryOver.Canceled"); if (kunden.kundenAbbruchProSimDay===null) return this.language.tr("XML.Statistic.Clients.CarryOver.Canceled.Error");
  
  kunden.kundenNextDayRetryProSimDay=[];
  var list=this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.CarryOver.RetryTimes",'').split('|');
  for (var i=0;i<list.length;i++) {
    var d=this.loadDistribution(list[i]); if (d!==null) kunden.kundenNextDayRetryProSimDay.push(d);
  }
  while (kunden.kundenNextDayRetryProSimDay.length<simDays) kunden.kundenNextDayRetryProSimDay.push([]);
    
  kunden.kundenNextDayUebertragWaitingTimeProSimDay=[];  
  kunden.kundenNextDayUebertragRestWaitingToleranceProSimDay=[];
  list=this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.CarryOver.WaitingTimeTolerances",'').split('|');
  for (var i=0;i<list.length;i++) {
    var temp1=[], temp2=[]; 
    var list2=list[i].split(';');
	for (var j=0;j<list2.length;j++) {
	  var list3=list2[j];
	  if (list3=='') continue;
	  var list4=list3.split('/');
	  temp1.push(list4[0]);
	  temp2.push(list4[1]);
	}
	kunden.kundenNextDayUebertragWaitingTimeProSimDay.push(temp1);
	kunden.kundenNextDayUebertragRestWaitingToleranceProSimDay.push(temp2);
  }
  while (kunden.kundenNextDayUebertragWaitingTimeProSimDay.length<simDays) kunden.kundenNextDayUebertragWaitingTimeProSimDay.push([]);
  while (kunden.kundenNextDayUebertragRestWaitingToleranceProSimDay.length<simDays) kunden.kundenNextDayUebertragRestWaitingToleranceProSimDay.push([]);
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.WaitingTime.Clients");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoWaitingTime").format(kunden.name);
  kunden.kundenWartezeitSum=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.kundenWartezeitSum===null) return this.language.tr("XML.Statistic.Clients.WaitingTime.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Sum"));
  kunden.kundenWartezeitSum2=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.kundenWartezeitSum2===null) return this.language.tr("XML.Statistic.Clients.WaitingTime.Clients.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"));
  kunden.kundenWartezeitSumProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"); if (kunden.kundenWartezeitSumProIntervall===null) return this.language.tr("XML.Statistic.Clients.WaitingTime.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.HoldingTime.Clients");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoHoldingTime").format(kunden.name);
  kunden.kundenVerweilzeitSum=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.kundenVerweilzeitSum===null) return this.language.tr("XML.Statistic.Clients.HoldingTime.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Sum"));
  kunden.kundenVerweilzeitSum2=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.kundenVerweilzeitSum2===null) return this.language.tr("XML.Statistic.Clients.HoldingTime.Clients.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"));
  kunden.kundenVerweilzeitSumProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"); if (kunden.kundenVerweilzeitSumProIntervall===null) return this.language.tr("XML.Statistic.Clients.HoldingTime.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CancelTime.Clients");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoCancelTime").format(kunden.name);
  kunden.kundenAbbruchzeitSum=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.kundenAbbruchzeitSum===null) return this.language.tr("XML.Statistic.Clients.CancelTime.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Sum"));
  kunden.kundenAbbruchzeitSum2=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.kundenAbbruchzeitSum2===null) return this.language.tr("XML.Statistic.Clients.CancelTime.Clients.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"));
  kunden.kundenAbbruchzeitSumProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"); if (kunden.kundenAbbruchzeitSumProIntervall===null) return this.language.tr("XML.Statistic.Clients.CancelTime.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.ServiceLevel.Clients");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoServiceLevel").format(kunden.name);
  kunden.kundenServicelevel=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.kundenServicelevel===null) return this.language.tr("XML.Statistic.Clients.ServiceLevel.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
  kunden.kundenServicelevelProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.kundenServicelevelProIntervall===null) return this.language.tr("XML.Statistic.Clients.ServiceLevel.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.Forwarding.Clients");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoForwarding").format(kunden.name);
  kunden.kundenWeiterleitungen=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.kundenWeiterleitungen===null) return this.language.tr("XML.Statistic.Clients.Forwarding.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
  kunden.kundenWeiterleitungenProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.kundenWeiterleitungenProIntervall===null) return this.language.tr("XML.Statistic.Clients.Forwarding.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.Retry.Clients");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoRetry").format(kunden.name);
  kunden.kundenWiederholungen=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.kundenWiederholungen===null) return this.language.tr("XML.Statistic.Clients.Retry.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
  kunden.kundenWiederholungenProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.kundenWiederholungenProIntervall===null) return this.language.tr("XML.Statistic.Clients.Retry.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.Recall.Clients");
  if (typeof dataSub==='undefined') {
    kunden.kundenWiederanruf=0;
	kunden.kundenWiederanrufProIntervall=this.loadDistribution(this.zeroDistribution());
  } else {
    kunden.kundenWiederanruf=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.kundenWiederanruf===null) return this.language.tr("XML.Statistic.Clients.Recall.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
    kunden.kundenWiederanrufProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.kundenWiederanrufProIntervall===null) return this.language.tr("XML.Statistic.Clients.Recall.Clients.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));
  }
 
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.WaitingTimeDistribution.Clients"); kunden.kundenWartezeitVerteilung=null;
  if (typeof dataSub!='undefined') kunden.kundenWartezeitVerteilung=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.kundenWartezeitVerteilung==null) return this.language.tr("XML.Statistic.Clients.WaitingTimeDistribution.Clients.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.HoldingTimeDistribution.Clients"); kunden.kundenVerweilzeitVerteilung=null;
  if (typeof dataSub!='undefined') kunden.kundenVerweilzeitVerteilung=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.kundenVerweilzeitVerteilung==null) return this.language.tr("XML.Statistic.Clients.HoldingTimeDistribution.Clients.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CancelTimeDistribution.Clients"); kunden.kundenAbbruchzeitVerteilung=null;
  if (typeof dataSub!='undefined') kunden.kundenAbbruchzeitVerteilung=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.kundenAbbruchzeitVerteilung==null) return this.language.tr("XML.Statistic.Clients.CancelTimeDistribution.Clients.Error");

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.WaitingTimeDistributionLong.Clients"); kunden.kundenWartezeitVerteilungLang=null;
  if (typeof dataSub!='undefined') kunden.kundenWartezeitVerteilungLang=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.kundenWartezeitVerteilungLang==null) return this.language.tr("XML.Statistic.Clients.WaitingTimeDistributionLong.Clients.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.HoldingTimeDistributionLong.Clients"); kunden.kundenVerweilzeitVerteilungLang=null;
  if (typeof dataSub!='undefined') kunden.kundenVerweilzeitVerteilungLang=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.kundenVerweilzeitVerteilungLang==null) return this.language.tr("XML.Statistic.Clients.HoldingTimeDistributionLong.Clients.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CancelTimeDistributionLong.Clients"); kunden.kundenAbbruchzeitVerteilungLang=null;
  if (typeof dataSub!='undefined') kunden.kundenAbbruchzeitVerteilungLang=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.kundenAbbruchzeitVerteilungLang==null) return this.language.tr("XML.Statistic.Clients.CancelTimeDistributionLong.Clients.Error");

  /* Daten pro Anruf */
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Calls.Count");
  if (typeof dataSub==='undefined') return this.language.tr(HTMLViewer.Loader.Calls.NoCount).format(kunden.name);
  kunden.anrufe=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Count"); if (kunden.anrufe===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Count.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Count"));
  kunden.anrufeErfolg=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Success"); if (kunden.anrufeErfolg===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Success.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Success"));
  kunden.anrufeBlocked=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Blocked"); if (kunden.anrufeBlocked===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Blocked.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Blocked"));
  kunden.anrufeAbbruch=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Canceled"); if (kunden.anrufeAbbruch===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.Canceled.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.Canceled"));
  kunden.anrufeUebertrag=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CarryOver",0); if (kunden.anrufeUebertrag===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.CarryOver.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CarryOver"));

  kunden.anrufeProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CountPerInterval"); if (kunden.anrufeProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.CountPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CountPerInterval"));
  kunden.anrufeErfolgProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.SuccessPerInterval"); if (kunden.anrufeErfolgProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.SuccessPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.SuccessPerInterval"));
  kunden.anrufeBlockedProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.BlockedPerInterval"); if (kunden.anrufeBlockedProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.BlockedPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.BlockedPerInterval"));
  kunden.anrufeAbbruchProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CanceledPerInterval"); if (kunden.anrufeAbbruchProIntervall===null) return this.language.tr("XML.Statistic.Clients.ClientsCallsCount.CanceledPerInterval.ErrorClients").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Clients.ClientsCallsCount.CanceledPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.WaitingTime.Calls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoWaitingTime").format(kunden.name);
  kunden.anrufeWartezeitSum=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.anrufeWartezeitSum===null) return this.language.tr("XML.Statistic.Clients.WaitingTime.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Sum"));
  kunden.anrufeWartezeitSum2=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.anrufeWartezeitSum2===null) return this.language.tr("XML.Statistic.Clients.WaitingTime.Calls.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"));
  kunden.anrufeWartezeitSumProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"); if (kunden.anrufeWartezeitSumProIntervall===null) return this.language.tr("XML.Statistic.Clients.WaitingTime.Calls.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.HoldingTime.Calls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoHoldingTime").format(kunden.name);
  kunden.anrufeVerweilzeitSum=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.anrufeVerweilzeitSum===null) return this.language.tr("XML.Statistic.Clients.HoldingTime.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Sum"));
  kunden.anrufeVerweilzeitSum2=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.anrufeVerweilzeitSum2===null) return this.language.tr("XML.Statistic.Clients.HoldingTime.Calls.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"));
  kunden.anrufeVerweilzeitSumProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"); if (kunden.anrufeVerweilzeitSumProIntervall===null) return this.language.tr("XML.Statistic.Clients.HoldingTime.Calls.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CancelTime.Calls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoCancelTime").format(kunden.name);
  kunden.anrufeAbbruchzeitSum=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.anrufeAbbruchzeitSum===null) return this.language.tr("XML.Statistic.Clients.CancelTime.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Sum"));
  kunden.anrufeAbbruchzeitSum2=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.anrufeAbbruchzeitSum2===null) return this.language.tr("XML.Statistic.Clients.CancelTime.Calls.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SquaresSum"));
  kunden.anrufeAbbruchzeitSumProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"); if (kunden.anrufeAbbruchzeitSumProIntervall===null) return this.language.tr("XML.Statistic.Clients.CancelTime.Calls.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.SumPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.ServiceLevel.Calls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoServiceLevel").format(kunden.name);
  kunden.anrufeServicelevel=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.anrufeServicelevel===null) return this.language.tr("XML.Statistic.Clients.ServiceLevel.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
  kunden.anrufeServicelevelProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.anrufeServicelevelProIntervall===null) return this.language.tr("XML.Statistic.Clients.ServiceLevel.Calls.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.Forwarding.Calls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoForwarding").format(kunden.name);
  kunden.anrufeWeiterleitungen=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.anrufeWeiterleitungen===null) return this.language.tr("XML.Statistic.Clients.Forwarding.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
  kunden.anrufeWeiterleitungenProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.anrufeWeiterleitungenProIntervall===null) return this.language.tr("XML.Statistic.Clients.Forwarding.Calls.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.Retry.Calls");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Clients.NoRetry").format(kunden.name);
  kunden.anrufeWiederholungen=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.GeneralAttributes.Count"); if (kunden.anrufeWiederholungen===null) return this.language.tr("XML.Statistic.Clients.Retry.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.Count"));
  kunden.anrufeWiederholungenProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"); if (kunden.anrufeWiederholungenProIntervall===null) return this.language.tr("XML.Statistic.Clients.Retry.Calls.ErrorSumPerInterval").format(this.conditionalLangLoad(dataSub,"XML.Statistic.GeneralAttributes.CountPerInterval"));
  
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.WaitingTimeDistribution.Calls"); kunden.anrufeWartezeitVerteilung=null;
  if (typeof dataSub!='undefined') kunden.anrufeWartezeitVerteilung=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.anrufeWartezeitVerteilung==null) return this.language.tr("XML.Statistic.Clients.WaitingTimeDistribution.Calls.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.HoldingTimeDistribution.Calls"); kunden.anrufeVerweilzeitVerteilung=null;
  if (typeof dataSub!='undefined') kunden.anrufeVerweilzeitVerteilung=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.anrufeVerweilzeitVerteilung==null) return this.language.tr("XML.Statistic.Clients.HoldingTimeDistribution.Calls.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CancelTimeDistribution.Calls"); kunden.anrufeAbbruchzeitVerteilung=null;
  if (typeof dataSub!='undefined') kunden.anrufeAbbruchzeitVerteilung=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.anrufeAbbruchzeitVerteilung==null) return this.language.tr("XML.Statistic.Clients.CancelTimeDistribution.Calls.Error");

  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.WaitingTimeDistributionLong.Calls"); kunden.anrufeWartezeitVerteilungLang=null;
  if (typeof dataSub!='undefined') kunden.anrufeWartezeitVerteilungLang=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.anrufeWartezeitVerteilungLang==null) return this.language.tr("XML.Statistic.Clients.WaitingTimeDistributionLong.Calls.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.HoldingTimeDistributionLong.Calls"); kunden.anrufeVerweilzeitVerteilungLang=null;
  if (typeof dataSub!='undefined') kunden.anrufeVerweilzeitVerteilungLang=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.anrufeVerweilzeitVerteilungLang==null) return this.language.tr("XML.Statistic.Clients.HoldingTimeDistributionLong.Calls.Error");
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Clients.CancelTimeDistributionLong.Calls"); kunden.anrufeAbbruchzeitVerteilungLang=null;
  if (typeof dataSub!='undefined') kunden.anrufeAbbruchzeitVerteilungLang=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.GeneralAttributes.Distribution",kunden.DistMax); if (kunden.anrufeAbbruchzeitVerteilungLang==null) return this.language.tr("XML.Statistic.Clients.CancelTimeDistributionLong.Calls.Error");

  /* Konfidenzintervalle */
  kunden.interDaySuccessCallsSum=0;
  kunden.interDaySuccessCallsSum2=0;
  kunden.interDaySuccessClientsSum=0;
  kunden.interDaySuccessClientsSum2=0;
  kunden.interDayWartezeitSum=0;
  kunden.interDayWartezeitSum2=0;
  kunden.interDayServiceLevelSum=0;
  kunden.interDayServiceLevelSum2=0;
  kunden.interDaySuccessCalls90Min=0;
  kunden.interDaySuccessCalls90Max=0;
  kunden.interDaySuccessCalls95Min=0;
  kunden.interDaySuccessCalls95Max=0;  
  kunden.interDaySuccessClients90Min=0;
  kunden.interDaySuccessClients90Max=0;
  kunden.interDaySuccessClients95Min=0;
  kunden.interDaySuccessClients95Max=0;  
  kunden.interDayWartezeit90Min=0;
  kunden.interDayWartezeit90Max=0;
  kunden.interDayWartezeit95Min=0;
  kunden.interDayWartezeit95Max=0;
  kunden.interDayServiceLevel90Min=0;
  kunden.interDayServiceLevel90Max=0;
  kunden.interDayServiceLevel95Min=0;
  kunden.interDayServiceLevel95Max=0; 
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Confidence");
  if (typeof dataSub!=='undefined') {
    dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.Accessibility.Calls");
    if (typeof dataSub2!=='undefined') {
      kunden.interDaySuccessCallsSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDaySuccessCallsSum===null) return this.language.tr("XML.Statistic.Confidence.Accessibility.Calls.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDaySuccessCallsSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDaySuccessCallsSum2===null) return this.language.tr("XML.Statistic.Confidence.Accessibility.Calls.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
	  kunden.interDaySuccessCalls90Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
	  kunden.interDaySuccessCalls90Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
	  kunden.interDaySuccessCalls95Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
	  kunden.interDaySuccessCalls95Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}
    dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.Accessibility.Clients");
    if (typeof dataSub2!=='undefined') {
      kunden.interDaySuccessClientsSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDaySuccessClientsSum===null) return this.language.tr("XML.Statistic.Confidence.Accessibility.Clients.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDaySuccessClientsSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDaySuccessClientsSum2===null) return this.language.tr("XML.Statistic.Confidence.Accessibility.Clients.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
	  kunden.interDaySuccessClients90Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
	  kunden.interDaySuccessClients90Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
	  kunden.interDaySuccessClients95Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
	  kunden.interDaySuccessClients95Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}
	dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.WaitingTime");
    if (typeof dataSub2!=='undefined') {
      kunden.interDayWartezeitSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDayWartezeitSum===null) return this.language.tr("XML.Statistic.Confidence.WaitingTime.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDayWartezeitSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDayWartezeitSum2===null) return this.language.tr("XML.Statistic.Confidence.WaitingTime.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
      kunden.interDayWartezeit90Min=this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
      kunden.interDayWartezeit90Max=this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
      kunden.interDayWartezeit95Min=this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
      kunden.interDayWartezeit95Max=this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}
	dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.ServiceLevel.CallsSuccess");
    if (typeof dataSub2!=='undefined') {
      kunden.interDayServiceLevelCallsSuccessSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDayServiceLevelCallsSuccessSum===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.CallsSuccess.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDayServiceLevelCallsSuccessSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDayServiceLevelCallsSuccessSum2===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.CallsSuccess.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
	  kunden.interDayServiceLevelCallsSuccess90Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
      kunden.interDayServiceLevelCallsSuccess90Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
      kunden.interDayServiceLevelCallsSuccess95Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
      kunden.interDayServiceLevelCallsSuccess95Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}
    dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.ServiceLevel.CallsAll");
    if (typeof dataSub2!=='undefined') {
      kunden.interDayServiceLevelCallsAllSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDayServiceLevelCallsAllSum===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.CallsAll.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDayServiceLevelCallsAllSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDayServiceLevelCallsAllSum2===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.CallsAll.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
	  kunden.interDayServiceLevelCallsAll90Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
      kunden.interDayServiceLevelCallsAll90Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
      kunden.interDayServiceLevelCallsAll95Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
      kunden.interDayServiceLevelCallsAll95Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}	
    dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.ServiceLevel.ClientsSuccess");
    if (typeof dataSub2!=='undefined') {
      kunden.interDayServiceLevelClientsSuccessSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDayServiceLevelClientsSuccessSum===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.ClientsSuccess.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDayServiceLevelClientsSuccessSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDayServiceLevelClientsSuccessSum2===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.ClientsSuccess.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
	  kunden.interDayServiceLevelClientsSuccess90Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
      kunden.interDayServiceLevelClientsSuccess90Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
      kunden.interDayServiceLevelClientsSuccess95Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
      kunden.interDayServiceLevelClientsSuccess95Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}
    dataSub2=this.conditionalLangLoad(dataSub,"XML.Statistic.Confidence.ServiceLevel.ClientsAll");
    if (typeof dataSub2!=='undefined') {
      kunden.interDayServiceLevelClientsAllSum=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.Sum"); if (kunden.interDayServiceLevelClientsAllSum===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.ClientsAll.ErrorSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.Sum"));
      kunden.interDayServiceLevelClientsAllSum2=this.conditionalLangLoadNonNegativeFloat(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"); if (kunden.interDayServiceLevelClientsAllSum2===null) return this.language.tr("XML.Statistic.Confidence.ServiceLevel.ClientsAll.ErrorSquaresSum").format(this.conditionalLangLoad(dataSub2,"XML.Statistic.GeneralAttributes.SquaresSum"));
	  kunden.interDayServiceLevelClientsAll90Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Min");
      kunden.interDayServiceLevelClientsAll90Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence90Max");
      kunden.interDayServiceLevelClientsAll95Min=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Min");
      kunden.interDayServiceLevelClientsAll95Max=this.conditionalLangLoadFloat(dataSub2,"XML.Statistic.GeneralAttributes.Confidence95Max");
	}
  }
  
  /* Kosten */
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Costs");
  if (typeof dataSub==='undefined') {
    kunden.revenue=0;
    kunden.costWaiting=0;
    kunden.costCancel=0;
  } else {
    kunden.revenue=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Costs.Yield"); if (kunden.revenue===null) return this.language.tr("XML.Statistic.Costs.Yield.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Costs.Yield"));
    kunden.costWaiting=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Costs.WaitingTimes"); if (kunden.costWaiting===null) return this.language.tr("XML.Statistic.Costs.WaitingTimes.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Costs.WaitingTimes"));
    kunden.costCancel=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Costs.Cancelations"); if (kunden.costCancel===null) return this.language.tr("XML.Statistic.Costs.Cancelations.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Costs.Cancelations"));
  }
  
  return kunden;
}

CallcenterSimulatorLoader.prototype.loadStatistikAgentenFromRawJSON=function(data) {
  var dataSub;
  var agenten={};
  agenten.name=this.conditionalLangLoad(data,"XML.Model.GeneralAttributes.Name",'');
  agenten.type=this.conditionalLangLoad(data,"XML.Statistic.GeneralAttributes.Type",'');

  agenten.anzahlAgenten=this.conditionalLangLoadNonNegativeInt(data,"XML.Statistic.GeneralAttributes.Count"); if (agenten.anzahlAgenten===null) return this.language.tr("XML.Statistic.Agents.ErrorCount").format(this.conditionalLangLoad(data,"XML.Statistic.GeneralAttributes.Count"));
  
  /* Gesamtdaten fr die Agentengruppe */
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Agents.Summary");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Agents.Incomplete");
  
  agenten.leerlaufGesamt=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Agents.Summary.FreeTime"); if (agenten.leerlaufGesamt===null) return this.language.tr("XML.Statistic.Agents.Summary.FreeTime.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.FreeTime"));
  agenten.technischerLeerlaufGesamt=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Agents.Summary.TechnicalFreeTime"); if (agenten.technischerLeerlaufGesamt===null) return this.language.tr("XML.Statistic.Agents.Summary.TechnicalFreeTime.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.TechnicalFreeTime"));
  agenten.arbeitGesamt=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Agents.Summary.HoldingTime"); if (agenten.arbeitGesamt===null) return this.language.tr("XML.Statistic.Agents.Summary.HoldingTime.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.HoldingTime"));
  agenten.postProcessingGesamt=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Agents.Summary.PostProcessingTime"); if (agenten.postProcessingGesamt===null) return this.language.tr("XML.Statistic.Agents.Summary.PostProcessingTime.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.PostProcessingTime"));
  
  agenten.leerlaufProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Agents.Summary.FreeTimePerInterval"); if (agenten.leerlaufProIntervall===null) return this.language.tr("XML.Statistic.Agents.Summary.FreeTimePerInterval.Error");
  agenten.technischerLeerlaufProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Agents.Summary.TechnicalFreeTimePerInterval"); if (agenten.technischerLeerlaufProIntervall===null) return this.language.tr("XML.Statistic.Agents.Summary.TechnicalFreeTimePerInterval.Error");
  agenten.arbeitProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Agents.Summary.HoldingTimePerInterval"); if (agenten.arbeitProIntervall===null) return this.language.tr("XML.Statistic.Agents.Summary.HoldingTimePerInterval.Error");
  agenten.postProcessingProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Agents.Summary.PostProcessingTimePerInterval"); if (agenten.postProcessingProIntervall===null) return this.language.tr("XML.Statistic.Agents.Summary.PostProcessingTimePerInterval.Error");
  
  agenten.brutto=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Statistic.Agents.Summary.GrossTime"); if (agenten.brutto==null) return this.language.tr("HTMLViewer.Loader.Agents.InvalidGrossTime").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.GrossTime"));
  agenten.netto=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Statistic.Agents.Summary.NetTime"); if (agenten.netto==null) return this.language.tr("HTMLViewer.Loader.Agents.InvalidNetTime").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.NetTime"));
  
  agenten.anrufe=this.conditionalLangLoadNonNegativeInt(dataSub,"XML.Statistic.Agents.Summary.Calls"); if (agenten.anrufe===null) return this.language.tr("XML.Statistic.Agents.Summary.Calls.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Summary.Calls"));
  agenten.anrufeProIntervall=this.conditionalLangLoadDistribution(dataSub,"XML.Statistic.Agents.Summary.CallsPerInterval"); if (agenten.anrufeProIntervall===null) return this.language.tr("XML.Statistic.Agents.Summary.CallsPerInterval.Error");

  /* Kundentyp-abhngige Daten fr die Agentengruppe */
  agenten.dataByCaller=[];
  agenten.dataByCallerTechnial=[];
  agenten.dataByCallerTechnialProIntervall=[];
  agenten.dataByCallerService=[];
  agenten.dataByCallerServiceProIntervall=[];
  agenten.dataByCallerPostProcessing=[];
  agenten.dataByCallerPostProcessingProIntervall=[];
  agenten.dataByCallerAnrufe=[];
  agenten.dataByCallerAnrufeProIntervall=[];
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Agents.ClientType");
  if (typeof dataSub==='undefined') return this.language.tr("HTMLViewer.Loader.Agents.Incomplete");
  var e=this.asArray(dataSub);
  for (var i=0;i<e.length;i++) {
    var d=e[i];
	var s=this.conditionalLangLoad(d,"XML.Statistic.GeneralAttributes.Name",''); if (s=='') continue;
	agenten.dataByCaller.push(s);
	var num;
	agenten.dataByCallerTechnial.push(num=this.conditionalLangLoadNonNegativeInt(d,"XML.Statistic.Agents.Summary.TechnicalFreeTime")); if (num===null) return this.language.tr("XML.Statistic.Agents.Summary.TechnicalFreeTime.ErrorPerClientType").format(this.conditionalLangLoad(d,"XML.Statistic.Agents.Summary.TechnicalFreeTime"));
	agenten.dataByCallerService.push(num=this.conditionalLangLoadNonNegativeInt(d,"XML.Statistic.Agents.Summary.HoldingTime")); if (num===null) return this.language.tr("XML.Statistic.Agents.Summary.HoldingTime.ErrorPerClientType").format(this.conditionalLangLoad(d,"XML.Statistic.Agents.Summary.HoldingTime"));
	agenten.dataByCallerPostProcessing.push(num=this.conditionalLangLoadNonNegativeInt(d,"XML.Statistic.Agents.Summary.PostProcessingTime")); if (num===null) return this.language.tr("XML.Statistic.Agents.Summary.PostProcessingTime.ErrorPerClientType").format(this.conditionalLangLoad(d,"XML.Statistic.Agents.Summary.PostProcessingTime"));
	var dist;
	agenten.dataByCallerTechnialProIntervall.push(dist=this.conditionalLangLoadDistribution(d,"XML.Statistic.Agents.Summary.TechnicalFreeTimePerInterval")); if (dist===null) return this.language.tr("XML.Statistic.Agents.Summary.TechnicalFreeTimePerInterval.ErrorPerClientType");
	agenten.dataByCallerServiceProIntervall.push(dist=this.conditionalLangLoadDistribution(d,"XML.Statistic.Agents.Summary.HoldingTimePerInterval")); if (dist===null) return this.language.tr("XML.Statistic.Agents.Summary.HoldingTimePerInterval.ErrorPerClientType");
	agenten.dataByCallerPostProcessingProIntervall.push(dist=this.conditionalLangLoadDistribution(d,"XML.Statistic.Agents.Summary.PostProcessingTimePerInterval")); if (dist===null) return this.language.tr("XML.Statistic.Agents.Summary.PostProcessingTimePerInterval.ErrorPerClientType");
	
    agenten.dataByCallerAnrufe.push(num=this.conditionalLangLoadNonNegativeInt(d,"XML.Statistic.Agents.Summary.Calls")); if (num===null) return this.language.tr("XML.Statistic.Agents.Summary.Calls.ErrorPerClientType").format(this.conditionalLangLoad(d,"XML.Statistic.Agents.Summary.Calls"));
    agenten.dataByCallerAnrufeProIntervall.push(dist=this.conditionalLangLoadDistribution(d,"XML.Statistic.Agents.Summary.CallsPerInterval")); if (num===null) return this.language.tr("XML.Statistic.Agents.Summary.CallsPerInterval.ErrorPerClientType");
  }

  /* Kosten */
  dataSub=this.conditionalLangLoad(data,"XML.Statistic.Agents.Costs");
  if (typeof dataSub==='undefined') {
    agenten.costOfficeTime=0;
    agenten.costCalls=0;
    agenten.costProcessTime=0;
  } else {
    agenten.costOfficeTime=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Statistic.Agents.Costs.Wages"); if (agenten.costOfficeTime===null) return this.language.tr("XML.Statistic.Agents.Costs.Wages.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Costs.Wages"));
    agenten.costCalls=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Statistic.Agents.Costs.Calls"); if (agenten.costCalls===null) return this.language.tr("XML.Statistic.Agents.Costs.Calls.Error").format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Costs.Calls"));
    agenten.costProcessTime=this.conditionalLangLoadNonNegativeFloat(dataSub,"XML.Statistic.Agents.Costs.CallTimes"); if (agenten.costProcessTime===null) return this.language.tr().format(this.conditionalLangLoad(dataSub,"XML.Statistic.Agents.Costs.CallTimes.Error"));
  }
  
  return agenten;
}

CallcenterSimulatorLoader.prototype.loadStatistikModelAgentenFromRawJSON=function(data) {
  var agenten={};  
  agenten.name=this.conditionalLangLoad(data,"XML.Model.GeneralAttributes.Name",'');
  agenten.type=this.conditionalLangLoad(data,"XML.Statistic.GeneralAttributes.Type",'');
  agenten.simAgents=this.conditionalLangLoadDistribution(data,"XML.Statistic.Agents.Model.Simulation");
  if (agenten.simAgents===null) return this.language.tr("XML.Statistic.Agents.Model.Simulation.Error");
  agenten.modelAgents=this.conditionalLangLoadDistribution(data,"XML.Statistic.Agents.Model.Model");
  if (agenten.modelAgents===null) return this.language.tr("XML.Statistic.Agents.Model.Model.Error");
  agenten.fullAgents=this.conditionalLangLoadDistribution(data,"XML.Statistic.Agents.Model.WithSurcharge");
  if (agenten.fullAgents===null) return this.language.tr("XML.Statistic.Agents.Model.WithSurcharge");
  return agenten;
}
/*
Klasse CallcenterSimulatorViewerText
(c) Alexander Herzog
*/

'use strict';

function CallcenterSimulatorFormatTools(language) {
  this.decimalSeparator=".";
  this.groupSeparator=",";
  if (typeof language!='undefined') this.setLanguage(language);
}

CallcenterSimulatorFormatTools.prototype.setLanguage=function(language) {
  this.language=language;
  this.decimalSeparator=language.decimalSeparator;
  this.groupSeparator=language.groupSeparator;
}

CallcenterSimulatorFormatTools.prototype.formatLong=function(text) {
  var num=parseFloat(text);
  if (isNaN(num)) return num;
  num=""+Math.round(num);
  var result="";
  var count=0;
  while (num!="") {
    if (count==3) {result=this.groupSeparator+result; count=0;}
	count++;
    result=num.substr(-1,1)+result;
	num=num.substr(0,num.length-1);
  }
  return result;
}

CallcenterSimulatorFormatTools.prototype.formatNumber=function(text,digits) {
  if (typeof digits==='undefined') digits=1;
  var num=parseFloat(text);
  if (isNaN(num)) return num;
  
  num*=Math.pow(10,digits);
  num=Math.round(num);
  num/=Math.pow(10,digits);
  
  num=""+num;
  num=num.replace(".",this.decimalSeparator);
  
  var frac=(num.indexOf(this.decimalSeparator)>=0);
  
  var result="";
  var count=0;
  while (num!="") {
    if (!frac) {
      if (count==3) {result=this.groupSeparator+result; count=0;}
	  count++;
	}
	var s=num.substr(-1,1);
    result=s+result;
	num=num.substr(0,num.length-1);
	if (s==this.decimalSeparator) frac=false;
  }
  return result;
}

CallcenterSimulatorFormatTools.prototype.formatTime=function(text,digits) {
  if (typeof digits==='undefined') digits=1;
  var time=parseFloat(text);
  if (isNaN(time)) return time;
  var minus=false;
  if (time<0) {minus=true; time=-time;}
  
  var frac=time%1;
  time=Math.round(time-frac);  
  var h=Math.floor(time/3600), m=Math.floor(time/60)%60, s=time%60;
  
  h=""+h; if (h.length<2) h="0"+h;
  m=""+m; if (m.length<2) m="0"+m;
  s=""+s; if (s.length<2) s="0"+s;
 
  text=h+":"+m+":"+s;
  if (frac!=0 && digits!=0) {
    var s=this.formatNumber(frac,digits);
	text+=this.decimalSeparator+s.substr(2);
  }
  if (minus) text="-"+text;
  return text;
}

CallcenterSimulatorFormatTools.prototype.formatShortTime=function(text) {
  var time=parseFloat(text);
  if (isNaN(time)) return time;
  
  var frac=time%1;
  time=Math.round(time-frac);  
  var h=Math.floor(time/3600), m=Math.floor(time/60)%60;
  
  h=""+h; if (h.length<2) h="0"+h;
  m=""+m; if (m.length<2) m="0"+m;
 
  return h+":"+m;
}

CallcenterSimulatorFormatTools.prototype.calcStd=function(x2,x,n) {
  if (n>0) return Math.sqrt(x2/n-x*x/n/n); else return 0;
}

CallcenterSimulatorFormatTools.prototype.div=function(data,number) {
  var newData=[];
  if (number.length>1) {
    for (var i=0;i<data.length;i++) newData.push((number[i]>0)?(data[i]/number[i]):0);
  } else {
    for (var i=0;i<data.length;i++) newData.push(data[i]/number);
  }
  return newData;
}

CallcenterSimulatorFormatTools.prototype.add=function(data,number) {
  var newData=[];
  if (number.length>1) {
    for (var i=0;i<data.length;i++) newData.push(data[i]+number[i]);
  } else {
    for (var i=0;i<data.length;i++) newData.push(data[i]+number);
  }
  return newData;
}

CallcenterSimulatorFormatTools.prototype.mul=function(data,number) {
  var newData=[];
  if (number.length>1) {
    for (var i=0;i<data.length;i++) newData.push(data[i]*number[i]);
  } else {
    for (var i=0;i<data.length;i++) newData.push(data[i]*number);
  }
  return newData;
}

CallcenterSimulatorFormatTools.prototype.sum=function(data) {
  var count=0;
  for (var i=0;i<data.length;i++) count+=data[i];
  return count;
}

CallcenterSimulatorFormatTools.prototype.round=function(data) {
  var newData=[];
  for (var i=0;i<data.length;i++) newData.push(Math.round(data[i]));
  return newData;
}

CallcenterSimulatorFormatTools.prototype.max=function(data1,data2) {
  var newData=[];
  for (var i=0;i<data1.length;i++) newData.push(Math.max(data1[i],data2[i]));
  return newData;
}

CallcenterSimulatorFormatTools.prototype.decode=function(text) {
  if (typeof text==='undefined' || text===null) text="";
  text=text.replace("&auml;","");
  text=text.replace("&ouml;","");
  text=text.replace("&uuml;","");
  text=text.replace("&Auml;","");
  text=text.replace("&Ouml;","");
  text=text.replace("&Uuml;","");
  text=text.replace("&szlig;","");
  return text;
}

CallcenterSimulatorFormatTools.prototype.tr=function(ID) {
  return this.language.tr(ID);
}
/*
Klasse CallcenterSimulatorViewer
(c) Alexander Herzog

Diese Klasse dient zur Darstellung der Statistikdaten eines Callcenter
Simulationslaufes.

Methoden:
CallcenterSimulatorViewer(language,xmlData,statistik,containerTitle,containerContent,globalViewerVarName)
CallcenterSimulatorTools.init();

Eigenschaften:
CallcenterSimulatorTools.tree

Nach dem Aufruf des Konstruktors kann das Array tree mit
Objekten der Form {label: 'Text', viewer: function(language,statistik,container){}, sub: []}
befllt werden.

Notwendige Bibliotheken:
jQuery, jquery.aciPlugin, jquery.aciTree.min.js
*/

'use strict';

function CallcenterSimulatorViewer(language,xmlData,statistik,containerTitle,containerContent,globalViewerVarName,printCSS,printJS,imagePath) {
  this.language=language;
  this.printCSS=printCSS;
  this.printJS=printJS;  
  this.imagePath=imagePath;
  this.xmlString="";
  this.treeVisible=true;
  if (xmlData!=null) {
    if (typeof xmlData==='string') this.xmlString=xmlData; else {
      if (window.ActiveXObject) this.xmlString=xmlData.xml; else this.xmlString=(new XMLSerializer()).serializeToString(xmlData);
    }
  }
  this.statistik=statistik;
  
  var download="";
  if (this.xmlString!="") {
    download=
    '  <div class="toolbaricon toolbaricon-withmenu" id="downloadDIV" style="float: right; font-size: smaller;" title="'+language.tr("HTMLViewer.Save.Tooltip")+'"><div class="toolbaricon-any toolbaricon-save">&nbsp;</div>'+
    '    <div class="toolbarMenu">'+
	'      <table><tr><td>'+
    '      <a id="downloadA"><span style="display: block; float: left;"><div class="toolbaricon-any toolbaricon-package" style="margin: 0px; margin-right: 8px;" id="downloadAimage">&nbsp;</div>&nbsp;</span> <span id="downloadAtext">'+language.tr("HTMLViewer.Save.Data")+'</span></a>'+
	'      </td></tr><tr><td>'+
    '      <a id="downloadA2"><span style="display: block; float: left;"><div class="toolbaricon-any toolbaricon-package" style="margin: 0px; margin-right: 8px;">&nbsp;</div>&nbsp;</span> '+language.tr("HTMLViewer.Save.XML")+'</a>'+
	'      </td></tr></table>'+
    '    </div>'+
    '  </div>';
  } else {
    download=
    '  <a style="float: right;" class="toolbaricon" id="downloadA"><div id="downloadAimage" class="toolbaricon-any toolbaricon-print">&nbsp;</div></a>';
  }
  
  containerTitle.html(    
    '  <a style="float: right;" class="toolbaricon" href="javascript:'+globalViewerVarName+'.showInfo()");" title="'+language.tr("HTMLViewer.ProgramInfo")+'"><div class="toolbaricon-any toolbaricon-info">&nbsp;</div></a>'+
    '  <a style="float: right;" class="toolbaricon" id="print" href="javascript:'+globalViewerVarName+'.printCurrent()" title="'+language.tr("HTMLViewer.Print")+'"><div class="toolbaricon-any toolbaricon-print">&nbsp;</div></a>'+
    download+
    '  <a style="float: right;" class="toolbaricon" href="javascript:'+globalViewerVarName+'.showTree()" title="'+language.tr("HTMLViewer.ShowHideTree")+'"><div id="showTree" class="toolbaricon-any toolbaricon-left">&nbsp;</div></a>'+
    '  Callcenter Simulator Viewer'
  );
    
  containerContent.html(    
    '<table style="width: 100%" style="margin: 0px;" id="completeTable">'+
    '<tr>'+
    '  <td style="width: 20%;" class="noprint" valign="top" id="treeData"><div id="statistik_tree" class="aciTree" style="overflow: scroll; height: '+(window.innerHeight-56)+'px;"></div></td>'+
    '  <td id="statistik_right" valign="top"></td>'+
    '</tr>'+
    '</table>'
  );
  
  this.treeElement=$('#statistik_tree');
  this.contentElement=$('#statistik_right');
  
  this.treeElement.css('border','1px solid lightgray');
  this.treeElement.css('margin-right','2px');
  
  this.contentElement.css('border','1px solid lightgray');
  this.contentElement.css('padding','0px');
  
  this.tree=[];
  this.idCounter=0;
  this.idTranslate={};
  this.idTranslateInfo={};
  this.idTranslateNr={};
  this.idTranslateType={};
  this.idTranslateType2={};

  var that=this;
  $(window).resize(function(){that.resizeViewer();});
}

CallcenterSimulatorViewer.prototype.resizeViewer=function() {
  $('#statistik_tree').css('height',(window.innerHeight-56)+"px");
  if (typeof this.currentViewer!='undefined') this.currentViewer.updateSize();
}

CallcenterSimulatorViewer.prototype.buildTreeData=function(data) {
  var nodes=[];
  
  for (var i=0;i<data.length;i++) {
    var node={};
    var id="statistikNode"+this.idCounter;
    node.id=id; this.idCounter++;
    if (typeof data[i].viewer==='undefined') {
      this.idTranslate[id]=null;
      this.idTranslateInfo[id]=null;
      this.idTranslateNr[id]=null;
      this.idTranslateType[id]=null;
      this.idTranslateType2[id]=null;
    } else {
      this.idTranslate[id]=data[i].viewer;
      this.idTranslateInfo[id]=data[i].select;
      this.idTranslateNr[id]=data[i].nr;
      this.idTranslateType[id]=data[i].type;
      this.idTranslateType2[id]=data[i].type2;
    }
    var s="";
    if (typeof data[i].type!=='undefined') s=" ("+data[i].type+")";
    node.label=data[i].label+s;
    if (typeof data[i].sub==='undefined') {
      node.inode=false;
      node.icon='file';
      var custom="";
      if (data[i].type==this.language.tr("Statistic.Type.Text")) custom="treeicon-text";
      if (data[i].type==this.language.tr("Statistic.Type.Table")) custom="treeicon-table";
      if (data[i].type==this.language.tr("Statistic.Type.Graphics") && typeof data[i].type2!=='undefined') {
        if (data[i].type2=='Bar') custom="treeicon-bar";
        if (data[i].type2=='Pie') custom="treeicon-pie";
        if (data[i].type2=='Line') custom="treeicon-line";
      }
      if (custom!="") node.icon=custom;
    } else {
      node.inode=true;
      node.icon='folder';
      if (typeof data[i].closed==='undefined' || !data[i].closed) node.open=true;
      node.branch=this.buildTreeData(data[i].sub);
    }
    nodes.push(node);
  }
  return nodes;
}

CallcenterSimulatorViewer.prototype.init=function() {
  var treeData=this.buildTreeData(this.tree);
  
  var that=this;
  
  this.treeElement.aciTree({rootData: treeData, loaderDelay: 0, animateRoot: false});
  this.treeElement.on('acitree',function(event,api,item,eventName,options) {
     if (eventName=='focus') {
       that.contentElement.html('');
       var index=api.getId(item);
       var viewer=that.idTranslate[index];
       if (typeof viewer==='undefined' || viewer===null) viewer=createCallcenterSimulatorViewerEmpty;
       var viewerObj=viewer(that.language,that.statistik,that.contentElement,that.idTranslateInfo[index],that.idTranslateNr[index],that.imagePath);
       if (typeof viewerObj.save==='undefined') {
         $('#downloadA').css('display','none');
         $('#print').css('display','none');
       } else {
         var saveData=viewerObj.save();
         $('#downloadA').css('display','block');
         $('#downloadA').attr('href',saveData[0]);
         $('#downloadA').attr('download',saveData[1]);
         var icon="";
         if (that.idTranslateType[index]==that.language.tr("Statistic.Type.Text")) icon="toolbaricon-text";
         if (that.idTranslateType[index]==that.language.tr("Statistic.Type.Table")) icon="toolbaricon-table";
         if (that.idTranslateType[index]==that.language.tr("Statistic.Type.Graphics") && typeof that.idTranslateType2[index]!=='undefined') {
           if (that.idTranslateType2[index]=='Bar') icon="toolbaricon-bar";
           if (that.idTranslateType2[index]=='Pie') icon="toolbaricon-pie";
           if (that.idTranslateType2[index]=='Line') icon="toolbaricon-line";
         }         
		 $('#downloadAimage').attr('class','toolbaricon-any '+icon);
		 if (that.xmlString=="") {
		   $('#downloadA').attr('title',that.language.tr("HTMLViewer.Save").format(that.idTranslateType[index]));
		 } else {
		   $('#downloadAtext').html(that.language.tr("HTMLViewer.Save").format(that.idTranslateType[index]));
		 }
		 
         if (that.xmlString!="") {
           $('#downloadA2').attr('href',"data:application/octet-stream;charset=utf-8,"+encodeURIComponent(that.xmlString));
           $('#downloadA2').attr('download','statistik.xml');
         }
         $('#print').css('display','block');
       }
       that.currentViewer=viewerObj;
	   viewerObj.updateSize();
     }
   });
   
   this.contentElement.html('');
   this.currentViewer=CallcenterSimulatorViewerEmpty(this.language,this.statistik,this.contentElement);
}

CallcenterSimulatorViewer.prototype.showTree=function() {
  if (this.treeVisible) {
    $('#showTree').attr('class','toolbaricon-any toolbaricon-right');
    $('#treeTitle').hide();
    $('#treeData').hide();
  } else {
    $('#showTree').attr('class','toolbaricon-any toolbaricon-left');
    $('#treeTitle').show();
    $('#treeData').show();
  }
  this.treeVisible=!this.treeVisible;
  this.resizeViewer();
}

CallcenterSimulatorViewer.prototype.printCurrent=function() {
  var printWindow=window.open("","","width=500,height=400");
  var a=this.currentViewer.getPrintData();
  
  printWindow.document.write(
    "<!DOCTYPE html>\n"+
    "<html>\n"+
    "<head>\n"+
    "  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n"+
    "  <meta charset=\"utf-8\">\n"+
    "  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n"+
    "  <title>Callcenter Simulator Statistik-Anzeige</title>\n"+
    "  <link href=\""+this.printCSS+"\" rel=\"stylesheet\" type=\"text/css\">\n"+
    "  <script src=\""+this.printJS+"\" type=\"application/javascript\" charset=\"UTF-8\"></script>\n"+
    "</head>\n"+
    "<body>\n"+
    a[0]+"\n"+
    "<script type=\"text/javascript\">$(document).ready(function() {"+a[1]+" window.print(); window.close();});</script>\n"+
    "</body>\n"+
    "</html>\n"
  );
  printWindow.document.close();
}

CallcenterSimulatorViewer.prototype.showInfo=function() {
  alert("Callcenter Simulator Viewer\n(c) Alexander Herzog");
}

CallcenterSimulatorViewerEmpty.prototype=new CallcenterSimulatorFormatTools();

function CallcenterSimulatorViewerEmpty(language,statistik,content,typeInfo,typeNr,imagePath) {
  var src="";
  if (!(typeof imagePath=='undefined')) src=imagePath+"CS.gif";
  var s="";
  s+="<div id=\"emptyViewerDiv\">\n";
  s+="<img id=\"emptyViewerLogo\" style='margin: 15px; border: 1px solid gray;' src='"+src+"'>\n";
  s+="<p style='padding: 15px;'>"+language.tr("HTMLViewer.EmptyViewer")+"</p>\n";
  s+="</div>\n";
  content.html(s);
}

CallcenterSimulatorViewerEmpty.prototype.updateSize=function() {
  var w=Math.min(450,window.innerWidth-$('#emptyViewerDiv').position().left-42);
  $('#emptyViewerLogo').css("width",w+"px");
}

function createCallcenterSimulatorViewerEmpty(language,statistik,content,typeInfo,typeNr,imagePath) {
  return new CallcenterSimulatorViewerEmpty(language,statistik,content,typeInfo,typeNr,imagePath);
}
/*
Klasse CallcenterSimulatorViewerText
(c) Alexander Herzog
*/

'use strict';

CallcenterSimulatorViewerText.prototype=new CallcenterSimulatorFormatTools();

function CallcenterSimulatorViewerText(language,container) {
  this.setLanguage(language);
  this.container=container;
  this.inParagraph=false;
  this.firstLine=true;
  this.text="";
}

CallcenterSimulatorViewerText.prototype.done=function() {
  this.divID="TextViewer"+Math.round(Math.random()*1000000);
  this.container.html('<div id="'+this.divID+'" style="padding: 0px 15px; overflow: scroll; height: '+(window.innerHeight-56)+'px;">'+this.text+'</div>');
}

CallcenterSimulatorViewerText.prototype.updateSize=function() {
  $('#'+this.divID).css("height",(window.innerHeight-56)+'px');
}

CallcenterSimulatorViewerText.prototype.getPrintData=function() {
  return ['<div >'+this.text+'</div>',''];
}

CallcenterSimulatorViewerText.prototype.append=function(text) {
  if (this.text!="") this.text+="\n";
  this.text+=text;
}

CallcenterSimulatorViewerText.prototype.addHeading=function(level,text) {
  this.endParagraph();
  this.append("<h"+level+">"+text+"</h"+level+">");  
}

CallcenterSimulatorViewerText.prototype.beginParagraph=function() {
  this.endParagraph();
  this.append("<p style='margin-bottom: 8px;'>");
  this.inParagraph=true;
  this.firstLine=true;
}

CallcenterSimulatorViewerText.prototype.endParagraph=function() {
  if (this.inParagraph) this.append("</p>");
  this.inParagraph=false;
}

CallcenterSimulatorViewerText.prototype.addLine=function(indentLevel,text,value,days,gesamt) {
  if (typeof days!=='undefined') value=value/days;
  if (typeof text==='undefined') {text=indentLevel; indentLevel=0;}
  if (typeof value!=='undefined') {text=text+": "+this.formatNumber(value);}
  if (typeof gesamt!=='undefined') {
    var percent=100*days*value/gesamt;
	text=text+=" ("+this.formatNumber(percent)+"%)";
  }

  if (!this.inParagraph) this.beginParagraph();
  if (this.firstLine) this.firstLine=false; else this.append("<br>");
  for (var i=0;i<indentLevel;i++) this.append("&nbsp;");
  this.append(text);
}

CallcenterSimulatorViewerText.prototype.addLineDigits=function(indentLevel,text,value,digits) {
  if (typeof text==='undefined') {text=indentLevel; indentLevel=0;}
  if (typeof value!=='undefined') {text=text+": "+this.formatNumber(value,digits);}

  if (!this.inParagraph) this.beginParagraph();
  if (this.firstLine) this.firstLine=false; else this.append("<br>");
  for (var i=0;i<indentLevel;i++) this.append("&nbsp;");
  this.append(text);
}

CallcenterSimulatorViewerText.prototype.addLines=function(text) {
  var list=text.split("\n");
  for (var i=0;i<list.length;i++) this.addLine(0,list[i]);
}

CallcenterSimulatorViewerText.prototype.formatExactTime=function(text) {
  return this.formatTime(text,3);
}

CallcenterSimulatorViewerText.prototype.addLineDiv=function(indentLevel,label,data,div) {
  this.addLine(indentLevel,label+": "+this.formatNumber(data/div,3));
}

CallcenterSimulatorViewerText.prototype.addPercentLine=function(indentLevel,label,value,digits) {
  if (typeof digits==='undefined') digits=3;
  this.addLine(indentLevel,label+": "+this.formatNumber(100*value,digits)+"%");
}

CallcenterSimulatorViewerText.prototype.addLineDiv2=function(indentLevel,label,data,div) {
  this.addLine(indentLevel,label+": "+this.formatNumber(data/div,3));
}

CallcenterSimulatorViewerText.prototype.addPercentLineParts=function(indentLevel,label,zaehler,nenner,digits) {
  if (typeof digits==='undefined') digits=3;
  if (nenner==0) return;
  this.addPercentLine(indentLevel,label,zaehler/nenner,digits);
}

CallcenterSimulatorViewerText.prototype.addShortTime=function(indentLevel,label,time) {
  this.addLine(indentLevel,label+": "+this.formatNumber(time,1)+" "+this.tr("Statistic.Seconds")+" (="+this.formatTime(Math.round(time))+")");
}

CallcenterSimulatorViewerText.prototype.addShortTimeParts=function(indentLevel,label,zaehler,nenner) {
  if (nenner==0) {
    if (zaehler==0) this.addShortTime(indentLevel,label,0);
    return;
  }
  this.addShortTime(indentLevel,label,zaehler/nenner);
}

CallcenterSimulatorViewerText.prototype.addPercentTime=function(indentLevel,label,time,div,sum) {
  var s=label+": ";
  s+=this.formatTime(time/div);
  if (sum>0) s+=" = "+this.formatNumber(100*time/sum)+"%";
  this.addLine(indentLevel,s);
}

CallcenterSimulatorViewerText.prototype.save=function() {
  var data=[];
  data.push("data:application/octet-stream;charset=utf-8,"+encodeURIComponent("<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>"+this.tr("XML.Statistic.BaseElement")+"</title>\n</head>\n<body>\n\n"+this.text+"\n\n</body>\n</html>\n"));
  data.push(this.tr("XML.Statistic.BaseElement")+'.html');
  return data;
}
/*
Klasse CallcenterSimulatorViewerTable
(c) Alexander Herzog
*/

'use strict';

CallcenterSimulatorViewerTable.prototype=new CallcenterSimulatorFormatTools();

function CallcenterSimulatorViewerTable(language,container) {
  this.setLanguage(language);
  this.container=container;
  this.data=[];  
  this.table=[];
}

CallcenterSimulatorViewerTable.prototype.done=function() {
  var dataCols=[];
  for (var i=1;i<this.data[0].length;i++) dataCols.push(this.data[0][i]);
  var dataContent=[];
  var dataRows=[];
  for (var i=1;i<this.data.length;i++) {
    var dataContentRow=[];
	dataRows.push(this.data[i][0]);
	for (var j=1;j<this.data[i].length;j++) dataContentRow.push(this.data[i][j]);
	dataContent.push(dataContentRow);
  }
  
  this.doneDirect(dataCols,dataRows,dataContent);
}

CallcenterSimulatorViewerTable.prototype.updateSize=function() {
  $('#statisticdatatable').css("width",(window.innerWidth-$('#statisticdatatable').position().left-5)+"px");
  $('#statisticdatatable').css("height",(window.innerHeight-56)+"px");
  $('#statisticdatatable').handsontable();
}

CallcenterSimulatorViewerTable.prototype.getPrintData=function() {
  var s="";
  s+="<table style=\"border-collapse: collapse;\">\n";
  s+="  <tr>\n";
  s+="    <th style=\"border: 1px solid black;\">&nbsp;</th>\n"
  for (var i=0;i<this.dataCols.length;i++) s+="    <th style=\"border: 1px solid black;\">"+this.dataCols[i]+"</th>\n";
  s+="  </tr>\n";
  for (var i=0;i<this.dataContent.length;i++) {
    s+="  <tr>\n";
    s+="    <th style=\"border: 1px solid black; text-align: left;\">"+this.dataRows[i]+"</th>\n"
    for (var j=0;j<this.dataContent[i].length;j++) s+="    <td style=\"border: 1px solid black;\">"+this.dataContent[i][j]+"</td>\n";
    s+="  </tr>\n";
  }  
  s+="</table>\n";  
  
  return [s,''];
}
  
CallcenterSimulatorViewerTable.prototype.doneDirect=function(dataCols,dataRows,dataContent) {
  this.container.html("<div id='statisticdatatable' style='overflow: scroll; width: "+($('#statistik_right_heading').width())+"px; height: "+(window.innerHeight-56)+"px'></div>");
  
  this.dataContent=dataContent;
  this.dataCols=dataCols;
  this.dataRows=dataRows;
  
  $('#statisticdatatable').handsontable({
    data: dataContent,
    colHeaders: dataCols,
    readOnly: true,
    rowHeaders: dataRows,
    contextMenu: false,
	fillHandle: false
  });
  
  var row=[""];
  for (var i=0;i<dataCols.length;i++) row.push(dataCols[i]);
  this.table.push(row);
  for (var i=0;i<dataContent.length;i++) {
    row=[dataRows[i]];
	for (var j=0;j<dataContent[i].length;j++) row.push(dataContent[i][j]);
	this.table.push(row);
  }
}

CallcenterSimulatorViewerTable.prototype.addCell=function(data,days) {
  return this.formatLong(Math.round(data/days));
}

CallcenterSimulatorViewerTable.prototype.addPercentCell=function(value,digits) {
  if (typeof digits=='undefined') digits=1;
  return this.formatNumber(100*value,digits)+"%";
}

CallcenterSimulatorViewerTable.prototype.addPercentCellParts=function(zaehler,nenner,digits) {
  if (typeof digits=='undefined') digits=1;
  if (nenner==0) return "-";
  return this.addPercentCell(zaehler/nenner,digits);
}

CallcenterSimulatorViewerTable.prototype.addTimeCell=function(data,days) {
  return this.formatTime(Math.round(data/days));
}

CallcenterSimulatorViewerTable.prototype.addTimeAndPercent=function(list,time,div,sum) {
  list.push(this.addTimeCell(time,div));
  list.push(this.addPercentCellParts(time,sum));
}

CallcenterSimulatorViewerTable.prototype.calcStd=function(x2,x,n) {
  if (n>0) return Math.round(Math.sqrt(x2/n-(x*x)/n/n)); else return 0;
}

CallcenterSimulatorViewerTable.prototype.transpose=function(data) {
  var newData=[];
  for (var i=0;i<data[0].length;i++) {
    var line=[];
	for (var j=0;j<data.length;j++) line.push(data[j][i]);
	newData.push(line);
  }
  return newData;
}

CallcenterSimulatorViewerTable.prototype.save=function() {
  var text="";
  for (var i=0;i<this.table.length;i++) {
    var line="\""+this.table[i][0]+"\"";
	for (var j=1;j<this.table[i].length;j++) line+=";\""+this.table[i][j]+"\"";
	text+=(line+"\n");
  }

  var data=[];
  data.push("data:application/octet-stream;charset=utf-8,"+encodeURIComponent(text));
  data.push(this.tr("XML.Statistic.BaseElement")+'.csv');
  return data;
}
/*
Klasse CallcenterSimulatorViewerDiagrams
(c) Alexander Herzog
*/

'use strict';

/* Pie */

CallcenterSimulatorViewerPieChart.prototype=new CallcenterSimulatorFormatTools();

function CallcenterSimulatorViewerPieChart(language,container) {
  this.setLanguage(language);
  this.container=container;
  this.title="";
  this.labels=[];
  this.values=[];
  this.colors=[];
  this.smartZoom=-1;
}

CallcenterSimulatorViewerPieChart.prototype.setTitle=function(s) {
  this.title=this.decode(s);
}

CallcenterSimulatorViewerPieChart.prototype.addSegment=function(label,value,color) {
  if (typeof color==='undefined') color=null;
  this.labels.push(this.decode(label));
  this.values.push(value);
  this.colors.push(color);
}

CallcenterSimulatorViewerPieChart.prototype.getPlotData=function() {
  var data=[];
  for (var i=0;i<this.values.length;i++) {
    var segment={label: this.labels[i], data: this.values[i]};
	if (this.colors[i]!==null) segment.color=this.colors[i];
    data.push(segment);
  }
  return data;
}

CallcenterSimulatorViewerPieChart.prototype.getPlotOptions=function() {
  return {
    series: {
      pie: {
        show: true,
        radius: 0.9,
        label: {
          show: true,
          radius: 5/8,
          formatter: function (label,series) {return "<div style='font-size:8pt; text-align:center; padding:2px; color:white;'>"+label.replace(/\n/g,"<br>")+"</div>";},
          background: {opacity: 0.7, color: '#000'}
        }
	  }
	},
	legend: {show: true, position: "sw"},
	canvas: true
  };
}

CallcenterSimulatorViewerPieChart.prototype.done=function() {
  var s="";
  if (this.title!="") s+='<div style="text-align: center; font-weight: bold; margin-top: 10px;">'+this.title+'</div>';
  s+='<div id="statisticPlot" style="margin: 15px; width: '+($('#statistik_right_heading').width()-30)+'px; height: '+(window.innerHeight-106)+'px;"></div>';
  this.container.html(s);

  this.plot=$.plot('#statisticPlot',this.getPlotData(),this.getPlotOptions());
}

CallcenterSimulatorViewerPieChart.prototype.updateSize=function() {
  $('#statisticPlot').css("width",(window.innerWidth-$('#statisticPlot').position().left-5-30)+"px");
  $('#statisticPlot').css('height',(window.innerHeight-106)+'px');
}

CallcenterSimulatorViewerPieChart.prototype.getPrintData=function() {
  var result="";
  
  if (this.title!="") result+='<div style="text-align: center; font-weight: bold;">'+this.title+'</div>';
  result+='<div id="statisticPlot" style="width: 1000px; height: 1000px;"></div>';

  result+=
    "<script type=\"text/javascript\">\n"+
    "$.plot('#statisticPlot',"+JSON.stringify(this.getPlotData())+","+JSON.stringify(this.getPlotOptions())+");\n"+    
    "</script>\n";
  
  return [result,''];
}

CallcenterSimulatorViewerPieChart.prototype.save=function() {
  var canvas=this.plot.getCanvas();
  var image=canvas.toDataURL("image/png");
  image = image.replace("image/png","image/octet-stream");
  var data=[];
  data.push(image);
  data.push(this.tr("XML.Statistic.BaseElement")+'.png');
  return data;
}

/* Line */

CallcenterSimulatorViewerLineChart.prototype=new CallcenterSimulatorFormatTools();

function CallcenterSimulatorViewerLineChart(language,container) {
  this.setLanguage(language);
  this.container=container;
  this.title="";
  this.mode=0;
  this.xLabel="";
  this.yLabel="";
  this.series=[];
}

CallcenterSimulatorViewerLineChart.prototype.setupDay=function(title,yLabel,yLabel2) {
  this.title=this.decode(title);
  this.mode=0;
  this.yLabel=this.decode(yLabel);
  this.yLabel2=this.decode(yLabel2);
}

CallcenterSimulatorViewerLineChart.prototype.setupDayPercent=function(title,yLabel,yLabel2) {
  this.title=this.decode(title);
  this.mode=1;
  this.yLabel=this.decode(yLabel);
  this.yLabel2=this.decode(yLabel2);
}

CallcenterSimulatorViewerLineChart.prototype.setupTime=function(title,xLabel,yLabel,yLabel2) {
  this.title=this.decode(title);
  this.mode=2;
  this.xLabel=this.decode(xLabel);
  this.yLabel=this.decode(yLabel);
  this.yLabel2=this.decode(yLabel2);
}

CallcenterSimulatorViewerLineChart.prototype.setupLongTime=function(title,xLabel,yLabel,yLabel2) {
  this.title=this.decode(title);
  this.mode=3;
  this.xLabel=this.decode(xLabel);
  this.yLabel=this.decode(yLabel);
  this.yLabel2=this.decode(yLabel2);
}

CallcenterSimulatorViewerLineChart.prototype.addSeries=function(title,color,dist) {
  var d=[];
  for (var i=0;i<dist.length;i++) d.push([i,dist[i]]);
  this.series.push({label: this.decode(title), color: color, data: d, yaxis: 1});
}

CallcenterSimulatorViewerLineChart.prototype.addSeriesPart=function(title,color,dist,count,smoothing) {
  var d=[];
  for (var i=0;i<Math.min(dist.length,count);i++) {
    var sum=0,c=0;
	for (var j=i;j>=Math.max(0,i-smoothing);j--) {sum+=dist[j]; c++;}
    d.push([i,sum/c]);
  }
  this.series.push({label: this.decode(title), color: color, data: d, yaxis: 1});
}

CallcenterSimulatorViewerLineChart.prototype.addLongSeriesPart=function(title,color,dist,count,smoothing) {
  var d=[];
  for (var i=0;i<Math.min(dist.length,count);i++) {
    var sum=0,c=0;
	for (var j=i;j>=Math.max(0,i-smoothing);j--) {sum+=dist[j]; c++;}
    d.push([i,sum/c]);
  }
  this.series.push({label: this.decode(title), color: color, data: d, yaxis: 1});
}

CallcenterSimulatorViewerLineChart.prototype.addSeriesToSecondSet=function(title,color,dist) {
  var d=[];
  for (var i=0;i<dist.length;i++) d.push([i,dist[i]]);
  this.series.push({label: this.decode(title), color: color, data: d, yaxis: 2});
}

CallcenterSimulatorViewerLineChart.prototype.addFillColor=function(seriesNumber) {
  var row=this.series[seriesNumber];
  row.lines={show: true, fill: true, fillColor: {colors:[{opacity:0.4},{opacity:0.1}]}};
}

CallcenterSimulatorViewerLineChart.prototype.getPlotData=function() {
  return this.series;
}

CallcenterSimulatorViewerLineChart.prototype.getPlotOptions=function() {
  var maxY;
  if (this.smartZoom>0) {
    maxY=0; for (var i=0;i<this.series.length;i++) for (var j=this.smartZoom;j<this.series[i].data.length;j++) maxY=Math.max(maxY,this.series[i].data[j][1]);
  }
  
  var options={};
  var that=this;
  switch (this.mode) {
    case 0:
	  var yAchse={axisLabel: this.yLabel, max: maxY, axisLabelUseCanvas: true, position: "left"};
	  if (typeof this.yLabel2!=='undefined') yAchse=[yAchse,{axisLabel: this.yLabel2, axisLabelUseCanvas: true, position: "right"}];
	  options={
	    canvas: true,
	    axisLabels: {show: true},
        xaxis: {
	      min: 0,
	      max: 47,
	      tickFormatter: function (val,axis) {var f=new CallcenterSimulatorFormatTools(that.language); return f.formatShortTime(val*1800);},
		  axisLabel: that.tr("Statistic.Time"),
		  axisLabelUseCanvas: true
		}
	  };
	  if (typeof this.yLabel2==='undefined') options.yaxis=yAchse; else options.yaxes=yAchse;
	  break;
    case 1:
	  var yAchse={axisLabel: this.yLabel, max: maxY, axisLabelUseCanvas: true, position: "left", tickFormatter: function (val,axis) {var f=new CallcenterSimulatorFormatTools(that.language); return f.formatNumber(100*val)+"%";}};
	  if (typeof this.yLabel2!=='undefined') yAchse=[yAchse,{axisLabel: this.yLabel2, axisLabelUseCanvas: true, position: "right"}];
	  options={
	    canvas: true,
	    axisLabels: {show: true},
        xaxis: {
	      min: 0,
	      max: 47,
	      tickFormatter: function (val,axis) {var f=new CallcenterSimulatorFormatTools(that.language); return f.formatShortTime(val*1800);},
		  axisLabel: that.tr("Statistic.Time"),
		  axisLabelUseCanvas: true
		}
	  };
	  if (typeof this.yLabel2==='undefined') options.yaxis=yAchse; else options.yaxes=yAchse;
      break;
	case 2:
	case 3:
	  var max=0; for (var i=0;i<this.series.length;i++) for (var j=0;j<this.series[i].data.length;j++) max=Math.max(max,this.series[i].data[j][0]);
	  var yAchse={axisLabel: this.yLabel, max: maxY, axisLabelUseCanvas: true, position: "left"};
	  if (typeof this.yLabel2!=='undefined') yAchse=[yAchse,{axisLabel: this.yLabel2, axisLabelUseCanvas: true, position: "right"}];
	  options={
	    axisLabels: {show: true},
        xaxis: {
	      min: 0,
	      max: max,
	      tickFormatter: function (val,axis) {var f=new CallcenterSimulatorFormatTools(that.language); return f.formatLong(val);},
		  axisLabel: this.xLabel,
		  axisLabelUseCanvas: true
		}
	  };
	  if (typeof this.yLabel2==='undefined') options.yaxis=yAchse; else options.yaxes=yAchse;
	  break;
  }
  
  options.canvas=true;
  
  return options;
}

CallcenterSimulatorViewerLineChart.prototype.done=function() {
  var s="";
  if (this.title!="") s+='<div style="text-align: center; font-weight: bold; margin-top: 10px;">'+this.title+'</div>';
  s+='<div id="statisticPlot" style="margin: 15px; width: '+($('#statistik_right_heading').width()-50)+'px; height: '+(window.innerHeight-126)+'px;"></div>';
  this.container.html(s);
  
  this.plot=$.plot('#statisticPlot',this.getPlotData(),this.getPlotOptions());
}

CallcenterSimulatorViewerLineChart.prototype.updateSize=function() {
  $('#statisticPlot').css("width",(window.innerWidth-$('#statisticPlot').position().left-5-30)+"px");
  $('#statisticPlot').css('height',(window.innerHeight-126)+'px');
}

CallcenterSimulatorViewerLineChart.prototype.getPrintData=function() {
  var result="";
  
  if (this.title!="") result+='<div style="text-align: center; font-weight: bold; margin-top: 10px;">'+this.title+'</div>';
  result+='<div id="statisticPlot" style="width: 1000px; height: 1000px;"></div>';

  result+=
    "<script type=\"text/javascript\">\n"+
    "$.plot('#statisticPlot',"+JSON.stringify(this.getPlotData())+","+JSON.stringify(this.getPlotOptions())+");\n"+    
    "</script>\n";  

  return [result,''];
}

CallcenterSimulatorViewerLineChart.prototype.smartZoom=function(removeFirst) {
  this.smartZoom=removeFirst;
}

CallcenterSimulatorViewerLineChart.prototype.save=function() {
  var canvas=this.plot.getCanvas();
  var image=canvas.toDataURL("image/png");
  image = image.replace("image/png","image/octet-stream");
  var data=[];
  data.push(image);
  data.push(this.tr("XML.Statistic.BaseElement")+'.png');
  return data;
}

/* Balken */

CallcenterSimulatorViewerBarChart.prototype=new CallcenterSimulatorFormatTools();

function CallcenterSimulatorViewerBarChart(language,container) {
  this.setLanguage(language);  
  this.container=container;
  this.title="";
  this.xLabel="";
  this.yLabel="";
  this.yPercent=false;
  this.series=[];
  this.parts=[];
  this.legend=true;
}

CallcenterSimulatorViewerBarChart.prototype.setupBarChart=function(title,xLabel,yLabel,yPercent) {
  this.title=this.decode(title);
  this.xLabel=this.decode(xLabel);
  this.yLabel=this.decode(yLabel);
  this.yPercent=yPercent;
  this.colors=[];
}

CallcenterSimulatorViewerBarChart.prototype.showLegend=function(show) {
  this.legend=show;
}

CallcenterSimulatorViewerBarChart.prototype.addValue=function(value,part,row) {
 var partIndex=-1;
 for (var i=0;i<this.parts.length;i++) if (row==this.parts[i]) {partIndex=i; break;}
 if (partIndex==-1) {this.parts.push(row); partIndex=this.parts.length-1;}
 
 var rowIndex=-1;
 for (var i=0;i<this.series.length;i++) 
   if (this.series[i].label==part) {rowIndex=i; break;}
 if (rowIndex==-1) {this.series.push({label: part, data: []}); rowIndex=this.series.length-1;}
 
 this.series[rowIndex].data.push([partIndex+1,value]);
}

CallcenterSimulatorViewerBarChart.prototype.setSeriesPaint=function(nr,color) {
  while (this.colors.length<nr+1) this.colors.push(null);
  this.colors[nr]=color;
}

CallcenterSimulatorViewerBarChart.prototype.getPlotData=function() {
  return this.series;
}

CallcenterSimulatorViewerBarChart.prototype.getPlotOptions=function() {
  var xTicks=[];
  for (var i=0;i<this.parts.length;i++) xTicks.push([i+1,this.parts[i]]);

  for (var i=0;i<Math.min(this.series.length,this.colors.length);i++) if (this.colors[i]!==null) this.series[i].color=this.colors[i];
  
  var options={
    series: {
	  stack: true,
      lines: {show: false, steps: false },
      bars: {show: true, barWidth: 0.9, align: 'center'},
	},
    xaxis: {
	  axisLabel: this.xLabel,
	  axisLabelUseCanvas: true,
	  ticks: xTicks
	},
	yaxis: {
	  axisLabel: this.yLabel,
	  axisLabelUseCanvas: true
	},
	legend: {show: this.legend},
	canvas: true
  };
  
  return options;
}

CallcenterSimulatorViewerBarChart.prototype.done=function() {
  var s="";
  if (this.title!="") s+='<div style="text-align: center; font-weight: bold; margin-top: 10px;">'+this.title+'</div>';
  s+='<div id="statisticPlot" style="margin: 15px; width: '+($('#statistik_right_heading').width()-50)+'px; height: '+(window.innerHeight-126)+'px;"></div>';
  this.container.html(s);

  this.plot=$.plot('#statisticPlot',this.getPlotData(),this.getPlotOptions());
}

CallcenterSimulatorViewerBarChart.prototype.updateSize=function() {
  $('#statisticPlot').css("width",(window.innerWidth-$('#statisticPlot').position().left-5-30)+"px");
  $('#statisticPlot').css('height',(window.innerHeight-126)+'px');
}

CallcenterSimulatorViewerBarChart.prototype.getPrintData=function() {
  var result="";
  
  if (this.title!="") result+='<div style="text-align: center; font-weight: bold; margin-top: 10px;">'+this.title+'</div>';
  result+='<div id="statisticPlot" style="width: 1000px; height: 1000px;"></div>';

  result+=
    "<script type=\"text/javascript\">\n"+
    "$.plot('#statisticPlot',"+JSON.stringify(this.getPlotData())+","+JSON.stringify(this.getPlotOptions())+");\n"+    
    "</script>\n";  
  
  return [result,''];
}

CallcenterSimulatorViewerBarChart.prototype.save=function() {
  var canvas=this.plot.getCanvas();
  var image=canvas.toDataURL("image/png");
  image = image.replace("image/png","image/octet-stream");
  var data=[];
  data.push(image);
  data.push(this.tr("XML.Statistic.BaseElement")+'.png');
  return data;
}
/*
(c) Alexander Herzog
*/

'use strict';

/* Schwellenwerte (Text) */

function viewerThresholds(language,statistic,content) {
  var viewer=new CallcenterSimulatorViewerText(language,content);

  viewer.addHeading(1,viewer.tr("SimStatistic.ThresholdsAndRecommendations"));
  
  viewerThresholdsIntern(viewer,statistic,true);
  viewerRecommendationsIntern(viewer,statistic,true);
  
  viewer.done();
  
  return viewer;
}

function viewerThresholdsIntern(viewer, statistic, fullInformation) {
  if (!fullInformation && statistic.warnings.length==0) return;
  
  var s;

  viewer.addHeading(2,viewer.tr("SimStatistic.Thresholds"));

  if (statistic.warnings.length==0) {
    viewer.beginParagraph();
    viewer.addLine(viewer.tr("SimStatistic.Thresholds.NoThresholds"));
    viewer.endParagraph();
    return;
  }

  if (!fullInformation) viewer.beginParagraph();
  var ok=0;
  
  for (var i=0;i<statistic.warnings.length;i++) {
    var record=statistic.warnings[i];

    if (record.warningStatus==record.WARNING_STATUS_OK) {
      ok++;
      if (!fullInformation) continue;
    }

    if (fullInformation) viewer.beginParagraph();

    var warning="";
    switch (record.warningStatus) {
      case record.WARNING_STATUS_OK: warning=viewer.tr("SimStatistic.Thresholds.Status.Ok"); break;
      case record.WARNING_STATUS_YELLOW: warning=viewer.tr("SimStatistic.Thresholds.Status.Yellow"); break;
      case record.WARNING_STATUS_RED: warning=viewer.tr("SimStatistic.Thresholds.Status.Red"); break;
    }
    var type="";
    switch (record.type) {
      case record.WARNING_TYPE_WAITINGTIME_CALL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.WaitingTimeCalls"); break;
      case record.WARNING_TYPE_WAITINGTIME_CLIENT: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.WaitingTimeClients"); break;
      case record.WARNING_TYPE_RESIDENCETIME_CALL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.ResidenceTimeCalls"); break;
      case record.WARNING_TYPE_RESIDENCETIME_CLIENT: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.ResidenceTimeClients"); break;
      case record.WARNING_TYPE_SUCCESSPART_CALL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.SuccessPartCalls"); break;
      case record.WARNING_TYPE_SUCCESSPART_CLIENT: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.SuccessPartClients"); break;
      case record.WARNING_TYPE_SERVICELEVEL_CALL_SUCCESSFUL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.ServiceLevelOnSuccessfulCalls"); break;
      case record.WARNING_TYPE_SERVICELEVEL_CLIENTS_SUCCESSFUL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.ServiceLevelOnSuccessfulClients"); break;
      case record.WARNING_TYPE_SERVICELEVEL_CALL_ALL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.ServiceLevelOnAllCalls"); break;
      case record.WARNING_TYPE_SERVICELEVEL_CLIENTS_ALL: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.ServiceLevelOnAllClients"); break;
      case record.WARNING_TYPE_WORKLOAD: type=viewer.tr("Editor.GeneralData.ThresholdValues.Type.Workload"); break;
    }
    viewer.addLine(warning+": "+type);

    if (fullInformation) {
      var currentValue, thresholdValue;
      if (record.type==record.WARNING_TYPE_WAITINGTIME_CALL || record.type==record.WARNING_TYPE_WAITINGTIME_CLIENT || record.type==record.WARNING_TYPE_RESIDENCETIME_CALL || record.type==record.WARNING_TYPE_RESIDENCETIME_CLIENT) {
        currentValue=viewer.formatTime(record.value);
        thresholdValue=viewer.formatTime(record.warningYellow);
      } else {
        currentValue=viewer.formatNumber(record.value*100)+"%";
        thresholdValue=viewer.formatNumber(record.warningYellow*100)+"%";
      }
      var compare;
      if (record.warningStatus==record.WARNING_STATUS_OK) {
        if (record.type==record.WARNING_TYPE_WAITINGTIME_CALL || record.type==record.WARNING_TYPE_WAITINGTIME_CLIENT || record.type==record.WARNING_TYPE_RESIDENCETIME_CALL || record.type==record.WARNING_TYPE_RESIDENCETIME_CLIENT) {
          compare="<=";
        } else {
          compare=">";
        }
      } else {
        if (record.type==record.WARNING_TYPE_WAITINGTIME_CALL || record.type==record.WARNING_TYPE_WAITINGTIME_CLIENT || record.type==record.WARNING_TYPE_RESIDENCETIME_CALL || record.type==record.WARNING_TYPE_RESIDENCETIME_CLIENT) {
          compare=">=";
        } else {
          compare="<";
        }
      }
      s=viewer.tr("SimStatistic.Thresholds.Compare");
      s=s.replace("%s",currentValue);
      s=s.replace("%s",compare);
      s=s.replace("%s",thresholdValue);
      viewer.addLine(1,s);

      var info1="";
      switch (record.modeTime) {
        case record.WARNING_MODE_AVERAGE:
          info1=viewer.tr("Editor.GeneralData.ThresholdValues.ModeTime.Average");
          break;
        case record.WARNING_MODE_EACH:
          info1=viewer.tr("Editor.GeneralData.ThresholdValues.ModeTime.Each");
          break;
        case record.WARNING_MODE_SELECTED:
          info1=viewer.tr("Editor.GeneralData.ThresholdValues.ModeTime.Intervals.Info");
          break;
      }
      var info2="";
      switch (record.modeGroup) {
        case record.WARNING_MODE_AVERAGE:
          info2=viewer.tr("Editor.GeneralData.ThresholdValues.ModeGroups.Average");
          break;
        case record.WARNING_MODE_EACH:
          info2=viewer.tr("Editor.GeneralData.ThresholdValues.ModeGroups.Each");
          break;
        case record.WARNING_MODE_SELECTED:
          info2=viewer.tr("Editor.GeneralData.ThresholdValues.ModeGroups.Group.Info")+": "+record.group;
          break;
      }
      viewer.addLine(1,"("+info1+", "+info2+")");
    }
    if (fullInformation) viewer.endParagraph();
  }

  if (!fullInformation && ok>0) {
    if (ok==statistic.warnings.length) {
        s=viewer.tr("SimStatistic.Thresholds.Count.AllOK");
        s=s.replace("%d",""+ok);
        viewer.addLine(s);
    } else {
      if (ok==1) {
        viewer.addLine(viewer.tr("SimStatistic.Thresholds.Count.OneOK"));
      } else {
        s=viewer.tr("SimStatistic.Thresholds.Count.Number");
        s=s.replace("%d",""+ok);
        viewer.addLine(s);
      }
    }
  }

  if (!fullInformation) viewer.endParagraph();
}

function viewerRecommendationsIntern(viewer, statistic, fullInformation) {
  var recommendations=[];
	
  var success=statistic.kundenGlobal.anrufeErfolg/Math.max(1,statistic.kundenGlobal.anrufe);
  if (success<0.6) recommendations.push(viewer.tr("SimStatistic.Recommendations.LowAccessibility").replace("%s",viewer.formatNumber(100*success)+"%"));

  var workload=(statistic.agentenGlobal.arbeitGesamt+statistic.agentenGlobal.postProcessingGesamt)/Math.max(1,statistic.agentenGlobal.leerlaufGesamt+statistic.agentenGlobal.technischerLeerlaufGesamt+statistic.agentenGlobal.arbeitGesamt+statistic.agentenGlobal.postProcessingGesamt);
  if (workload<0.5) recommendations.push(viewer.tr("SimStatistic.Recommendations.LowWorkload").replace("%s",viewer.formatNumber(100*workload)+"%"));

  var minWorkLoad=1;
  var maxWorkLoad=0;
  for (var i=0;i<48;i++) {
	if (statistic.kundenGlobal.anrufeProIntervall[i]<statistic.kundenGlobal.anrufe/24) continue;
	var w=(statistic.agentenGlobal.arbeitProIntervall[i]+statistic.agentenGlobal.postProcessingProIntervall[i])/Math.max(1,statistic.agentenGlobal.leerlaufProIntervall[i]+statistic.agentenGlobal.technischerLeerlaufProIntervall[i]+statistic.agentenGlobal.arbeitProIntervall[i]+statistic.agentenGlobal.postProcessingProIntervall[i]);
    if (w>maxWorkLoad) maxWorkLoad=w;
    if (w<minWorkLoad) minWorkLoad=w;
  }
  if (maxWorkLoad-minWorkLoad>0.2) recommendations.push(viewer.tr("SimStatistic.Recommendations.HighWorkloadVarinace"));
  
  for (var i=0;i<statistic.editModel.skills.length;i++) {
    var skill=statistic.editModel.skills[i];
	for (var j=0;j<skill.callerTypeWorkingTime;j++) {
	  var dist=skill.callerTypeWorkingTime[j];
      var valueVar=0; /* knnen wir per js leider nicht: dist.getNumericalVariance(); */
      var valueE=1; /* knnen wir per js leider nicht: dist.getNumericalMean(); */
      if (isNaN(valueVar) || !isFinite(valueVar)) continue;
      if (Math.abs(valueE)<0.0001) continue;
      var CV=Math.sqrt(valueVar)/valueE;
      if (CV>0.5) recommendations.push(viewer.tr("SimStatistic.Recommendations.HighWorkingTimeCV").replace("%s",skill.name));
    }
	for (var j=0;j<skill.callerTypePostProcessingTime;j++) {
	  var dist=skill.callerTypeWorkingTime[j];
	  var valueVar=0; /* knnen wir per js leider nicht: dist.getNumericalVariance(); */
      var valueE=1; /* knnen wir per js leider nicht: dist.getNumericalMean(); */
      if (isNaN(valueVar) || !isFinite(valueVar)) continue;
      if (Math.abs(valueE)<0.0001) continue;
      var CV=Math.sqrt(valueVar)/valueE;
      if (CV>0.5) recommendations.push(viewer.tr("SimStatistic.Recommendations.HighPostProcessingTimeCV").replace("%s",skill.name));
	}
  }

  if (recommendations.length==0) {
    if (fullInformation) {
	  viewer.addHeading(2,viewer.tr("SimStatistic.Recommendations"));
      viewer.beginParagraph();
      viewer.addLine(viewer.tr("SimStatistic.Recommendations.NoRecommendations"));
      viewer.endParagraph();
    }
  } else {
	viewer.addHeading(2,viewer.tr("SimStatistic.Recommendations"));
    viewer.beginParagraph();
	for (var i=0;i<recommendations.length;i++) viewer.addLine(recommendations[i]);
    viewer.endParagraph();
  }
}

/* Ergebnisbersicht (Text) */

function viewerBaseInformationClientData(viewer, kunden, simDays, ServiceLevel) {
  if (kunden.name=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllClients.Short")); else viewer.addHeading(2,kunden.name);
  
  var serviceLevelText="P(W<="+ServiceLevel+")";
  if (ServiceLevel<0) serviceLevelText="("+viewer.tr("SimStatistic.DifferentServiceLevelValuesPerClientType")+")";
  
  viewer.beginParagraph();
  viewer.addLineDiv(1,viewer.tr("SimStatistic.FreshCalls"),kunden.kunden,simDays);
  if (kunden.kundenWiederanruf>0) viewer.addLineDiv(1,viewer.tr("SimStatistic.RecallingClients.Info"),kunden.kundenWiederanruf,simDays);
  viewer.addLineDiv(1,viewer.tr("SimStatistic.Calls.Info"),kunden.anrufe-kunden.anrufeUebertrag,simDays);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",kunden.anrufeErfolg,kunden.anrufe-kunden.anrufeUebertrag);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",kunden.kundenErfolg,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag);
  viewer.addShortTimeParts(1,viewer.tr("SimStatistic.AverageWaitingTime"),kunden.anrufeWartezeitSum,kunden.anrufeErfolg);
  viewer.addShortTimeParts(1,viewer.tr("SimStatistic.AverageCancelTime"),kunden.anrufeAbbruchzeitSum,kunden.anrufeAbbruch);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ForwardedCallsPart"),kunden.anrufeWeiterleitungen,kunden.anrufeErfolg);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.BlockedCallsPart"),kunden.anrufeBlocked,kunden.anrufe-kunden.anrufeUebertrag);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnCallBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+") "+serviceLevelText,kunden.anrufeServicelevel,kunden.anrufeErfolg);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnClientBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.SuccessfulClients")+") "+serviceLevelText,kunden.kundenServicelevel,kunden.kundenErfolg);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnCallBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.AllCalls")+") "+serviceLevelText,kunden.anrufeServicelevel,kunden.anrufe);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnClientBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.AllClients")+") "+serviceLevelText,kunden.kundenServicelevel,kunden.kunden);
  viewer.endParagraph();
}


function viewerBaseInformationQueueLengthData(viewer, statistic) {
  viewer.addHeading(2,viewer.tr("SimStatistic.AverageQueueLength"));

  viewer.beginParagraph();
  viewer.addLine(1,viewer.tr("SimStatistic.AverageQueueLength.OverTheDay"),statistic.meanQueueLength);
  var maxNr=0;
  var maxValue=0;
  for (var i=0;i<statistic.meanQueueLengthProIntervall.length;i++) if (statistic.meanQueueLengthProIntervall[i]>maxValue) {
    maxValue=statistic.meanQueueLengthProIntervall[i];
    maxNr=i;
  }
  var t=viewer.formatTime(maxNr*1800)+"-"+viewer.formatTime((maxNr+1)*1800);
  viewer.addLine(2,viewer.tr("SimStatistic.AverageQueueLength.Maximum").format(t),statistic.meanQueueLengthProIntervall[maxNr]);
  viewer.endParagraph();
}

function viewerBaseInformationCallcenterData(viewer, agenten, simDays) {
  if (agenten.name=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllActiveAgents")); else viewer.addHeading(2,agenten.name);

  viewer.beginParagraph();
  viewer.addLine(1,viewer.tr("SimStatistic.Count"),agenten.anzahlAgenten);
  var sum=agenten.leerlaufGesamt+agenten.technischerLeerlaufGesamt+agenten.arbeitGesamt+agenten.postProcessingGesamt;
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.IdleTime"),agenten.leerlaufGesamt,sum);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.TechnicalFreeTime"),agenten.technischerLeerlaufGesamt,sum);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.HoldingTime"),agenten.arbeitGesamt,sum);
  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.PostProcessingTime"),agenten.postProcessingGesamt,sum);

  var brutto=agenten.brutto/simDays;
  var netto=agenten.netto/simDays;
  if (Math.abs(brutto-netto)<0.1) {
    viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.Scheduled")+": "+viewer.formatNumber(brutto/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
  } else {
    viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.ScheduledBrutto")+": "+viewer.formatNumber(brutto/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
    viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.ScheduledNetto")+": "+viewer.formatNumber(netto/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
  }
  viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.Worked")+": "+viewer.formatNumber(sum/simDays/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
  
  viewer.endParagraph();
}

function viewerBaseInformation(language,statistic,content) {
  var viewer=new CallcenterSimulatorViewerText(language,content);

  viewer.addHeading(1,language.tr("SimStatistic.ResultOverview"));
  
  var needDetailedData=(statistic.kundenProTyp.length>1);
  if (!needDetailedData && statistic.editModel.caller[0].serviceLevelSeconds>0) needDetailedData=true;

  var serviceLevel=statistic.editModel.serviceLevelSeconds;
  if (statistic.editModel.caller[0].serviceLevelSeconds>0) serviceLevel=statistic.editModel.caller[0].serviceLevelSeconds;
  for (var i=1;i<statistic.kundenProTyp.length;i++) {
    var sl=statistic.editModel.caller[i].serviceLevelSeconds;
    if (sl<=0) sl=statistic.editModel.serviceLevelSeconds;
    if (sl!=serviceLevel) {serviceLevel=-1; break;}
  }

  viewerBaseInformationClientData(viewer,statistic.kundenGlobal,statistic.simDays,serviceLevel);
  if (needDetailedData) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    var sl=statistic.editModel.caller[i].serviceLevelSeconds;
    if (sl<=0) sl=statistic.editModel.serviceLevelSeconds;
    viewerBaseInformationClientData(viewer,statistic.kundenProTyp[i],statistic.simDays,sl);
  }

  viewerBaseInformationQueueLengthData(viewer,statistic);

  viewerBaseInformationCallcenterData(viewer,statistic.agentenGlobal,statistic.simDays);
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++)
    viewerBaseInformationCallcenterData(viewer,statistic.agentenProCallcenter[i],statistic.simDays);
  
  viewerThresholdsIntern(viewer,statistic,false);
  viewerRecommendationsIntern(viewer,statistic,false);
  
  viewer.done();
  
  return viewer;
}

/* Konfidenzintervalle (Text) */

function viewerConfidenceClientData(viewer,kunden,simDays,ServiceLevel) {
  if (kunden.name=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllClients.Short")); else viewer.addHeading(2,kunden.name);

  viewer.addHeading(3,viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")");
  viewer.beginParagraph();
  viewer.addPercentLine(2,viewer.tr("Distribution.Mean"),kunden.interDaySuccessCallsSum/simDays,2);
  var d=viewer.calcStd(kunden.interDaySuccessCallsSum2,kunden.interDaySuccessCallsSum,simDays);
  viewer.addLineDigits(2,viewer.tr("Distribution.StdDev"),d,3);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDaySuccessCallsSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDaySuccessCalls90Min*100,2)+"%;"+viewer.formatNumber(kunden.interDaySuccessCalls90Max*100,2)+"%]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDaySuccessCalls95Min*100,2)+"%;"+viewer.formatNumber(kunden.interDaySuccessCalls95Max*100,2)+"%]");
  viewer.endParagraph();
  
  viewer.addHeading(3,viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")");
  viewer.beginParagraph();
  viewer.addPercentLine(2,viewer.tr("Distribution.Mean"),kunden.interDaySuccessClientsSum/simDays,2);
  var d=viewer.calcStd(kunden.interDaySuccessClientsSum2,kunden.interDaySuccessClientsSum,simDays);
  viewer.addLineDigits(2,viewer.tr("Distribution.StdDev"),d,3);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDaySuccessClientsSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDaySuccessClients90Min*100,2)+"%;"+viewer.formatNumber(kunden.interDaySuccessClients90Max*100,2)+"%]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDaySuccessClients95Min*100,2)+"%;"+viewer.formatNumber(kunden.interDaySuccessClients95Max*100,2)+"%]");
  viewer.endParagraph();

  viewer.addHeading(3,viewer.tr("SimStatistic.WaitingTime"));
  viewer.beginParagraph();
  viewer.addShortTime(2,viewer.tr("Distribution.Mean"),kunden.interDayWartezeitSum/simDays);
  d=viewer.calcStd(kunden.interDayWartezeitSum2,kunden.interDayWartezeitSum,simDays);
  viewer.addShortTime(2,viewer.tr("Distribution.StdDev"),d);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDayWartezeitSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+kunden.interDayWartezeit90Min+";"+kunden.interDayWartezeit90Max+"]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+kunden.interDayWartezeit95Min+";"+kunden.interDayWartezeit95Max+"]");
  viewer.endParagraph();

  viewer.addHeading(3,viewer.tr("SimStatistic.ServiceLevel")+" P(W<="+ServiceLevel+") ("+viewer.tr("SimStatistic.OnCallBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")");
  viewer.beginParagraph();
  viewer.addPercentLine(2,viewer.tr("Distribution.Mean"),kunden.interDayServiceLevelCallsSuccessSum/simDays,2);
  d=viewer.calcStd(kunden.interDayServiceLevelCallsSuccessSum2,kunden.interDayServiceLevelCallsSuccessSum,simDays);
  viewer.addLineDigits(2,viewer.tr("Distribution.StdDev"),d,3);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDayServiceLevelCallsSuccessSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelCallsSuccess90Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelCallsSuccess90Max*100,2)+"%]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelCallsSuccess95Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelCallsSuccess95Max*100,2)+"%]");
  viewer.endParagraph();
  
  viewer.addHeading(3,viewer.tr("SimStatistic.ServiceLevel")+" P(W<="+ServiceLevel+") ("+viewer.tr("SimStatistic.OnCallBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.AllCalls")+")");
  viewer.beginParagraph();
  viewer.addPercentLine(2,viewer.tr("Distribution.Mean"),kunden.interDayServiceLevelCallsAllSum/simDays,2);
  d=viewer.calcStd(kunden.interDayServiceLevelCallsAllSum2,kunden.interDayServiceLevelCallsAllSum,simDays);
  viewer.addLineDigits(2,viewer.tr("Distribution.StdDev"),d,3);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDayServiceLevelCallsAllSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelCallsAll90Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelCallsAll90Max*100,2)+"%]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelCallsAll95Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelCallsAll95Max*100,2)+"%]");
  viewer.endParagraph();
  
  viewer.addHeading(3,viewer.tr("SimStatistic.ServiceLevel")+" P(W<="+ServiceLevel+") ("+viewer.tr("SimStatistic.OnClientBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")");
  viewer.beginParagraph();
  viewer.addPercentLine(2,viewer.tr("Distribution.Mean"),kunden.interDayServiceLevelClientsSuccessSum/simDays,2);
  d=viewer.calcStd(kunden.interDayServiceLevelClientsSuccessSum2,kunden.interDayServiceLevelClientsSuccessSum,simDays);
  viewer.addLineDigits(2,viewer.tr("Distribution.StdDev"),d,3);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDayServiceLevelClientsSuccessSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelClientsSuccess90Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelClientsSuccess90Max*100,2)+"%]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelClientsSuccess95Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelClientsSuccess95Max*100,2)+"%]");
  viewer.endParagraph();

  viewer.addHeading(3,viewer.tr("SimStatistic.ServiceLevel")+" P(W<="+ServiceLevel+") ("+viewer.tr("SimStatistic.OnClientBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.AllClients")+")");
  viewer.beginParagraph();
  viewer.addPercentLine(2,viewer.tr("Distribution.Mean"),kunden.interDayServiceLevelClientsAllSum/simDays,2);
  d=viewer.calcStd(kunden.interDayServiceLevelClientsAllSum2,kunden.interDayServiceLevelClientsAllSum,simDays);
  viewer.addLineDigits(2,viewer.tr("Distribution.StdDev"),d,3);
  viewer.addLineDigits(2,viewer.tr("Distribution.CV"),d/(kunden.interDayServiceLevelClientsAllSum/simDays),3);
  viewer.addLine(2,"90%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelClientsAll90Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelClientsAll90Max*100,2)+"%]");
  viewer.addLine(2,"95%"+viewer.tr("SimStatistic.ConfidenceIntervals.ForMean")+": ["+viewer.formatNumber(kunden.interDayServiceLevelClientsAll95Min*100,2)+"%;"+viewer.formatNumber(kunden.interDayServiceLevelClientsAll95Max*100,2)+"%]");
  viewer.endParagraph();
}

function viewerConfidenceInformation(language,statistic,content) {
  var viewer=new CallcenterSimulatorViewerText(language,content);
  
  viewer.addHeading(1,language.tr("SimStatistic.ConfidenceIntervals"));

  viewer.addLines(language.tr("SimStatistic.ConfidenceIntervals.Info"));

  viewerConfidenceClientData(viewer,statistic.kundenGlobal,statistic.simDays,statistic.editModel.serviceLevelSeconds);
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    var sl=(statistic.editModel.caller[i].serviceLevelSeconds>0)?(statistic.editModel.caller[i].serviceLevelSeconds):(statistic.editModel.serviceLevelSeconds);
    viewerConfidenceClientData(viewer,statistic.kundenProTyp[i],statistic.simDays,sl);
  }
  
  viewer.done();
  
  return viewer;
}

/* Systemdaten (Text) */

function viewerSystemInformation(language,statistic,content) {
  var viewer=new CallcenterSimulatorViewerText(language,content);

  viewer.addHeading(1,language.tr("SimStatistic.SystemData"));
  viewer.beginParagraph();
  viewer.addLine(language.tr("SimStatistic.SystemData.Version")+": "+statistic.editModel.version);
  if (statistic.runUser!="") viewer.addLine(language.tr("SimStatistic.SystemData.User")+": "+statistic.runUser);
  if (statistic.runDate!="") viewer.addLine(language.tr("SimStatistic.SystemData.Date")+": "+statistic.runDate);
  viewer.addLine(language.tr("SimStatistic.SystemData.Threads")+": "+statistic.runThreads);
  if (statistic.runServer!="") viewer.addLine(language.tr("SimStatistic.SystemData.ServerVersion")+": "+statistic.runServer);
  if (statistic.runServerOS!="") viewer.addLine(language.tr("SimStatistic.SystemData.ServerOS")+": "+statistic.runServerOS);
  viewer.addLine(language.tr("SimStatistic.SystemData.SimDays")+": "+viewer.formatLong(statistic.simDays));
  viewer.endParagraph();

  viewer.beginParagraph();
  var t=(statistic.runThreads>1)?" (*)":"";
  viewer.addLine(language.tr("SimStatistic.SystemData.SimulationTime")+": "+viewer.formatLong(statistic.runTime)+" "+language.tr("Statistic.Units.MilliSeconds"));
  viewer.addLine(language.tr("SimStatistic.SystemData.SimulationTimePerSimulatedDay")+t+": "+viewer.formatLong(statistic.runTime*statistic.runThreads/statistic.simDays)+" "+language.tr("Statistic.Units.MilliSeconds"));
  viewer.addLine(language.tr("SimStatistic.SystemData.SimulatedEvents")+": "+viewer.formatLong(statistic.simEvents));
  viewer.endParagraph();

  if (statistic.runTime>0) {
    viewer.beginParagraph();
    viewer.addLine(language.tr("SimStatistic.SystemData.EventsPerSecond")+": "+viewer.formatLong(1000*statistic.simEvents/statistic.runTime));
    viewer.addLine(language.tr("SimStatistic.SystemData.SimulationModelClientsPerSecond")+": "+viewer.formatLong(1000*statistic.kundenGlobal.kunden/statistic.simDays/statistic.runTime));
	viewer.addLine(language.tr("SimStatistic.SystemData.ClientsPerSecond")+": "+viewer.formatLong(1000*statistic.kundenGlobal.kunden/statistic.runTime));
	if (statistic.kundenGlobal.anrufe>0) viewer.addLine(language.tr("SimStatistic.SystemData.TimePerCall")+t+": "+viewer.formatNumber(1000*statistic.runTime*statistic.runThreads/statistic.kundenGlobal.anrufe,1)+" s");
	if (statistic.simEvents>0) viewer.addLine(language.tr("SimStatistic.SystemData.TimePerEvent")+t+": "+viewer.formatNumber(1000*statistic.runTime*statistic.runThreads/statistic.simEvents,2)+" s");
    viewer.endParagraph();
  }

  if (statistic.runThreads>1) {
    viewer.beginParagraph();
    viewer.addLine(language.tr("SimStatistic.SystemData.MultiThreadInfo"));
    viewer.endParagraph();
  }

  viewer.done();
  
  return viewer;
}

/* Kosten (Text) */

function viewerClientCosts(viewer,kunden,days) {
  if (kunden.name=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllClients.Short")); else viewer.addHeading(2,kunden.name);
  viewer.beginParagraph();
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Yield.Clients"),kunden.revenue,days);
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Costs.Cancel"),kunden.costCancel,days);
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Costs.WaitingTime"),kunden.costWaiting,days);
  viewer.addLineDiv2(1,viewer.tr("Statistic.Total"),kunden.revenue-kunden.costCancel-kunden.costWaiting,days);
  viewer.endParagraph();
 }

function viewerAgentCosts(viewer,agenten,days) {
  if (agenten.name=="" && agenten.type=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllAgents")); else {
    if (agenten.name=="") viewer.addHeading(2,agenten.type); else viewer.addHeading(2,agenten.name);
  }

  viewer.beginParagraph();
  viewer.addLine(1,viewer.tr("SimStatistic.Count")+": "+viewer.formatLong(agenten.anzahlAgenten));
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Costs.Wage"),agenten.costOfficeTime,days);
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Costs.HoldingTimes"),agenten.costCalls,days);
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Costs.HoldingAndPostProcessingTimes"),agenten.costProcessTime,days);
  viewer.addLineDiv2(1,viewer.tr("SimStatistic.Costs.Total.Short"),agenten.costOfficeTime+agenten.costCalls+agenten.costProcessTime,days);
  viewer.endParagraph();
}

function viewerCosts(language,statistic,content) {
  var viewer=new CallcenterSimulatorViewerText(language,content);

  viewer.addHeading(1,language.tr("SimStatistic.Costs.ByClients"));
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) viewerClientCosts(viewer,statistic.kundenProTyp[i],statistic.simDays);
  viewerClientCosts(viewer,statistic.kundenGlobal,statistic.simDays);

  viewer.addHeading(1,language.tr("SimStatistic.Costs.ByAgents"));
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++) viewerAgentCosts(viewer,statistic.agentenProCallcenter[i],statistic.simDays);
  if (statistic.agentenProSkilllevel.length>1) for (var i=0;i<statistic.agentenProSkilllevel.length;i++) viewerAgentCosts(viewer,statistic.agentenProSkilllevel[i],statistic.simDays);
	viewerAgentCosts(viewer,statistic.agentenGlobal,statistic.simDays);

  viewer.addHeading(1,language.tr("SimStatistic.Costs.Total"));
  viewer.beginParagraph();
  viewer.addLineDiv2(1,language.tr("SimStatistic.Yield"),statistic.kundenGlobal.revenue,statistic.simDays);
  viewer.addLineDiv2(1,language.tr("SimStatistic.Costs"),statistic.kundenGlobal.costCancel+statistic.kundenGlobal.costWaiting+statistic.agentenGlobal.costOfficeTime+statistic.agentenGlobal.costCalls+statistic.agentenGlobal.costProcessTime,statistic.simDays);
  viewer.addLineDiv2(1,language.tr("Statistic.Total"),statistic.kundenGlobal.revenue-(statistic.kundenGlobal.costCancel+statistic.kundenGlobal.costWaiting+statistic.agentenGlobal.costOfficeTime+statistic.agentenGlobal.costCalls+statistic.agentenGlobal.costProcessTime),statistic.simDays);
  viewer.endParagraph();
  
  viewer.done();
  
  return viewer;
}

/* Modellinformationen (Text) */

function viewerModelBuildSummery(language,model) {
  var s=language.tr("Model.GenerateDescription.Name").format(model.name)+"\n\n";
  
  var callerCount=0; for (var i=0;i<model.caller.length;i++) callerCount+=model.caller[i].freshCallsCountMean;
  s+=""+(model.caller.length)+" "+
  ((model.caller.length==1)?language.tr("Model.GenerateDescription.ClientType.Single"):language.tr("Model.GenerateDescription.ClientType.Multiple"))+" ("+language.tr("Model.GenerateDescription.FreshCalls.All").format(callerCount)+"): \n";

  for (var i=0;i<model.caller.length;i++) {
    s+="  - "+model.caller[i].name;
    if (!model.caller[i].active) s+=" ("+language.tr("Dialog.inactive.lower")+")";
    s+=" ("+model.caller[i].freshCallsCountMean+" "+language.tr("Model.GenerateDescription.FreshCalls");
	if (model.caller[i].freshCallsCountSD>0) s+="; "+language.tr("Distribution.StdDev")+" "+viewer.formatNumber(model.caller[i].freshCallsCountSD,1);
	s+=")";
	s+="\n";
  }

  var callContinue=false;
  var callCancel=false;
  var callRetry=false;
  if (model.caller.length>0) {
    callContinue=(model.caller[0].continueProbability>0);
    callCancel=(model.caller[0].waitingTimeMode!=model.caller[0].WAITING_TIME_MODE_OFF);
    callRetry=(model.caller[0].retryProbabiltyAfterGiveUpFirstRetry>0);
    var scoreBase=model.caller[0].scoreBase;
    var scoreSecond=model.caller[0].scoreSecond;
    var scoreContinued=model.caller[0].scoreContinued;
    var sameScore=true;
    for (var i=1;i<model.caller.length;i++) {
      if (scoreBase!=model.caller[i].scoreBase) sameScore=false;
      if (scoreSecond!=model.caller[i].scoreSecond) sameScore=false;
      if (scoreContinued!=model.caller[i].scoreContinued) sameScore=false;
      callContinue=callContinue || (model.caller[i].continueProbability>0);
      callCancel=callCancel || (model.caller[i].waitingTimeMode!=model.caller[i].WAITING_TIME_MODE_OFF);
      callRetry=callRetry || (model.caller[i].retryProbabiltyAfterGiveUpFirstRetry>0);
    }
    if (sameScore) s+="  - "+language.tr("Model.GenerateDescription.ClientPriority.Same")+"\n"; else s+="  - "+language.tr("Model.GenerateDescription.ClientPriority.Different")+"\n";
  }
  
  s+="\n"+(model.callcenter.length)+" "+((model.callcenter.length==1)?language.tr("Model.GenerateDescription.Callcenter.Single"):language.tr("Model.GenerateDescription.Callcenter.Multiple"))+":\n";
  
  var agentType=-3;

  for (var i=0;i<model.callcenter.length;i++) {
    var c=model.callcenter[i];
    s+="  - "+c.name;
    if (!c.active) s+=" ("+language.tr("Dialog.inactive.lower")+")";
    s+=":\n";
    s+="&nbsp;&nbsp;&nbsp;&nbsp;"+(c.agents.length)+" "+((c.agents.length==1)?language.tr("Model.GenerateDescription.AgentGroup.Single"):language.tr("Model.GenerateDescription.AgentGroupMultiple"))+"\n&nbsp;&nbsp;&nbsp;&nbsp;(";
    var types=[];
    for (var j=0;j<c.agents.length;j++) if (c.agents[j].active) {
      if (agentType==-3) {
        if (c.agents[j].count>0) agentType=1;
        if (c.agents[j].count<0) agentType=c.agents[j].count;
      } else {
        if (c.agents[j].count>0 && agentType<0) agentType=0;
        if (c.agents[j].count<0 && agentType!=c.agents[j].count) agentType=0;
      }
      for (var k=0;k<model.skills.length;k++) if (model.skills[k].name==c.agents[j].skillLevel) {
	    for (var l=0;l<model.skills[k].callerTypeName.length;l++) if (types.indexOf(model.skills[k].callerTypeName[l])<0) types.push(model.skills[k].callerTypeName[l]);
      }
    }		
    var first=true; for (var j=0;j<types.length;j++) {if (!first) s+=", "; s+=types[j]; first=false;}
    s+=")\n";
  }

  s+="\n"+(model.skills.length)+" "+((model.skills.length==1)?language.tr("Model.GenerateDescription.SkillLevel.Single"):language.tr("Model.GenerateDescription.SkillLevel.Multiple"))+":\n";
  for (var i=0;i<model.skills.length;i++) {
    s+="  - "+model.skills[i].name+"\n&nbsp;&nbsp;&nbsp;&nbsp;(";
    var first=true; for (var j=0;j<model.skills[i].callerTypeName.length;j++) {if (!first) s+=", "; s+=model.skills[i].callerTypeName[j]; first=false;}
    s+=")\n";
  }

  s+="\n";
  switch (agentType) {
    case -2: s+=language.tr("Model.GenerateDescription.Agents.FromFreshCalls")+"\n"; break;
    case -1: s+=language.tr("Model.GenerateDescription.Agents.DistributionOverTheDay")+"\n"; break;
    case 0: s+=language.tr("Model.GenerateDescription.Agents.Different")+"\n"; break;
    case 1: s+=language.tr("Model.GenerateDescription.Agents.FixedWorkingTimes")+"\n"; break;
    default: s+=anguage.tr("Model.GenerateDescription.Agents.NoAgents")+"\n"; break;
  }

  if (callCancel || callRetry || callContinue) {
    s+=language.tr("Model.GenerateDescription.Extra.TheModelContains")+" ";
    if (callCancel || callRetry) {
      if (callRetry) s+=language.tr("Model.GenerateDescription.Extra.Retry"); else s+=language.tr("Model.GenerateDescription.Extra.Cancelation");
      if (callContinue) s+=" "+language.tr("Model.GenerateDescription.Extra.And")+" ";
    }
    if (callContinue) s+=language.tr("Model.GenerateDescription.Extra.Forwarding");
    s+=".\n";
  }

  return s;
}

function viewerModel(language,statistic,content) {
  var viewer=new CallcenterSimulatorViewerText(language,content);
  
  viewer.addHeading(1,language.tr("SimStatistic.ModelInformation.Name"));
  viewer.beginParagraph();
  viewer.addLine(statistic.editModel.name);
  viewer.endParagraph();
  
  viewer.addHeading(1,language.tr("SimStatistic.ModelInformation.Description"));
  viewer.beginParagraph();
  viewer.addLine(statistic.editModel.description.replace(/\n/g,"<br>"));
  viewer.endParagraph();
  
  if (statistic.editModel.date!="") {
    viewer.addHeading(1,language.tr("SimStatistic.ModelInformation.Date"));
    viewer.beginParagraph();
    var parts=statistic.editModel.date.split("/");
    var dateObj=new Date(parseInt(parts[2])+2000,parseInt(parts[0])-1,parseInt(parts[1]));
    viewer.addLine(dateObj.toLocaleDateString());
    viewer.endParagraph();
  }
  
  viewer.addHeading(1,language.tr("SimStatistic.ModelInformation.Summary"));
  viewer.beginParagraph();
  viewer.addLine(viewerModelBuildSummery(language,statistic.editModel).replace(/\n/g,"<br>"));
  viewer.endParagraph();
  
  viewer.done();
  
  return viewer;
}

/* Erlang-C Vergleich (Tabelle+Grafik) */

var ERLANGC_DATA_SUCCESS=0;
var ERLANGC_DATA_WAITING_TIME=1;
var ERLANGC_DATA_SERVICE_LEVEL=2;

function viewerErlangCTableContent(dataType,statistic,viewer) {
  var cols=[];
  
  var sim, erlang1, erlang2;
  switch (dataType) {
    case ERLANGC_DATA_SUCCESS:
	  erlang1=statistic.erlangC1.Success;
	  erlang2=statistic.erlangC2.Success;
	  sim=viewer.div(statistic.kundenGlobal.anrufeErfolgProIntervall,statistic.kundenGlobal.anrufeProIntervall);
	  break;
    case ERLANGC_DATA_WAITING_TIME:
	  erlang1=statistic.erlangC1.WaitingTime;
	  erlang2=statistic.erlangC2.WaitingTime;
	  sim=viewer.div(statistic.kundenGlobal.anrufeWartezeitSumProIntervall,statistic.kundenGlobal.anrufeErfolgProIntervall);
	  break;
    case ERLANGC_DATA_SERVICE_LEVEL:
	  erlang1=statistic.erlangC1.ServiceLevel;
	  erlang2=statistic.erlangC2.ServiceLevel;
	  sim=viewer.div(statistic.kundenGlobal.anrufeServicelevelProIntervall,statistic.kundenGlobal.anrufeErfolgProIntervall);
	  break;
  }
  
  for (var i=0;i<48;i++) {
    var row=[];
	var e1=(erlang1==null)?0:erlang1[i];
	var e2=(erlang2==null)?0:erlang2[i];
	if (dataType==ERLANGC_DATA_WAITING_TIME) {
	  row.push(viewer.formatTime(e1,1));
	  row.push(viewer.formatTime(e2,1));
	  row.push(viewer.formatTime(sim[i],1));
	  row.push(viewer.formatTime((e1-sim[i]),1));
	  row.push(viewer.formatTime((e2-sim[i]),1));
	} else {
	  row.push(viewer.formatNumber(100*e1,1)+"%");
	  row.push(viewer.formatNumber(100*e2,1)+"%");
	  row.push(viewer.formatNumber(100*sim[i],1)+"%");
	  row.push(viewer.formatNumber(100*(e1-sim[i]),1)+"%");
	  row.push(viewer.formatNumber(100*(e2-sim[i]),1)+"%");
	}	
	cols.push(row);
  }
  return cols;
}

function viewerErlangCTable(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerTable(language,content);
  
  var dataRows=[];
  for (var i=0;i<48;i++) dataRows.push(viewer.formatTime(i*1800)+"-"+viewer.formatTime(i*1800+1799));
  
  var dataCols=[];  
  var value="";
  switch (dataType) {
    case ERLANGC_DATA_SUCCESS : value=language.tr("SimStatistic.Accessibility"); break;
    case ERLANGC_DATA_WAITING_TIME : value=language.tr("SimStatistic.AverageWaitingTime"); break;
    case ERLANGC_DATA_SERVICE_LEVEL : value=language.tr("SimStatistic.ServiceLevel"); break;
  }
  dataCols.push(value+" ("+language.tr("SimStatistic.Type.ErlangCSimple")+")");
  dataCols.push(value+" ("+language.tr("SimStatistic.Type.ErlangCComplex")+")");
  dataCols.push(value+" ("+language.tr("SimStatistic.Type.Simulation")+")");
  dataCols.push(language.tr("SimStatistic.Error")+" "+language.tr("SimStatistic.Type.ErlangCSimple")+" - "+language.tr("SimStatistic.Type.Simulation"));
  dataCols.push(language.tr("SimStatistic.Error")+" "+language.tr("SimStatistic.Type.ErlangCComplex")+" - "+language.tr("SimStatistic.Type.Simulation"));
  
  var dataContent=viewerErlangCTableContent(dataType,statistic,viewer);
  
  viewer.doneDirect(dataCols,dataRows,dataContent);
  
  return viewer;
}

function viewerErlangCLineChart(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerLineChart(language,content);
  
  var title, erlang1, erlang2, sim;

  switch (dataType) {
  case ERLANGC_DATA_SUCCESS:
    title=language.tr("SimStatistic.Accessibility.OverTheDay");
    erlang1=statistic.erlangC1.Success;
	erlang2=statistic.erlangC2.Success;
    sim=viewer.div(statistic.kundenGlobal.anrufeErfolgProIntervall,statistic.kundenGlobal.anrufeProIntervall);
    viewer.setupDayPercent(title,language.tr("SimStatistic.AveragePerHalfHourInterval"),language.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    break;
  case ERLANGC_DATA_WAITING_TIME:
    title=language.tr("SimStatistic.AverageWaitingTime.OverTheDay");
    erlang1=statistic.erlangC1.WaitingTime;
	erlang2=statistic.erlangC2.WaitingTime;
    sim=viewer.div(statistic.kundenGlobal.anrufeWartezeitSumProIntervall,statistic.kundenGlobal.anrufeErfolgProIntervall);
    viewer.setupDay(title,language.tr("SimStatistic.AveragePerHalfHourInterval")+" ("+language.tr("Statistic.Units.InSeconds")+")",language.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    break;
  case ERLANGC_DATA_SERVICE_LEVEL:
    title=language.tr("SimStatistic.ServiceLevel.OverTheDay");
    erlang1=statistic.erlangC1.ServiceLevel;
	erlang2=statistic.erlangC2.ServiceLevel;
    sim=viewer.div(statistic.kundenGlobal.anrufeServicelevelProIntervall,statistic.kundenGlobal.anrufeErfolgProIntervall);
    viewer.setupDayPercent(title,language.tr("SimStatistic.AveragePerHalfHourInterval"),language.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    break;
  default:
    return;
  }
  
  viewer.addSeries(title+" ("+language.tr("SimStatistic.Type.Simulation")+")","blue",sim);
  viewer.addSeries(title+" ("+language.tr("SimStatistic.Type.ErlangCSimple")+")","red",erlang1);
  viewer.addSeries(title+" ("+language.tr("SimStatistic.Type.ErlangCComplex")+")","orange",erlang2);
  viewer.addSeriesToSecondSet(language.tr("SimStatistic.Caller"),"black",viewer.div(statistic.kundenGlobal.kundenProIntervall,statistic.simDays));
  
  viewer.done();

  return viewer;
}
/*
(c) Alexander Herzog
*/

'use strict';

var DATA_TYPE_COUNT=0;
var DATA_TYPE_SUCCESS=1;
var DATA_TYPE_SERVICE_LEVEL=2;
var DATA_TYPE_WAITINGTIME=3;

var DATA_TYPE_CALLS=17;
var DATA_TYPE_CALLS_CONTINUE=18;
var DATA_TYPE_CALLS_RETRIED=19;
var DATA_TYPE_CALLS_CANCEL=20;
var DATA_TYPE_CALLS_SUCCESS=21;
var DATA_TYPE_CALLS_CONTINUE_PART=22;
var DATA_TYPE_CALLS_CANCEL_PART=23;
var DATA_TYPE_CALLS_SUCCESS_PART=24;
var DATA_TYPE_CALLS_SERVICE_LEVEL=25;
var DATA_TYPE_CALLS_SERVICE_LEVEL_ALL=26;
var DATA_TYPE_CALLS_WAITINGTIME=27;
var DATA_TYPE_CALLS_STAYINGTIME=28;
var DATA_TYPE_CALLS_CANCELTIME=29;

var DATA_TYPE_CLIENTS=30;
var DATA_TYPE_CLIENTS_CONTINUE=31;
var DATA_TYPE_CLIENTS_RETRIED=32;
var DATA_TYPE_CLIENTS_CANCEL=33;
var DATA_TYPE_CLIENTS_SUCCESS=34;
var DATA_TYPE_CLIENTS_CONTINUE_PART=35;
var DATA_TYPE_CLIENTS_CANCEL_PART=36;
var DATA_TYPE_CLIENTS_SUCCESS_PART=37;
var DATA_TYPE_CLIENTS_SERVICE_LEVEL=38;
var DATA_TYPE_CLIENTS_SERVICE_LEVEL_ALL=39;
var DATA_TYPE_CLIENTS_WAITINGTIME=40;
var DATA_TYPE_CLIENTS_STAYINGTIME=41;
var DATA_TYPE_CLIENTS_CANCELTIME=42;
var DATA_TYPE_RECALLS=43;

var DATA_TYPE_FRESH_CALLS=44;
var DATA_TYPE_RECALLS_PIE=45;
var DATA_TYPE_CALLS=46;
var DATA_TYPE_CANCELED_CALLS=47;
var DATA_TYPE_CONTINUED_CALLS=48;
var DATA_TYPE_RETRIED_CALLS=49;

var DATA_TYPE_CALLER=50;
var DATA_TYPE_CLIENT_WAITINGTIME_DIST=51;
var DATA_TYPE_CALLER_WAITINGTIME_DIST=52;
var DATA_TYPE_CLIENT_STAYINGTIME_DIST=53;
var DATA_TYPE_CALLER_STAYINGTIME_DIST=54;
var DATA_TYPE_CLIENT_WAITINGTIME_DIST_LONG=55;
var DATA_TYPE_CALLER_WAITINGTIME_DIST_LONG=56;
var DATA_TYPE_CLIENT_STAYINGTIME_DIST_LONG=57;
var DATA_TYPE_CALLER_STAYINGTIME_DIST_LONG=58;
var DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST=59;
var DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST=60;
var DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST_LONG=61;
var DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST_LONG=62;
var DATA_TYPE_CLIENT_CANCELTIME_DIST=63;
var DATA_TYPE_CALLER_CANCELTIME_DIST=64;
var DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG=65;
var DATA_TYPE_CALLER_CANCELTIME_DIST_LONG=66;
var DATA_TYPE_CLIENT_WAITING_AND_CANCEL=67;
var DATA_TYPE_CALLER_WAITING_AND_CANCEL=68;
var DATA_TYPE_CLIENT_SUCCESS=69;
var DATA_TYPE_CALLER_SUCCESS=70;
var DATA_TYPE_CLIENT_SERVICE_LEVEL=71;
var DATA_TYPE_CALLER_SERVICE_LEVEL=72;
var DATA_TYPE_CLIENT_SERVICE_LEVEL_ALL=73;
var DATA_TYPE_CALLER_SERVICE_LEVEL_ALL=74;

var DATA_TYPE_WAITINGTIME_BYCLIENT=75;
var DATA_TYPE_WAITINGTIME_BYCALL=76;
var DATA_TYPE_STAYINGTIME_BYCLIENT=77;
var DATA_TYPE_STAYINGTIME_BYCALL=78;
var DATA_TYPE_WAITINGANDSTAYINGTIME_BYCLIENT=79;
var DATA_TYPE_WAITINGANDSTAYINGTIME_BYCALL=80;
var DATA_TYPE_SUCCESS_BYCLIENT=81;
var DATA_TYPE_SUCCESS_BYCALL=82;
var DATA_TYPE_SERVICELEVEL_BYCLIENT=83;
var DATA_TYPE_SERVICELEVEL_BYCALL=84;
var DATA_TYPE_SERVICELEVEL_BYCLIENT_ALL=85;
var DATA_TYPE_SERVICELEVEL_BYCALL_ALL=86;

/* Texte */

function viewerKundenTextClientData(dataType,viewer,kunden,days,ServiceLevel) {
  if (kunden.name=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllClients.Short")); else viewer.addHeading(2,kunden.name);

  var l;
		
  switch (dataType) {
    case DATA_TYPE_COUNT:
      viewer.beginParagraph();
      viewer.addLineDiv(1,viewer.tr("SimStatistic.FreshCalls"),kunden.kunden-kunden.kundenUebertrag,days);
	  if (kunden.kundenWiederanruf>0) viewer.addLineDiv(1,viewer.tr("SimStatistic.RecallingClients.Info"),kunden.kundenWiederanruf,days);
      viewer.addLineDiv(1,viewer.tr("SimStatistic.Calls.Info"),kunden.anrufe-kunden.anrufeUebertrag,days);
      viewer.addLine(1,viewer.tr("SimStatistic.Canceled.CallBlocked"),kunden.anrufeBlocked,days,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.Canceled.CallWaitingTime"),kunden.anrufeAbbruch,days,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.Canceled.CallCarriedOver"),kunden.anrufeUebertrag,days,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.Canceled.Client"),kunden.kundenBlocked+kunden.kundenAbbruch,days,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.ForwardedCalls"),kunden.anrufeWeiterleitungen,days,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.ForwardedClients"),kunden.kundenWeiterleitungen,days,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.Retryer")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",kunden.anrufeWiederholungen,days,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.Retryer")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",kunden.kundenWiederholungen,days,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.SuccessfulCalls"),kunden.anrufeErfolg,days,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addLine(1,viewer.tr("SimStatistic.SuccessfulClients"),kunden.kundenErfolg,days,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag);
      viewer.endParagraph();
      break;
    case DATA_TYPE_WAITINGTIME:
      viewer.addHeading(3,viewer.tr("SimStatistic.WaitingTime")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")");
      viewer.beginParagraph();
      viewer.addShortTimeParts(2,viewer.tr("Distribution.Mean"),kunden.anrufeWartezeitSum,kunden.anrufeErfolg);
      l=viewer.calcStd(kunden.anrufeWartezeitSum2,kunden.anrufeWartezeitSum,kunden.anrufeErfolg);
      viewer.addShortTimeParts(2,viewer.tr("Distribution.StdDev"),l,1);
      viewer.addLine(2,viewer.tr("Distribution.CV"),l/Math.max(1,kunden.anrufeWartezeitSum/Math.max(1,kunden.anrufeErfolg)),1);
      viewer.endParagraph();
      viewer.addHeading(3,viewer.tr("SimStatistic.ResidenceTime")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")");
      viewer.beginParagraph();
      viewer.addShortTimeParts(2,viewer.tr("Distribution.Mean"),kunden.anrufeVerweilzeitSum,kunden.anrufeErfolg);
      l=viewer.calcStd(kunden.anrufeVerweilzeitSum2,kunden.anrufeVerweilzeitSum,kunden.anrufeErfolg);
      viewer.addShortTimeParts(2,viewer.tr("Distribution.StdDev"),l,1);
      viewer.addLine(2,viewer.tr("Distribution.CV"),l/Math.max(1,kunden.anrufeVerweilzeitSum/Math.max(1,kunden.anrufeErfolg)),1);
      viewer.endParagraph();
      viewer.addHeading(3,viewer.tr("SimStatistic.CancelTime")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")");
      viewer.beginParagraph();
      viewer.addShortTimeParts(2,viewer.tr("Distribution.Mean"),kunden.anrufeAbbruchzeitSum,kunden.anrufeAbbruch);
      l=viewer.calcStd(kunden.anrufeAbbruchzeitSum2,kunden.anrufeAbbruchzeitSum,kunden.anrufeAbbruch);
      viewer.addShortTimeParts(2,viewer.tr("Distribution.StdDev"),l,1);
      viewer.addLine(2,viewer.tr("Distribution.CV"),l/Math.max(1,kunden.anrufeAbbruchzeitSum/Math.max(1,kunden.anrufeAbbruch)),1);
      viewer.endParagraph();
      viewer.addHeading(3,viewer.tr("SimStatistic.WaitingTime")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")");
      viewer.beginParagraph();
      viewer.addShortTimeParts(2,viewer.tr("Distribution.Mean"),kunden.kundenWartezeitSum,kunden.kundenErfolg);
      l=viewer.calcStd(kunden.kundenWartezeitSum2,kunden.kundenWartezeitSum,kunden.kundenErfolg);
      viewer.addShortTimeParts(2,viewer.tr("Distribution.StdDev"),l,1);
      viewer.addLine(2,viewer.tr("Distribution.CV"),l/Math.max(1,kunden.kundenWartezeitSum/Math.max(1,kunden.kundenErfolg)),1);
      viewer.endParagraph();
      viewer.addHeading(3,viewer.tr("SimStatistic.ResidenceTime")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")");
      viewer.beginParagraph();
      viewer.addShortTimeParts(2,viewer.tr("Distribution.Mean"),kunden.kundenVerweilzeitSum,kunden.kundenErfolg);
      l=viewer.calcStd(kunden.kundenVerweilzeitSum2,kunden.kundenVerweilzeitSum,kunden.kundenErfolg);
      viewer.addShortTimeParts(2,viewer.tr("Distribution.StdDev"),l,1);
      viewer.addLine(2,viewer.tr("Distribution.CV"),l/Math.max(1,kunden.kundenVerweilzeitSum/Math.max(1,kunden.kundenErfolg)),1);
      viewer.endParagraph();
      viewer.addHeading(3,viewer.tr("SimStatistic.CancelTime")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")");
      viewer.beginParagraph();
      viewer.addShortTimeParts(2,viewer.tr("Distribution.Mean"),kunden.kundenAbbruchzeitSum,kunden.kundenAbbruch);
      l=viewer.calcStd(kunden.kundenAbbruchzeitSum2,kunden.kundenAbbruchzeitSum,kunden.kundenAbbruch);
      viewer.addShortTimeParts(2,viewer.tr("Distribution.StdDev"),l,1);
      viewer.addLine(2,viewer.tr("Distribution.CV"),l/Math.max(1,kunden.kundenAbbruchzeitSum/Math.max(1,kunden.kundenAbbruch)),1);
      viewer.endParagraph();
      break;
    case DATA_TYPE_SUCCESS:
      viewer.beginParagraph();
      viewer.addPercentLineParts(1,viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",kunden.anrufeErfolg,kunden.anrufe-kunden.anrufeUebertrag);
      viewer.addPercentLineParts(1,viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",kunden.kundenErfolg,kunden.kunden-kunden.kundenUebertrag);
      viewer.endParagraph();
      break;
    case DATA_TYPE_SERVICE_LEVEL:
      var serviceLevelText="P(W<="+ServiceLevel+")";
      if (ServiceLevel<0) serviceLevelText="("+viewer.tr("SimStatistic.DifferentServiceLevelValuesPerClientType")+")";
      viewer.beginParagraph();
      viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnCallBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+") "+serviceLevelText,kunden.anrufeServicelevel,kunden.anrufeErfolg);
      viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnClientBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.SuccessfulClients")+") "+serviceLevelText,kunden.kundenServicelevel,kunden.kundenErfolg);
	  viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnCallBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.AllCalls")+") "+serviceLevelText,kunden.anrufeServicelevel,kunden.anrufe);
      viewer.addPercentLineParts(1,viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnClientBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.AllClients")+") "+serviceLevelText,kunden.kundenServicelevel,kunden.kunden);
      viewer.endParagraph();
      break;
  }
}	
	
function viewerKundenText(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerText(language,content);

  switch (dataType) {
    case DATA_TYPE_COUNT: viewer.addHeading(1,viewer.tr("SimStatistic.Category.NumberOfCallers")); break;
    case DATA_TYPE_WAITINGTIME: viewer.addHeading(1,viewer.tr("SimStatistic.WaitingAndResidenceTimes")); break;
    case DATA_TYPE_SUCCESS: viewer.addHeading(1,viewer.tr("SimStatistic.Accessibility")); break;
    case DATA_TYPE_SERVICE_LEVEL: viewer.addHeading(1,viewer.tr("SimStatistic.ServiceLevel")); break;
  }

  var needDetailedData=(statistic.kundenProTyp.length>1);
  if (!needDetailedData && dataType==DATA_TYPE_SERVICE_LEVEL && statistic.editModel.caller[0].serviceLevelSeconds>0) needDetailedData=true;

  var serviceLevel=statistic.editModel.serviceLevelSeconds;
  if (statistic.editModel.caller[0].serviceLevelSeconds>0) serviceLevel=statistic.editModel.caller[0].serviceLevelSeconds;
  for (var i=1;i<statistic.kundenProTyp.length;i++) {
    var sl=statistic.editModel.caller[i].serviceLevelSeconds;
    if (sl<=0) sl=statistic.editModel.serviceLevelSeconds;
    if (sl!=serviceLevel) {serviceLevel=-1; break;}
  }

  viewerKundenTextClientData(dataType,viewer,statistic.kundenGlobal,statistic.simDays,serviceLevel);
  if (needDetailedData) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    var sl=(statistic.editModel.caller[i].serviceLevelSeconds>0)?(statistic.editModel.caller[i].serviceLevelSeconds):(statistic.editModel.serviceLevelSeconds);
    viewerKundenTextClientData(dataType,viewer,statistic.kundenProTyp[i],statistic.simDays,sl);
  }
  
  viewer.done();

  return viewer;
}

/* Tabellen */

function viewerKundenTableRowNamesTimeArray(statistic,viewer) {
  var row=[];
  for (var i=0;i<statistic.kundenGlobal.DistMax;i++) row[i]=i+" "+viewer.tr("Statistic.Seconds");
  return row;
}

function viewerKundenTableRowNamesLongTimeArray(statistic,viewer) {
  var row=[];
  for (var i=0;i<statistic.kundenGlobal.DistMax;i++) row[i]=viewer.formatTime(i*1800)+"-"+viewer.formatTime((i+1)*1800-1);
  return row;
}

function viewerKundenTableRowNames(dataType,statistic,viewer) {
  switch (dataType) {
  case DATA_TYPE_COUNT:
    return [
      viewer.tr("SimStatistic.FreshCalls"),
      viewer.tr("SimStatistic.RecallingClients.Info"),
      viewer.tr("SimStatistic.Retryer")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",
      viewer.tr("SimStatistic.Call.Total"),
      viewer.tr("SimStatistic.Call.Blocked"),
      viewer.tr("SimStatistic.Call.Blocked"),
      viewer.tr("SimStatistic.Call.Canceled"),
      viewer.tr("SimStatistic.Call.Canceled"),
      viewer.tr("SimStatistic.Call.CarriedOver"),
      viewer.tr("SimStatistic.Call.CarriedOver"),
      viewer.tr("SimStatistic.Client.Canceled"),
      viewer.tr("SimStatistic.Client.Canceled"),
      viewer.tr("SimStatistic.ForwardedCalls"),
      viewer.tr("SimStatistic.ForwardedCalls"),
      viewer.tr("SimStatistic.ForwardedClients"),
      viewer.tr("SimStatistic.ForwardedClients"),
      viewer.tr("SimStatistic.SuccessfulCalls"),
      viewer.tr("SimStatistic.SuccessfulCalls"),
      viewer.tr("SimStatistic.SuccessfulClients"),
      viewer.tr("SimStatistic.SuccessfulClients")
    ];
  case DATA_TYPE_SUCCESS:
    return [
      viewer.tr("SimStatistic.Accessibility")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.Accessibility")+" "+viewer.tr("SimStatistic.OnClientBasis")
    ];
  case DATA_TYPE_SERVICE_LEVEL:
    return [
      viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnCallBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")",
      viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnClientBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")",
      viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnCallBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.AllCalls")+")",
      viewer.tr("SimStatistic.ServiceLevel")+" "+viewer.tr("SimStatistic.OnClientBasis")+" ("+viewer.tr("SimStatistic.CalculatedOn.AllClients")+")"
    ];
  case DATA_TYPE_WAITINGTIME:
    return [
      viewer.tr("SimStatistic.WaitingTime.Mean")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.WaitingTime.StdDev")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.WaitingTime.CV")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.ResidenceTime.Mean")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.ResidenceTime.StdDev")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.ResidenceTime.CV")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.CancelTime.Mean")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.CancelTime.StdDev")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.CancelTime.CV")+" "+viewer.tr("SimStatistic.OnCallBasis"),
      viewer.tr("SimStatistic.WaitingTime.Mean")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.WaitingTime.StdDev")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.WaitingTime.CV")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.ResidenceTime.Mean")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.ResidenceTime.StdDev")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.ResidenceTime.CV")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.CancelTime.Mean")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.CancelTime.StdDev")+" "+viewer.tr("SimStatistic.OnClientBasis"),
      viewer.tr("SimStatistic.CancelTime.CV")+" "+viewer.tr("SimStatistic.OnClientBasis")
    ];
  case DATA_TYPE_CALLER_WAITINGTIME_DIST:
  case DATA_TYPE_CALLER_STAYINGTIME_DIST:
  case DATA_TYPE_CALLER_CANCELTIME_DIST:
  case DATA_TYPE_CLIENT_WAITINGTIME_DIST:
  case DATA_TYPE_CLIENT_STAYINGTIME_DIST:
  case DATA_TYPE_CLIENT_CANCELTIME_DIST:
    return viewerKundenTableRowNamesTimeArray(statistic,viewer);
  case DATA_TYPE_CALLER_WAITINGTIME_DIST_LONG:
  case DATA_TYPE_CALLER_STAYINGTIME_DIST_LONG:
  case DATA_TYPE_CALLER_CANCELTIME_DIST_LONG:
  case DATA_TYPE_CLIENT_WAITINGTIME_DIST_LONG:
  case DATA_TYPE_CLIENT_STAYINGTIME_DIST_LONG:
  case DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG:
    return viewerKundenTableRowNamesLongTimeArray(statistic,viewer);
  default:
    return [];
  }
}

function viewerKundenTableColNames(language,dataType,statistic) {
  var head=[];
  for (var i=0;i<statistic.kundenProTyp.length;i++) head.push(statistic.kundenProTyp[i].name); 
  head.push(language.tr("Statistic.Total")); 
  return head;
}

function viewerKundenTableContentRow(dataType,viewer,kunden,days,distMax) {
  var line=[];
  var d,m,l;
  
  switch (dataType) {
    case DATA_TYPE_COUNT:
      line.push(viewer.addCell(kunden.kunden-kunden.kundenUebertrag,days));
	  line.push(viewer.addCell(kunden.kundenWiederanruf,days));
      line.push(viewer.addCell(kunden.anrufeWiederholungen,days));
      line.push(viewer.addCell(kunden.anrufe-kunden.anrufeUebertrag,days));

      line.push(viewer.addCell(kunden.anrufeBlocked,days));
	  line.push(viewer.addPercentCellParts(kunden.anrufeBlocked,kunden.anrufe-kunden.anrufeUebertrag));
      line.push(viewer.addCell(kunden.anrufeAbbruch,days));
      line.push(viewer.addPercentCellParts(kunden.anrufeAbbruch,kunden.anrufe-kunden.anrufeUebertrag));

      line.push(viewer.addCell(kunden.anrufeUebertrag,days));
      line.push(viewer.addPercentCellParts(kunden.anrufeUebertrag,kunden.anrufe-kunden.anrufeUebertrag));

      line.push(viewer.addCell(kunden.kundenBlocked+kunden.kundenAbbruch,days));
      line.push(viewer.addPercentCellParts(kunden.kundenBlocked+kunden.kundenAbbruch,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag));

      line.push(viewer.addCell(kunden.anrufeWeiterleitungen,days));
      line.push(viewer.addPercentCellParts(kunden.anrufeWeiterleitungen,kunden.anrufe-kunden.anrufeUebertrag));
      line.push(viewer.addCell(kunden.kundenWeiterleitungen,days));
      line.push(viewer.addPercentCellParts(kunden.kundenWeiterleitungen,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag));

      line.push(viewer.addCell(kunden.anrufeErfolg,days));
      line.push(viewer.addPercentCellParts(kunden.anrufeErfolg,kunden.anrufe-kunden.anrufeUebertrag));
      line.push(viewer.addCell(kunden.kundenErfolg,days));
      line.push(viewer.addPercentCellParts(kunden.kundenErfolg,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag));
      break;
	  
    case DATA_TYPE_SUCCESS:
      line.push(viewer.addPercentCellParts(kunden.anrufeErfolg,kunden.anrufe-kunden.anrufeUebertrag));
      line.push(viewer.addPercentCellParts(kunden.kundenErfolg,kunden.kunden+kunden.kundenWiederanruf-kunden.kundenUebertrag));
      break;

    case DATA_TYPE_SERVICE_LEVEL:
      line.push(viewer.addPercentCellParts(kunden.anrufeServicelevel,kunden.anrufeErfolg));
      line.push(viewer.addPercentCellParts(kunden.kundenServicelevel,kunden.kundenErfolg));
	  line.push(viewer.addPercentCellParts(kunden.anrufeServicelevel,kunden.anrufe));
      line.push(viewer.addPercentCellParts(kunden.kundenServicelevel,kunden.kunden));
      break;

    case DATA_TYPE_WAITINGTIME:
      m=kunden.anrufeWartezeitSum/Math.max(1,kunden.anrufeErfolg);
      l=viewer.calcStd(kunden.anrufeWartezeitSum2,kunden.anrufeWartezeitSum,kunden.anrufeErfolg);
      line.push(viewer.formatTime(Math.round(m)));
      line.push(viewer.formatTime(l));
      line.push(viewer.formatNumber(l/Math.max(1,m)));
	  
      m=kunden.anrufeVerweilzeitSum/Math.max(1,kunden.anrufeErfolg);
      l=viewer.calcStd(kunden.anrufeVerweilzeitSum2,kunden.anrufeVerweilzeitSum,kunden.anrufeErfolg);
      line.push(viewer.formatTime(Math.round(m)));
      line.push(viewer.formatTime(l));
      line.push(viewer.formatNumber(l/Math.max(1,m)));

      m=kunden.anrufeAbbruchzeitSum/Math.max(1,kunden.anrufeAbbruch);
      l=viewer.calcStd(kunden.anrufeAbbruchzeitSum2,kunden.anrufeAbbruchzeitSum,kunden.anrufeAbbruch);
      line.push(viewer.formatTime(Math.round(m)));
      line.push(viewer.formatTime(l));
      line.push(viewer.formatNumber(l/Math.max(1,m)));

      m=kunden.kundenWartezeitSum/Math.max(1,kunden.kundenErfolg);
      l=viewer.calcStd(kunden.kundenWartezeitSum2,kunden.kundenWartezeitSum,kunden.kundenErfolg);
      line.push(viewer.formatTime(Math.round(m)));
      line.push(viewer.formatTime(l));
      line.push(viewer.formatNumber(l/Math.max(1,m)));

      m=kunden.kundenVerweilzeitSum/Math.max(1,kunden.kundenErfolg);
      l=viewer.calcStd(kunden.kundenVerweilzeitSum2,kunden.kundenVerweilzeitSum,kunden.kundenErfolg);
      line.push(viewer.formatTime(Math.round(m)));
      line.push(viewer.formatTime(l));
      line.push(viewer.formatNumber(l/Math.max(1,m)));

      m=kunden.kundenAbbruchzeitSum/Math.max(1,kunden.kundenAbbruch);
      l=viewer.calcStd(kunden.kundenAbbruchzeitSum2,kunden.kundenAbbruchzeitSum,kunden.kundenAbbruch);
      line.push(viewer.formatTime(Math.round(m)));
      line.push(viewer.formatTime(l));
      line.push(viewer.formatNumber(l/Math.max(1,m)));
      break;

    case DATA_TYPE_CALLER_WAITINGTIME_DIST:
      d=kunden.anrufeWartezeitVerteilung;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CALLER_STAYINGTIME_DIST:
      d=kunden.anrufeVerweilzeitVerteilung;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CALLER_CANCELTIME_DIST:
      d=kunden.anrufeAbbruchzeitVerteilung;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CLIENT_WAITINGTIME_DIST:
      d=kunden.kundenWartezeitVerteilung;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CLIENT_STAYINGTIME_DIST:
      d=kunden.kundenVerweilzeitVerteilung;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CLIENT_CANCELTIME_DIST:
      d=kunden.kundenAbbruchzeitVerteilung;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CALLER_WAITINGTIME_DIST_LONG:
      d=kunden.anrufeWartezeitVerteilungLang;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CALLER_STAYINGTIME_DIST_LONG:
      d=kunden.anrufeVerweilzeitVerteilungLang;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CALLER_CANCELTIME_DIST_LONG:
      d=kunden.anrufeAbbruchzeitVerteilungLang;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CLIENT_WAITINGTIME_DIST_LONG:
      d=kunden.kundenWartezeitVerteilungLang;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CLIENT_STAYINGTIME_DIST_LONG:
      d=kunden.kundenVerweilzeitVerteilungLang;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;

    case DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG:
      d=kunden.kundenAbbruchzeitVerteilungLang;
      for (var i=0;i<kunden.DistMax;i++) line.push(viewer.formatNumber(d[i]/days,3));
      break;
  }		
  return line;
}

function viewerKundenTableContent(dataType,statistic,viewer) {
  var data=[];
  for (var i=0;i<statistic.kundenProTyp.length;i++) data.push(viewerKundenTableContentRow(dataType,viewer,statistic.kundenProTyp[i],statistic.simDays));
  data.push(viewerKundenTableContentRow(dataType,viewer,statistic.kundenGlobal,statistic.simDays));
  return viewer.transpose(data);
}

function viewerKundenTable(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerTable(language,content);
  
  var dataRows=viewerKundenTableRowNames(dataType,statistic,viewer);
  var dataCols=viewerKundenTableColNames(language,dataType,statistic);
  var dataContent=viewerKundenTableContent(dataType,statistic,viewer);
  
  viewer.doneDirect(dataCols,dataRows,dataContent);

  return viewer;
}

/* Tabellen (auf Intervallbasis) */

function viewerKundenIntervalTableContent(viewer,kunden,days,dataType) {
  var dist, dist2=null, sum;
  
  switch (dataType) {
    case DATA_TYPE_CALLS:
    	dist=viewer.div(kunden.anrufeProIntervall,days);
    	sum=viewer.formatNumber(kunden.anrufe/days);
    	break;
    case DATA_TYPE_CALLS_CONTINUE:
    	dist=viewer.div(kunden.anrufeWeiterleitungenProIntervall,days);
    	sum=viewer.formatNumber(kunden.anrufeWeiterleitungen/days);
    	break;
    case DATA_TYPE_CALLS_RETRIED:
    	dist=viewer.div(kunden.anrufeWiederholungenProIntervall,days);
    	sum=viewer.formatNumber(kunden.anrufeWiederholungen/days);
    	break;
    case DATA_TYPE_CALLS_CANCEL:
    	dist=viewer.div(kunden.anrufeAbbruchProIntervall,days);
    	sum=viewer.formatNumber(kunden.anrufeAbbruch/days);
    	break;
    case DATA_TYPE_CALLS_SUCCESS:
    	dist=viewer.div(kunden.anrufeErfolgProIntervall,days);
    	sum=viewer.formatNumber(kunden.anrufeErfolg/days);
    	break;

    case DATA_TYPE_CALLS_CONTINUE_PART:
        dist=kunden.anrufeWeiterleitungenProIntervall;
        dist2=kunden.anrufeErfolgProIntervall;
        sum=viewer.formatNumber(100*kunden.anrufeWeiterleitungen/kunden.anrufeErfolg)+"%";
        break;
    case DATA_TYPE_CALLS_CANCEL_PART:
        dist=kunden.anrufeAbbruchProIntervall;
        dist2=kunden.anrufeProIntervall;
        sum=viewer.formatNumber(100*kunden.anrufeAbbruch/kunden.anrufe)+"%";
        break;
    case DATA_TYPE_CALLS_SUCCESS_PART:
        dist=kunden.anrufeErfolgProIntervall;
        dist2=kunden.anrufeProIntervall;
        sum=viewer.formatNumber(100*kunden.anrufeErfolg/kunden.anrufe)+"%";
        break;		
		
    case DATA_TYPE_CALLS_SERVICE_LEVEL:
    	dist=kunden.anrufeServicelevelProIntervall;
    	dist2=kunden.anrufeErfolgProIntervall;
    	sum=viewer.formatNumber(100*kunden.anrufeServicelevel/kunden.anrufeErfolg,1)+"%";
    	break;
	case DATA_TYPE_CALLS_SERVICE_LEVEL_ALL:
    	dist=kunden.anrufeServicelevelProIntervall;
    	dist2=kunden.anrufeProIntervall;
    	sum=viewer.formatNumber(100*kunden.anrufeServicelevel/kunden.anrufe,1)+"%";
    	break;
    case DATA_TYPE_CALLS_WAITINGTIME:
    	dist=kunden.anrufeWartezeitSumProIntervall;
    	dist2=kunden.anrufeErfolgProIntervall;
    	sum=viewer.formatTime(Math.round(kunden.anrufeWartezeitSum/kunden.anrufeErfolg));
    	break;
    case DATA_TYPE_CALLS_STAYINGTIME:
    	dist=kunden.anrufeVerweilzeitSumProIntervall;
    	dist2=kunden.anrufeErfolgProIntervall;
    	sum=viewer.formatTime(Math.round(kunden.anrufeVerweilzeitSum/kunden.anrufeErfolg));
    	break;
    case DATA_TYPE_CALLS_CANCELTIME:
    	dist=kunden.anrufeAbbruchzeitSumProIntervall;
    	dist2=kunden.anrufeAbbruchProIntervall;
    	sum=viewer.formatTime(Math.round(kunden.anrufeAbbruchzeitSum/kunden.anrufeAbbruch));
    	break;
    case DATA_TYPE_CLIENTS:
    	dist=viewer.div(kunden.kundenProIntervall,days);
    	sum=viewer.formatNumber(kunden.kunden/days);
    	break;
    case DATA_TYPE_CLIENTS_CONTINUE:
    	dist=viewer.div(kunden.kundenWeiterleitungenProIntervall,days);
    	sum=viewer.formatNumber(kunden.kundenWeiterleitungen/days);
    	break;
    case DATA_TYPE_CLIENTS_RETRIED:
    	dist=viewer.div(kunden.kundenWiederholungenProIntervall,days);
    	sum=viewer.formatNumber(kunden.kundenWiederholungen/days);
    	break;
    case DATA_TYPE_CLIENTS_CANCEL:
    	dist=viewer.div(kunden.kundenAbbruchProIntervall,days);
    	sum=viewer.formatNumber(kunden.kundenAbbruch/days);
    	break;
    case DATA_TYPE_CLIENTS_SUCCESS:
    	dist=viewer.div(kunden.kundenErfolgProIntervall,days);
    	sum=viewer.formatNumber(kunden.kundenErfolg/days);
    	break;
		
    case DATA_TYPE_CLIENTS_CONTINUE_PART:
        dist=kunden.kundenWeiterleitungenProIntervall;
        dist2=kunden.kundenErfolgProIntervall;
        sum=viewer.formatNumber(100*kunden.kundenWeiterleitungen/kunden.kundenErfolg)+"%";
        break;
    case DATA_TYPE_CLIENTS_CANCEL_PART:
        dist=kunden.kundenAbbruchProIntervall;
        dist2=kunden.kundenProIntervall;
        sum=viewer.formatNumber(100*kunden.kundenAbbruch/kunden.kunden)+"%";
        break;
    case DATA_TYPE_CLIENTS_SUCCESS_PART:
        dist=kunden.kundenErfolgProIntervall;
        dist2=kunden.kundenProIntervall;
        sum=viewer.formatNumber(100*kunden.kundenErfolg/kunden.kunden)+"%";
        break;
		
    case DATA_TYPE_CLIENTS_SERVICE_LEVEL:
    	dist=kunden.kundenServicelevelProIntervall;
    	dist2=kunden.kundenErfolgProIntervall;
    	sum=viewer.formatNumber(100*kunden.kundenServicelevel/kunden.kundenErfolg,1)+"%";
    	break;
	case DATA_TYPE_CLIENTS_SERVICE_LEVEL_ALL:
    	dist=kunden.kundenServicelevelProIntervall;
    	dist2=kunden.kundenProIntervall;
    	sum=viewer.formatNumber(100*kunden.kundenServicelevel/kunden.kunden,1)+"%";
    	break;
    case DATA_TYPE_CLIENTS_WAITINGTIME:
    	dist=kunden.kundenWartezeitSumProIntervall;
    	dist2=kunden.kundenErfolgProIntervall;
    	sum=viewer.formatTime(Math.round(kunden.kundenWartezeitSum/kunden.kundenErfolg));
    	break;
    case DATA_TYPE_CLIENTS_STAYINGTIME:
    	dist=kunden.kundenVerweilzeitSumProIntervall;
    	dist2=kunden.kundenErfolgProIntervall;
    	sum=viewer.formatTime(Math.round(kunden.kundenVerweilzeitSum/kunden.kundenErfolg));
    	break;
    case DATA_TYPE_CLIENTS_CANCELTIME:
    	dist=kunden.kundenAbbruchzeitSumProIntervall;
    	dist2=kunden.kundenAbbruchProIntervall;
    	sum=viewer.formatTime(Math.round(kunden.kundenAbbruchzeitSum/kunden.kundenAbbruch));
    	break;
    case DATA_TYPE_RECALLS:
	    dist=viewer.div(kunden.kundenWiederanrufProIntervall,days);
		sum=viewer.formatNumber(kunden.kundenWiederanruf/days);
		break;
    default:
    	dist=null;
    	sum="";
    }
    var col=[];
    for (var i=0;i<48;i++) {
    	var value=(dist==null)?0:dist[i];
    	if (dist2!=null && dist2[i]!=0) value/=dist2[i];
    	var s;
    	switch (dataType) {
		  case DATA_TYPE_CALLS_CONTINUE_PART:
		  case DATA_TYPE_CALLS_CANCEL_PART:
		  case DATA_TYPE_CALLS_SUCCESS_PART:
    	  case DATA_TYPE_CALLS_SERVICE_LEVEL:
		  case DATA_TYPE_CALLS_SERVICE_LEVEL_ALL:
		  case DATA_TYPE_CLIENTS_CONTINUE_PART:
		  case DATA_TYPE_CLIENTS_CANCEL_PART:
		  case DATA_TYPE_CLIENTS_SUCCESS_PART:		  
    	  case DATA_TYPE_CLIENTS_SERVICE_LEVEL:
		  case DATA_TYPE_CLIENTS_SERVICE_LEVEL_ALL:
            s=viewer.formatNumber(100*value,1)+"%";
            break;
    	  case DATA_TYPE_CALLS_WAITINGTIME:
    	  case DATA_TYPE_CLIENTS_WAITINGTIME:
    	  case DATA_TYPE_CALLS_STAYINGTIME:
    	  case DATA_TYPE_CLIENTS_STAYINGTIME:
    	  case DATA_TYPE_CALLS_CANCELTIME:
    	  case DATA_TYPE_CLIENTS_CANCELTIME:
            s=viewer.formatTime(Math.round(value));
            break;
    	  default:
            s=viewer.formatNumber(value);
    	}
    	col.push(s);
    }
    col.push(sum);
    return col;
}

function viewerKundenIntervalTable(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerTable(language,content);

  var sumRow;
  switch (dataType) {
    case DATA_TYPE_CALLS: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CALLS_CONTINUE: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CALLS_RETRIED: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CALLS_CANCEL: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CALLS_SUCCESS: sumRow=language.tr("Statistic.Sum"); break;	
	case DATA_TYPE_CALLS_CONTINUE_PART: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CALLS_CANCEL_PART: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CALLS_SUCCESS_PART: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CALLS_SERVICE_LEVEL: sumRow=language.tr("Statistic.Average"); break;
	case DATA_TYPE_CALLS_SERVICE_LEVEL_ALL: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CALLS_WAITINGTIME: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CALLS_STAYINGTIME: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CALLS_CANCELTIME: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CLIENTS_CONTINUE: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CLIENTS_RETRIED: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CLIENTS_CANCEL: sumRow=language.tr("Statistic.Sum"); break;
    case DATA_TYPE_CLIENTS_SUCCESS: sumRow=language.tr("Statistic.Sum"); break;	
    case DATA_TYPE_CLIENTS_CONTINUE_PART: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS_CANCEL_PART: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS_SUCCESS_PART: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS_SERVICE_LEVEL: sumRow=language.tr("Statistic.Average"); break;
	case DATA_TYPE_CLIENTS_SERVICE_LEVEL_ALL: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS_WAITINGTIME: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS_STAYINGTIME: sumRow=language.tr("Statistic.Average"); break;
    case DATA_TYPE_CLIENTS_CANCELTIME: sumRow=language.tr("Statistic.Average"); break;
	case DATA_TYPE_RECALLS: sumRow=language.tr("Statistic.Sum"); break;
    default: sumRow="";
  }
  var dataRows=[];
  for (var i=0;i<48;i++) dataRows.push(viewer.formatTime(i*1800)+"-"+viewer.formatTime(i*1800+1799));
  dataRows.push(sumRow);
  
  var dataCols=[];
  for (var i=0;i<statistic.kundenProTyp.length;i++) dataCols.push(statistic.kundenProTyp[i].name);
  dataCols.push(language.tr("Statistic.Total"));
  
  var dataContent=[];
  for (var i=0;i<statistic.kundenProTyp.length;i++) dataContent.push(viewerKundenIntervalTableContent(viewer,statistic.kundenProTyp[i],statistic.simDays,dataType));
  dataContent.push(viewerKundenIntervalTableContent(viewer,statistic.kundenGlobal,statistic.simDays,dataType));

  viewer.doneDirect(dataCols,dataRows,viewer.transpose(dataContent));

  return viewer;
}

/* Tortendiagramme */

function viewerKundenPieChart(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerPieChart(language,content);

  var sum=0;
  var k=statistic.kundenGlobal;
  switch (dataType) {
    case DATA_TYPE_FRESH_CALLS:
  	  viewer.setTitle(viewer.tr("SimStatistic.FreshCalls"));
  	  sum=k.kunden;
  	  break;
	case DATA_TYPE_RECALLS_PIE:
      viewer.setTitle(viewer.tr("SimStatistic.RecallingClients"));
  	  sum=k.kundenWiederanruf;
    case DATA_TYPE_CALLS:
  	  viewer.setTitle(viewer.tr("SimStatistic.Calls"));
  	  sum=(k.anrufe-k.anrufeUebertrag);
  	  break;
    case DATA_TYPE_CANCELED_CALLS:
  	  viewer.setTitle(viewer.tr("SimStatistic.CanceledCalls"));
  	  sum=k.anrufeAbbruch;
  	  break;
    case DATA_TYPE_CONTINUED_CALLS:
  	  viewer.setTitle(viewer.tr("SimStatistic.ForwardedCalls"));
  	  sum=k.anrufeWeiterleitungen;
  	  break;
    case DATA_TYPE_RETRIED_CALLS:
  	  viewer.setTitle(viewer.tr("SimStatistic.RetryCalls"));
  	  sum=k.anrufeWiederholungen;
  	  break;
  }

  for (var i=0;i<statistic.kundenProTyp.length;i++) {
  	k=statistic.kundenProTyp[i];
  	var value=0;
  	switch (dataType) {
  	  case DATA_TYPE_FRESH_CALLS: value=k.kunden; break;
	  case DATA_TYPE_RECALLS_PIE: value=k.kundenWiederanruf; break;
  	  case DATA_TYPE_CALLS: value=k.anrufe; break;
  	  case DATA_TYPE_CANCELED_CALLS: value=k.anrufeAbbruch; break;
  	  case DATA_TYPE_CONTINUED_CALLS: value=k.anrufeWeiterleitungen; break;
  	  case DATA_TYPE_RETRIED_CALLS: value=k.anrufeWiederholungen; break;
  	}
	var s=k.name+"\n("+viewer.formatLong(value/statistic.simDays)+", "+viewer.formatNumber(100*value/sum)+"%)";
	viewer.addSegment(s,value);
  }
  
  viewer.done();

  return viewer;
}

/* Liniendiagramme */

function viewerKundenLineChart(language,statistic,content,dataType,nr) {
  var viewer=new CallcenterSimulatorViewerLineChart(language,content);
  var kunden, type;

  if (nr<0) {
  	kunden=statistic.kundenGlobal;
  	type=language.tr("SimStatistic.AllClients");
  } else {
  	kunden=statistic.kundenProTyp[nr];
  	type=kunden.name;
  }

  switch (dataType) {
    case DATA_TYPE_CALLER:
    	viewer.setupDay(viewer.tr("SimStatistic.Caller"),viewer.tr("Statistic.LineChart.CountPerHalfHour"));
    	viewer.addSeries(viewer.tr("SimStatistic.FreshCalls")+" ("+type+")","blue",viewer.div(kunden.kundenProIntervall,statistic.simDays));
		if (kunden.kundenWiederanruf>0) viewer.addSeries(viewer.tr("SimStatistic.RecallingClients")+" ("+type+")","green",viewer.div(kunden.kundenWiederanrufProIntervall,statistic.simDays));
    	viewer.addSeries(viewer.tr("SimStatistic.Calls.Info")+" ("+type+")","red",viewer.div(kunden.anrufeProIntervall,statistic.simDays));
    	viewer.addFillColor((kunden.kundenWiederanruf>0)?2:1);
    	break;

    case DATA_TYPE_CLIENT_WAITINGTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.WaitingTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.kundenWartezeitVerteilung,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_WAITINGTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.WaitingTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.anrufeWartezeitVerteilung,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_STAYINGTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.ResidenceTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.kundenVerweilzeitVerteilung,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_STAYINGTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.ResidenceTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.anrufeVerweilzeitVerteilung,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_WAITINGTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.WaitingTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.kundenWartezeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_WAITINGTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.WaitingTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.anrufeWartezeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_STAYINGTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.ResidenceTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.kundenVerweilzeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_STAYINGTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.ResidenceTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.anrufeVerweilzeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.WaitingAndResidenceTimesDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("Statistic.Period"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","red",viewer.div(kunden.kundenWartezeitVerteilung,statistic.simDays),1200,5);
    	viewer.addSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.kundenVerweilzeitVerteilung,statistic.simDays),1200,5);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.WaitingAndResidenceTimesDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("Statistic.Period"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","red",viewer.div(kunden.anrufeWartezeitVerteilung,statistic.simDays),1200,5);
    	viewer.addSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.anrufeVerweilzeitVerteilung,statistic.simDays),1200,5);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.WaitingAndResidenceTimesDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("Statistic.Period"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","red",viewer.div(kunden.kundenWartezeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.kundenVerweilzeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.WaitingAndResidenceTimesDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("Statistic.Period"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.WaitingTimeDistribution")+" ("+type+")","red",viewer.div(kunden.anrufeWartezeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.ResidenceTimeDistribution")+" ("+type+")","blue",viewer.div(kunden.anrufeVerweilzeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_CANCELTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.CancelTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+type+")","red",viewer.div(kunden.kundenAbbruchzeitVerteilung,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_CANCELTIME_DIST:
    	viewer.setupTime(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.CancelTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addSeriesPart(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+type+")","red",viewer.div(kunden.anrufeAbbruchzeitVerteilung,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.CancelTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+type+")","red",viewer.div(kunden.kundenAbbruchzeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CALLER_CANCELTIME_DIST_LONG:
    	viewer.setupLongTime(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.CancelTime"),viewer.tr("Statistic.Frequency"));
    	viewer.addLongSeriesPart(viewer.tr("SimStatistic.CancelTimeDistribution")+" ("+type+")","red",viewer.div(kunden.anrufeAbbruchzeitVerteilungLang,statistic.simDays),1200,5);
    	viewer.addFillColor(0);
    	viewer.smartZoom(10);
    	break;

    case DATA_TYPE_CLIENT_WAITING_AND_CANCEL:
    	viewer.setupDay(viewer.tr("SimStatistic.AverageWaitingAndCancelTimes")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.AverageWaitingTime")+" ("+type+")","blue",viewer.div(kunden.kundenWartezeitSumProIntervall,kunden.kundenProIntervall));
    	viewer.addSeries(viewer.tr("SimStatistic.AverageCancelTime")+" ("+type+")","red",viewer.div(kunden.kundenAbbruchzeitSumProIntervall,kunden.kundenAbbruchProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Caller")+" ("+type+")","black",viewer.div(kunden.kundenProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_CALLER_WAITING_AND_CANCEL:
    	viewer.setupDay(viewer.tr("SimStatistic.AverageWaitingAndCancelTimes")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.AverageWaitingTime")+" ("+type+")","blue",viewer.div(kunden.anrufeWartezeitSumProIntervall,kunden.anrufeProIntervall));
    	viewer.addSeries(viewer.tr("SimStatistic.AverageCancelTime")+" ("+type+")","red",viewer.div(kunden.anrufeAbbruchzeitSumProIntervall,kunden.anrufeAbbruchProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Caller")+" ("+type+")","black",viewer.div(kunden.anrufeProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_CLIENT_SUCCESS:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.Accessibility")+" ("+type+")","blue",viewer.div(kunden.kundenErfolgProIntervall,kunden.kundenProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Caller")+" ("+type+")","black",viewer.div(kunden.kundenProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_CALLER_SUCCESS:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.Accessibility")+" ("+type+")","blue",viewer.div(kunden.anrufeErfolgProIntervall,kunden.anrufeProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Caller")+" ("+type+")","black",viewer.div(kunden.anrufeProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_CLIENT_SERVICE_LEVEL:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnClientBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.ServiceLevel")+" ("+type+")","blue",viewer.div(kunden.kundenServicelevelProIntervall,kunden.kundenErfolgProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Clients")+" ("+type+")","black",viewer.div(kunden.kundenProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_CALLER_SERVICE_LEVEL:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnCallBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.ServiceLevel")+" ("+type+")","blue",viewer.div(kunden.anrufeServicelevelProIntervall,kunden.anrufeErfolgProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Caller")+" ("+type+")","black",viewer.div(kunden.anrufeProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;
		
    case DATA_TYPE_CLIENT_SERVICE_LEVEL_ALL:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnClientBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.AllClients")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.ServiceLevel")+" ("+type+")","blue",viewer.div(kunden.kundenServicelevelProIntervall,kunden.kundenProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Clients")+" ("+type+")","black",viewer.div(kunden.kundenProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_CALLER_SERVICE_LEVEL_ALL:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnCallBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.AllCalls")+")",viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.ArrivalsPerHalfHourInterval"));
    	viewer.addSeries(viewer.tr("SimStatistic.ServiceLevel")+" ("+type+")","blue",viewer.div(kunden.anrufeServicelevelProIntervall,kunden.anrufeProIntervall));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.Caller")+" ("+type+")","black",viewer.div(kunden.anrufeProIntervall,statistic.simDays));
    	viewer.addFillColor(0);
    	break;
  }

  viewer.done();

  return viewer;
}

/* Balkendiagramme */
  
function viewerKundenBarChart(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerBarChart(language,content);
  var div, v,w;

  switch (dataType) {
    case DATA_TYPE_WAITINGTIME_BYCLIENT:
    	viewer.setupBarChart(viewer.tr("SimStatistic.WaitingTimes")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.AverageWaitingTime")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",false);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].kundenWartezeitSum/Math.max(1,statistic.kundenProTyp[i].kundenErfolg),viewer.tr("SimStatistic.WaitingTime"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.kundenWartezeitSum/Math.max(1,statistic.kundenGlobal.kundenErfolg),"Wartezeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"red");
    	viewer.setSeriesPaint(1,"darkred");
		viewer.showLegend(false);
    	break;

    case DATA_TYPE_STAYINGTIME_BYCLIENT:
    	viewer.setupBarChart(viewer.tr("SimStatistic.ResidenceTimes")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.AverageResidenceTime")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",false);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].kundenVerweilzeitSum/Math.max(1,statistic.kundenProTyp[i].kundenErfolg),viewer.tr("SimStatistic.ResidenceTime"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.kundenVerweilzeitSum/Math.max(1,statistic.kundenGlobal.kundenErfolg),"Verweilzeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"darkblue");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_WAITINGANDSTAYINGTIME_BYCLIENT:
    	viewer.setupBarChart(viewer.tr("SimStatistic.WaitingAndResidenceTimes")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.AverageTime")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",false);
    	for (var i=0;i<statistic.kundenProTyp.length;i++) {
          var name=statistic.kundenProTyp[i].name;
          w=statistic.kundenProTyp[i].kundenWartezeitSum/Math.max(1,statistic.kundenProTyp[i].kundenErfolg);
          v=statistic.kundenProTyp[i].kundenVerweilzeitSum/Math.max(1,statistic.kundenProTyp[i].kundenErfolg)-w;
          viewer.addValue(w,viewer.tr("SimStatistic.WaitingTime"),name);
          viewer.addValue(v,viewer.tr("SimStatistic.ResidenceTime"),name);
    	}
    	w=statistic.kundenGlobal.kundenWartezeitSum/Math.max(1,statistic.kundenGlobal.kundenErfolg);
    	v=statistic.kundenGlobal.kundenVerweilzeitSum/Math.max(1,statistic.kundenGlobal.kundenErfolg)-w;
    	viewer.addValue(w,"Wartezeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.addValue(v,"Verweilzeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"red");
    	viewer.setSeriesPaint(1,"blue");
    	viewer.setSeriesPaint(2,"darkred");
    	viewer.setSeriesPaint(3,"darkblue");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_WAITINGTIME_BYCALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.WaitingTimes")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.AverageWaitingTime")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",false);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].anrufeWartezeitSum/Math.max(1,statistic.kundenProTyp[i].anrufeErfolg),viewer.tr("SimStatistic.WaitingTime"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.anrufeWartezeitSum/Math.max(1,statistic.kundenGlobal.anrufeErfolg),"Wartezeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"red");
    	viewer.setSeriesPaint(1,"darkred");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_STAYINGTIME_BYCALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.ResidenceTimes")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.AverageResidenceTime")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",false);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].anrufeVerweilzeitSum/Math.max(1,statistic.kundenProTyp[i].anrufeErfolg),viewer.tr("SimStatistic.ResidenceTime"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.anrufeVerweilzeitSum/Math.max(1,statistic.kundenGlobal.anrufeErfolg),"Verweilzeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"darkblue");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_WAITINGANDSTAYINGTIME_BYCALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.WaitingAndResidenceTimes")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.AverageTime")+" ("+viewer.tr("Statistic.Units.InSeconds")+")",false);
    	for (var i=0;i<statistic.kundenProTyp.length;i++) {
          var name=statistic.kundenProTyp[i].name;
          w=statistic.kundenProTyp[i].anrufeWartezeitSum/Math.max(1,statistic.kundenProTyp[i].anrufeErfolg);
          v=statistic.kundenProTyp[i].anrufeVerweilzeitSum/Math.max(1,statistic.kundenProTyp[i].anrufeErfolg)-w;
          viewer.addValue(w,viewer.tr("SimStatistic.WaitingTime"),name);
          viewer.addValue(v,viewer.tr("SimStatistic.ResidenceTime"),name);
    	}
    	w=statistic.kundenGlobal.anrufeWartezeitSum/Math.max(1,statistic.kundenGlobal.anrufeErfolg);
    	v=statistic.kundenGlobal.anrufeVerweilzeitSum/Math.max(1,statistic.kundenGlobal.anrufeErfolg)-w;
    	viewer.addValue(w,"Wartezeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.addValue(v,"Verweilzeit-alle",language.tr("SimStatistic.AllClients"));
		viewer.setSeriesPaint(0,"red");
    	viewer.setSeriesPaint(1,"blue");
    	viewer.setSeriesPaint(2,"darkred");
    	viewer.setSeriesPaint(3,"darkblue");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_SUCCESS_BYCLIENT:
    	viewer.setupBarChart(viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnClientBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.SuccessfulClients"),true);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].kundenErfolg/Math.max(1,statistic.kundenProTyp[i].kunden+statistic.kundenProTyp[i].kundenWiederanruf),viewer.tr("SimStatistic.Accessibility"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.kundenErfolg/Math.max(1,statistic.kundenGlobal.kunden+statistic.kundenGlobal.kundenWiederanruf),"Erreichbarkeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"red");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_SERVICELEVEL_BYCLIENT:
    	viewer.setupBarChart(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnClientBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.ServiceLevel"),true);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].kundenServicelevel/Math.max(1,statistic.kundenProTyp[i].kundenErfolg),viewer.tr("SimStatistic.ServiceLevel"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.kundenServicelevel/Math.max(1,statistic.kundenGlobal.kundenErfolg),"Service-Level-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"red");
    	viewer.showLegend(false);
    	break;
		
  case DATA_TYPE_SERVICELEVEL_BYCLIENT_ALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnClientBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.AllClients")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.ServiceLevel"),true);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].kundenServicelevel/Math.max(1,statistic.kundenProTyp[i].kunden),viewer.tr("SimStatistic.ServiceLevel"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.kundenServicelevel/Math.max(1,statistic.kundenGlobal.kunden),"Service-Level-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"red");
    	viewer.showLegend(false);
    	break;		

    case DATA_TYPE_SUCCESS_BYCALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.Accessibility")+" ("+viewer.tr("SimStatistic.OnCallBasis")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.SuccessfulCalls"),true);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].anrufeErfolg/Math.max(1,statistic.kundenProTyp[i].anrufe),viewer.tr("SimStatistic.Accessibility"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.anrufeErfolg/Math.max(1,statistic.kundenGlobal.anrufe),"Erreichbarkeit-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"red");
    	viewer.showLegend(false);
    	break;

    case DATA_TYPE_SERVICELEVEL_BYCALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnCallBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.ServiceLevel"),true);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].anrufeServicelevel/Math.max(1,statistic.kundenProTyp[i].anrufeErfolg),viewer.tr("SimStatistic.ServiceLevel"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.anrufeServicelevel/Math.max(1,statistic.kundenGlobal.anrufeErfolg),"Service-Level-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"red");
    	viewer.showLegend(false);
    	break;
		
    case DATA_TYPE_SERVICELEVEL_BYCALL_ALL:
    	viewer.setupBarChart(viewer.tr("SimStatistic.ServiceLevel")+" ("+viewer.tr("SimStatistic.OnCallBasis")+", "+viewer.tr("SimStatistic.CalculatedOn.AllCalls")+")",viewer.tr("SimStatistic.ClientTypes"),viewer.tr("SimStatistic.ServiceLevel"),true);
    	for (var i=0;i<statistic.kundenProTyp.length;i++)
          viewer.addValue(statistic.kundenProTyp[i].anrufeServicelevel/Math.max(1,statistic.kundenProTyp[i].anrufe),viewer.tr("SimStatistic.ServiceLevel"),statistic.kundenProTyp[i].name);
    	viewer.addValue(statistic.kundenGlobal.anrufeServicelevel/Math.max(1,statistic.kundenGlobal.anrufe),"Service-Level-alle",language.tr("SimStatistic.AllClients"));
    	viewer.setSeriesPaint(0,"blue");
    	viewer.setSeriesPaint(1,"red");
    	viewer.showLegend(false);
    	break;
  }
  
  viewer.done();

  return viewer;
}
/*
(c) Alexander Herzog
*/

'use strict';

var SORT_BY_CALLCENTER=0;
var SORT_BY_SKILL_LEVEL=1;
var DATA_TYPE_AUSLASTUNG=2;
var DATA_TYPE_AUSLASTUNG_DETAILS=3;
var DATA_TYPE_CALLS=4;
var DATA_TYPE_SKILL_LEVEL_DETAILS=5;
var DATA_TYPE_BEREITZEIT=6;
var DATA_MODEL_SIM_AGENTS=7;
var DATA_MODEL_MODEL_AGENTS=8;
var DATA_MODEL_FULL_AGENTS=9;

var DATA_TYPE_ALL=10;
var DATA_TYPE_ALL_FULL=11;
var DATA_TYPE_CALLCENTER=12;
var DATA_TYPE_CALLCENTER_FULL=13;
var DATA_TYPE_SKILL_LEVEL=14;
var DATA_TYPE_SKILL_LEVEL_FULL=15;

var DATA_TYPE_SERVICETIMEPART=16;
var DATA_TYPE_SERVICETIMEPART_FULL=17;
var DATA_TYPE_FREETIME=18;

var DATA_TYPE_WORKING_TIME=19;
var DATA_TYPE_WORKING_TIME_BY_SKILL=20;

var DATA_TYPE_QUEUE=21;

/* Texte */

function viewerAgentenTextData(viewer,agenten,days) {
  if (agenten.name=="" && agenten.type=="") viewer.addHeading(2,viewer.tr("SimStatistic.AllActiveAgents")); else {
    if (agenten.name=="") viewer.addHeading(2,agenten.type); else viewer.addHeading(2,agenten.name);
  }

  viewer.beginParagraph();
  viewer.addLine(1,viewer.tr("SimStatistic.Count")+": "+viewer.formatLong(agenten.anzahlAgenten));
  viewer.endParagraph();

  var sum=agenten.leerlaufGesamt+agenten.technischerLeerlaufGesamt+agenten.arbeitGesamt+agenten.postProcessingGesamt;
  viewer.beginParagraph();
  viewer.addLine(1,viewer.tr("SimStatistic.NumberOfConversations"),agenten.anrufe,days);
  viewer.addPercentTime(1,viewer.tr("SimStatistic.IdleTime"),agenten.leerlaufGesamt,days*agenten.anzahlAgenten,sum);
  viewer.addPercentTime(1,viewer.tr("SimStatistic.TechnicalFreeTime"),agenten.technischerLeerlaufGesamt,days*agenten.anzahlAgenten,sum);
  viewer.addPercentTime(1,viewer.tr("SimStatistic.HoldingTime"),agenten.arbeitGesamt,days*agenten.anzahlAgenten,sum);
  viewer.addPercentTime(1,viewer.tr("SimStatistic.PostProcessingTime"),agenten.postProcessingGesamt,days*agenten.anzahlAgenten,sum);
  viewer.endParagraph();
  
  viewer.beginParagraph();  
  var brutto=agenten.brutto/days;
  var netto=agenten.netto/days;
  if (Math.abs(brutto-netto)<0.1) {
    viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.Scheduled")+": "+viewer.formatNumber(brutto/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
  } else {
    viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.ScheduledBrutto")+": "+viewer.formatNumber(brutto/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
    viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.ScheduledNetto")+": "+viewer.formatNumber(netto/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));
  }
  viewer.addLine(1,viewer.tr("SimStatistic.AgentsWorkingHours.Worked")+": "+viewer.formatNumber(sum/days/3600)+" "+viewer.tr("Statistic.Units.Hours.lower"));  
  viewer.endParagraph();

  for (var i=0;i<agenten.dataByCaller.length;i++) {
    if (agenten.dataByCallerTechnial[i]+agenten.dataByCallerService[i]+agenten.dataByCallerPostProcessing[i]==0) continue;
    viewer.addHeading(3,viewer.tr("SimStatistic.AgentConversations").format(agenten.dataByCaller[i]));
    viewer.beginParagraph();
	viewer.addLine(2,viewer.tr("SimStatistic.NumberOfConversations"),agenten.dataByCallerAnrufe[i],days);
    viewer.addPercentTime(2,viewer.tr("Statistic.Total"),agenten.dataByCallerTechnial[i]+agenten.dataByCallerService[i]+agenten.dataByCallerPostProcessing[i],days*agenten.anzahlAgenten,sum);
    viewer.addPercentTime(2,viewer.tr("SimStatistic.TechnicalFreeTime"),agenten.dataByCallerTechnial[i],days*agenten.anzahlAgenten,sum);
    viewer.addPercentTime(2,viewer.tr("SimStatistic.HoldingTime"),agenten.dataByCallerService[i],days*agenten.anzahlAgenten,sum);
    viewer.addPercentTime(2,viewer.tr("SimStatistic.PostProcessingTime"),agenten.dataByCallerPostProcessing[i],days*agenten.anzahlAgenten,sum);
    viewer.endParagraph();
  }
}

function viewerAgentenText(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerText(language,content);

  viewer.addHeading(1,viewer.tr("SimStatistic.AgentsWorkLoad"));

  viewerAgentenTextData(viewer,statistic.agentenGlobal,statistic.simDays);
  switch (dataType) {
    case SORT_BY_CALLCENTER:
      if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++)
        viewerAgentenTextData(viewer,statistic.agentenProCallcenter[i],statistic.simDays);
      break;
    case SORT_BY_SKILL_LEVEL:
      if (statistic.agentenProSkilllevel.length>1) for (var i=0;i<statistic.agentenProSkilllevel.length;i++)
        viewerAgentenTextData(viewer,statistic.agentenProSkilllevel[i],statistic.simDays);
      break;
    }  
  
  viewer.done();

  return viewer;
}

/* Tabellen */

function viewerAgentenTableRow(viewer,agenten,days) {
  var line=[];

  var sum=agenten.leerlaufGesamt+agenten.technischerLeerlaufGesamt+agenten.arbeitGesamt+agenten.postProcessingGesamt;

  line.push(viewer.addCell(agenten.anzahlAgenten,1));
  line.push(viewer.addCell(agenten.anrufe,days));
  viewer.addTimeAndPercent(line,agenten.leerlaufGesamt,agenten.anzahlAgenten*days,sum);
  viewer.addTimeAndPercent(line,agenten.technischerLeerlaufGesamt,agenten.anzahlAgenten*days,sum);
  viewer.addTimeAndPercent(line,agenten.arbeitGesamt,agenten.anzahlAgenten*days,sum);
  viewer.addTimeAndPercent(line,agenten.postProcessingGesamt,agenten.anzahlAgenten*days,sum);

  for (var i=0;i<agenten.dataByCaller.length;i++) {
    var subsum=agenten.dataByCallerTechnial[i]+agenten.dataByCallerService[i]+agenten.dataByCallerPostProcessing[i];
	line.push(viewer.addCell(agenten.dataByCallerAnrufe[i],days));
    viewer.addTimeAndPercent(line,subsum,agenten.anzahlAgenten*days,sum);
    viewer.addTimeAndPercent(line,agenten.dataByCallerTechnial[i],agenten.anzahlAgenten*days,sum);
    viewer.addTimeAndPercent(line,agenten.dataByCallerService[i],agenten.anzahlAgenten*days,sum);
    viewer.addTimeAndPercent(line,agenten.dataByCallerPostProcessing[i],agenten.anzahlAgenten*days,sum);
  }

  return line;
}

function viewerAgentenTable(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerTable(language,content);
  
  var dataRows=[
    viewer.tr("SimStatistic.Count"),
	viewer.tr("SimStatistic.NumberOfConversations"),
    viewer.tr("SimStatistic.IdleTime"),viewer.tr("SimStatistic.IdleTime"),
    viewer.tr("SimStatistic.TechnicalFreeTime"),viewer.tr("SimStatistic.TechnicalFreeTime"),
    viewer.tr("SimStatistic.HoldingTime"),viewer.tr("SimStatistic.HoldingTime"),
    viewer.tr("SimStatistic.PostProcessingTime"),viewer.tr("SimStatistic.PostProcessingTime")
  ];
  for (var i=0;i<statistic.agentenGlobal.dataByCaller.length;i++) {
    var s=statistic.agentenGlobal.dataByCaller[i];
	dataRows.push(viewer.tr("SimStatistic.NumberOfConversationsWith").format(s));
    dataRows.push(viewer.tr("SimStatistic.CompleteZimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.CompleteZimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.TechnicalFreeTimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.TechnicalFreeTimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.HoldingTimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.HoldingTimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.PostProcessingTimeFor").format(s));
    dataRows.push(viewer.tr("SimStatistic.PostProcessingTimeFor").format(s));
  }
  
  var dataCols=[];
  switch (dataType) {
    case SORT_BY_CALLCENTER:
      for (var i=0;i<statistic.agentenProCallcenter.length;i++) dataCols.push(statistic.agentenProCallcenter[i].name);
      dataCols.push(viewer.tr("SimStatistic.AllCallcenter"));
      break;
    case SORT_BY_SKILL_LEVEL:
      for (var i=0;i<statistic.agentenProSkilllevel.length;i++) dataCols.push(statistic.agentenProSkilllevel[i].name);
      dataCols.push(viewer.tr("SimStatistic.AllAgents"));
      break;
   }
   
  var dataContent=[];
  switch (dataType) {
    case SORT_BY_CALLCENTER:
      for (var i=0;i<statistic.agentenProCallcenter.length;i++) dataContent.push(viewerAgentenTableRow(viewer,statistic.agentenProCallcenter[i],statistic.simDays));
      break;
    case SORT_BY_SKILL_LEVEL:
      for (var i=0;i<statistic.agentenProSkilllevel.length;i++) dataContent.push(viewerAgentenTableRow(viewer,statistic.agentenProSkilllevel[i],statistic.simDays));
      break;
  }
  dataContent.push(viewerAgentenTableRow(viewer,statistic.agentenGlobal,statistic.simDays));
  
  viewer.doneDirect(dataCols,dataRows,viewer.transpose(dataContent));

  return viewer;
}

/* Tabellen (auf Intervallbasis) */

function viewerAgentenIntervalTableCol(viewer,agenten,days,dataType) {
  var col=[];

  switch (dataType) {
    case DATA_TYPE_AUSLASTUNG:
      var dist=agenten.leerlaufProIntervall;
      var dist1=agenten.technischerLeerlaufProIntervall;
      var dist2=agenten.arbeitProIntervall;
      var dist3=agenten.postProcessingProIntervall;
      for (var i=0;i<48;i++) {
        var value=1-dist[i]/(dist[i]+dist1[i]+dist2[i]+dist3[i]);
        col.push(viewer.formatNumber(100*value)+"%");
      }
      var value1=1-agenten.leerlaufGesamt/(agenten.leerlaufGesamt+agenten.technischerLeerlaufGesamt+agenten.arbeitGesamt+agenten.postProcessingGesamt);
      col.push(viewer.formatNumber(100*value1)+"%");
    break;
  case DATA_TYPE_CALLS:
    var sum=0;
    var d=agenten.anrufeProIntervall;
    for (var i=0;i<48;i++) {sum+=(d[i]/days); col.push(viewer.formatNumber(d[i]/days));}
    col.push(viewer.formatNumber(sum));
    break;
  case DATA_TYPE_BEREITZEIT:
    var sum=0;
    var d=agenten.leerlaufProIntervall;
    for (var i=0;i<48;i++) {sum+=(d[i]/days); col.push(viewer.formatTime(Math.round(d[i]/days)));}
    col.push(viewer.formatTime(sum));
    break;
  }

  return col;
}

function viewerAgentenIntervalDetailTableCol(viewer,agenten,days,dataType,colNr) {
  var col=[];

  switch (dataType) {
    case DATA_TYPE_AUSLASTUNG_DETAILS:
	case DATA_TYPE_SKILL_LEVEL_DETAILS:
      var dist;
      switch (colNr) {
        case 0: dist=agenten.leerlaufProIntervall; break;
        case 1: dist=agenten.technischerLeerlaufProIntervall; break;
        case 2: dist=agenten.arbeitProIntervall; break;
        case 3: dist=agenten.postProcessingProIntervall; break;
      }
	  var sum=0;
	  for (var i=0;i<48;i++) {
	    col.push(viewer.formatTime(Math.round(dist[i]/days),0));
	    sum+=dist[i];
	  }
	  col.push(viewer.formatTime(Math.round(sum/days),0));
      break;
  }

  return col;
}

function viewerAgentenIntervalTableModelCol(viewer,agents,dataType) {
  var col=[];

  switch (dataType) {
    case DATA_MODEL_SIM_AGENTS:
      for (var i=0;i<48;i++) col.push(viewer.formatNumber(agents.simAgents[i]));
      break;
    case DATA_MODEL_MODEL_AGENTS:
      for (var i=0;i<48;i++) col.push(viewer.formatNumber(agents.modelAgents[i]));
      break;
    case DATA_MODEL_FULL_AGENTS:
      for (var i=0;i<48;i++) col.push(viewer.formatNumber(agents.fullAgents[i]));
      break;
  }

  return col;
}

function viewerQueueTableCol(viewer,statistic) {
  var col=[];
  
  for (var i=0;i<48;i++) col.push(viewer.formatNumber(statistic.meanQueueLengthProIntervall[i]));
  col.push(viewer.formatNumber(statistic.meanQueueLength));

  return col;
}

function viewerAgentenIntervalTableCols(viewer,dataType,statistic) {
  var cols=[];
  
  switch (dataType) {
    case DATA_TYPE_AUSLASTUNG:
    case DATA_TYPE_CALLS:
    case DATA_TYPE_BEREITZEIT:
      for (var i=0;i<statistic.agentenProCallcenter.length;i++) cols.push(statistic.agentenProCallcenter[i].name);
	  cols.push(viewer.tr("Statistic.Total"));
	  break;
    case DATA_TYPE_AUSLASTUNG_DETAILS:
      for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
        cols.push(viewer.tr("SimStatistic.IdleTime")+" ("+statistic.agentenProCallcenter[i].name+")");
        cols.push(viewer.tr("SimStatistic.TechnicalFreeTime")+" ("+statistic.agentenProCallcenter[i].name+")");
        cols.push(viewer.tr("SimStatistic.HoldingTime")+" ("+statistic.agentenProCallcenter[i].name+")");
        cols.push(viewer.tr("SimStatistic.PostProcessingTime")+" ("+statistic.agentenProCallcenter[i].name+")");
      }
      cols.push(viewer.tr("SimStatistic.IdleTime")+" ("+viewer.tr("Statistic.Total")+")");
      cols.push(viewer.tr("SimStatistic.TechnicalFreeTime")+" ("+viewer.tr("Statistic.Total")+")");
      cols.push(viewer.tr("SimStatistic.HoldingTime")+" ("+viewer.tr("Statistic.Total")+")");
      cols.push(viewer.tr("SimStatistic.PostProcessingTime")+" ("+viewer.tr("Statistic.Total")+")");
      break;
  case DATA_TYPE_SKILL_LEVEL_DETAILS:
      for (var i=0;i<statistic.agentenProSkilllevel.length;i++) {
        cols.push(viewer.tr("SimStatistic.IdleTime")+" ("+statistic.agentenProSkilllevel[i].name+")");
        cols.push(viewer.tr("SimStatistic.TechnicalFreeTime")+" ("+statistic.agentenProSkilllevel[i].name+")");
        cols.push(viewer.tr("SimStatistic.HoldingTime")+" ("+statistic.agentenProSkilllevel[i].name+")");
        cols.push(viewer.tr("SimStatistic.PostProcessingTime")+" ("+statistic.agentenProSkilllevel[i].name+")");
      }
      cols.push(viewer.tr("SimStatistic.IdleTime")+" ("+viewer.tr("Statistic.Total")+")");
      cols.push(viewer.tr("SimStatistic.TechnicalFreeTime")+" ("+viewer.tr("Statistic.Total")+")");
      cols.push(viewer.tr("SimStatistic.HoldingTime")+" ("+viewer.tr("Statistic.Total")+")");
      cols.push(viewer.tr("SimStatistic.PostProcessingTime")+" ("+viewer.tr("Statistic.Total")+")");
      break;
    case DATA_MODEL_SIM_AGENTS:
    case DATA_MODEL_MODEL_AGENTS:
    case DATA_MODEL_FULL_AGENTS:
      for (var i=0;i<statistic.agentenModellProGruppe.length;i++) cols.push(statistic.agentenModellProGruppe[i].name);
	  cols.push(viewer.tr("Statistic.Total"));
	  break;
	case DATA_TYPE_QUEUE:
	  cols.push(viewer.tr("Statistic.QueueLength"));
  }

  return cols;
}

function viewerAgentenIntervalTable(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerTable(language,content);
  
  var dataCols=viewerAgentenIntervalTableCols(viewer,dataType,statistic);
  
  var sumRow;
  
  switch (dataType) {
    case DATA_TYPE_AUSLASTUNG: sumRow=viewer.tr("Statistic.Average"); break;
	case DATA_TYPE_AUSLASTUNG_DETAILS: sumRow=viewer.tr("Statistic.Sum"); break;
	case DATA_TYPE_BEREITZEIT: sumRow=viewer.tr("Statistic.Sum"); break;
	case DATA_TYPE_CALLS: sumRow=viewer.tr("Statistic.Sum"); break;	
    case DATA_MODEL_SIM_AGENTS: sumRow=viewer.tr("Statistic.Sum"); break;
    case DATA_MODEL_MODEL_AGENTS: sumRow=viewer.tr("Statistic.Sum"); break;
    case DATA_MODEL_FULL_AGENTS: sumRow=viewer.tr("Statistic.Sum"); break;
    case DATA_TYPE_SKILL_LEVEL_DETAILS: sumRow=viewer.tr("Statistic.Sum"); break;
    case DATA_TYPE_QUEUE: sumRow=viewer.tr("Statistic.Average"); break;
    default: sumRow="";
  }
  var dataRows=[];
  for (var i=0;i<48;i++) dataRows.push(viewer.formatTime(i*1800)+"-"+viewer.formatTime(i*1800+1799));
  dataRows.push(sumRow);

  var dataContent=[];
  for (var i=0;i<dataCols.length;i++) switch (dataType) {
    case DATA_TYPE_AUSLASTUNG:
    case DATA_TYPE_CALLS:
    case DATA_TYPE_BEREITZEIT:	  
      dataContent.push((i<statistic.agentenProCallcenter.length)?viewerAgentenIntervalTableCol(viewer,statistic.agentenProCallcenter[i],statistic.simDays,dataType):viewerAgentenIntervalTableCol(viewer,statistic.agentenGlobal,statistic.simDays,dataType));
      break;
	case DATA_TYPE_AUSLASTUNG_DETAILS:
	  dataContent.push((Math.floor(i/4)<statistic.agentenProCallcenter.length)?viewerAgentenIntervalDetailTableCol(viewer,statistic.agentenProCallcenter[Math.floor(i/4)],statistic.simDays,dataType,i%4):viewerAgentenIntervalDetailTableCol(viewer,statistic.agentenGlobal,statistic.simDays,dataType,i%4));
	  break;
	case DATA_TYPE_SKILL_LEVEL_DETAILS:
	  dataContent.push((Math.floor(i/4)<statistic.agentenProSkilllevel.length)?viewerAgentenIntervalDetailTableCol(viewer,statistic.agentenProSkilllevel[Math.floor(i/4)],statistic.simDays,dataType,i%4):viewerAgentenIntervalDetailTableCol(viewer,statistic.agentenGlobal,statistic.simDays,dataType,i%4));
	  break;
    case DATA_MODEL_SIM_AGENTS:
    case DATA_MODEL_MODEL_AGENTS:
    case DATA_MODEL_FULL_AGENTS:
      dataContent.push((i<statistic.agentenModellProGruppe.length)?viewerAgentenIntervalTableModelCol(viewer,statistic.agentenModellProGruppe[i],dataType):viewerAgentenIntervalTableModelCol(viewer,statistic.agentenModellGlobal,dataType));
      break;
    case DATA_TYPE_QUEUE:
      dataContent.push(viewerQueueTableCol(viewer,statistic));
      break;
  }

  viewer.doneDirect(dataCols,dataRows,viewer.transpose(dataContent));

  return viewer;
}

/* Tortendiagramme */

function viewerAgentenPieChartText(viewer,label,value,count,sum) {
  return label+" ("+viewer.formatTime(Math.round(value/count))+", "+viewer.formatNumber(100*value/sum)+"%)";
}

function viewerAgentenPieChartSegment(viewer,label,value,count,sum,color) {
  var s=viewerAgentenPieChartText(viewer,label,value,count,sum);
  viewer.addSegment(s,value,color);
}
	
function viewerAgentenPieChartBuildPie(viewer,agenten,days) {
  var sum=agenten.leerlaufGesamt+agenten.technischerLeerlaufGesamt+agenten.arbeitGesamt+agenten.postProcessingGesamt;
  var count=agenten.anzahlAgenten*days;
  
  viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.IdleTime"),agenten.leerlaufGesamt,count,sum,"#EEE");
  viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.TechnicalFreeTime"),agenten.technischerLeerlaufGesamt,count,sum,"blue");
  viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.HoldingTime"),agenten.arbeitGesamt,count,sum,"red");
  viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.PostProcessingTime"),agenten.postProcessingGesamt,count,sum,"green");
}

function viewerAgentenPieChartBuildFullPie(viewer,agenten,days) {
  var sum=agenten.leerlaufGesamt+agenten.technischerLeerlaufGesamt+agenten.arbeitGesamt+agenten.postProcessingGesamt;
  var count=agenten.anzahlAgenten*days;

  var colorsLight=["LightBlue","LightCoral","LightGreen","LightCyan","Thistle","Coral"];
  var colors=["blue","red","green","cyan","magenta","orange"];
  var colorsDark=["DarkBlue","DarkRed","DarkGreen","DarkCyan","DarkMagenta","DarkOrange"];

  var nr=0;
  viewer.addSegment(viewerAgentenPieChartText(viewer,viewer.tr("SimStatistic.IdleTime"),agenten.leerlaufGesamt,count,sum),agenten.leerlaufGesamt,"#EEE");
  for (var i=0;i<agenten.dataByCaller.length;i++) {
    if (agenten.dataByCallerTechnial[i]+agenten.dataByCallerService[i]+agenten.dataByCallerPostProcessing[i]==0) continue;
    var name=agenten.dataByCaller[i];
    var c1=colorsLight[nr%colors.length];
	var c2=colors[nr%colors.length];
	var c3=colorsDark[nr%colors.length];
    nr++;
    viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.TechnicalFreeTime")+" ("+name+")",agenten.dataByCallerTechnial[i],count,sum,c1);
    viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.HoldingTime")+" ("+name+")",agenten.dataByCallerService[i],count,sum,c2);
    viewerAgentenPieChartSegment(viewer,viewer.tr("SimStatistic.PostProcessingTime")+" ("+name+")",agenten.dataByCallerPostProcessing[i],count,sum,c3);
  }
}

function viewerAgentenPieChart(language,statistic,content,dataType,nr) {
  var viewer=new CallcenterSimulatorViewerPieChart(language,content);

  switch (dataType) {
    case DATA_TYPE_ALL:
      viewer.setTitle(viewer.tr("SimStatistic.AgentsWorkLoad"));
      viewerAgentenPieChartBuildPie(viewer,statistic.agentenGlobal,statistic.simDays);
      break;
    case DATA_TYPE_ALL_FULL:
      viewer.setTitle(viewer.tr("SimStatistic.AgentsWorkLoad"));
      viewerAgentenPieChartBuildFullPie(viewer,statistic.agentenGlobal,statistic.simDays);
      break;
    case DATA_TYPE_CALLCENTER:
      viewer.setTitle(viewer.tr("SimStatistic.AgentsWorkLoad.Callcenter").format(statistic.agentenProCallcenter[nr].name));
      viewerAgentenPieChartBuildPie(viewer,statistic.agentenProCallcenter[nr],statistic.simDays);
      break;
    case DATA_TYPE_CALLCENTER_FULL:
      viewer.setTitle(viewer.tr("SimStatistic.AgentsWorkLoad.Callcenter").format(statistic.agentenProCallcenter[nr].name));
      viewerAgentenPieChartBuildFullPie(viewer,statistic.agentenProCallcenter[nr],statistic.simDays);
      break;
    case DATA_TYPE_SKILL_LEVEL:
      viewer.setTitle(viewer.tr("SimStatistic.AgentsWorkLoad.SkillLevel").format(statistic.agentenProSkilllevel[nr].name));
      viewerAgentenPieChartBuildPie(viewer,statistic.agentenProSkilllevel[nr],statistic.simDays);
      break;
    case DATA_TYPE_SKILL_LEVEL_FULL:
      viewer.setTitle(viewer.tr("SimStatistic.AgentsWorkLoad.SkillLevel").format(statistic.agentenProSkilllevel[nr].name));
      viewerAgentenPieChartBuildFullPie(viewer,statistic.agentenProSkilllevel[nr],statistic.simDays);
      break;
  }

  viewer.done();

  return viewer;
}

/* Liniendiagramme */

function createAgent(template,begin,end) {
  var agent={};
  agent.count=1;
  agent.active=true;
  agent.workingTimeStart=begin*1800;
  agent.workingTimeEnd=end*1800+1800;
  agent.workingNoEndTime=false;
  agent.skillLevel=template.skillLevel;
  agent.costPerWorkingHour=template.costPerWorkingHour;
  agent.costCallerTypes=[];
  for (var i=0;i<template.costCallerTypes.length;i++) agent.costCallerTypes.push(template.costCallerTypes[i]);
  agent.costPerCall=[];
  for (var i=0;i<template.costPerCall.length;i++) agent.costPerCall.push(template.costPerCall[i]);
  agent.costPerCallMinute=[];
  for (var i=0;i<template.costPerCallMinute.length;i++) agent.costPerCallMinute.push(template.costPerCallMinute[i]);
  return agent;
}

function calcAgentShiftsInt(agents,preferredShiftLength,callcenter,model) {
  var list=[];

  if (agents.preferredShiftLength>=0) preferredShiftLength=agents.preferredShiftLength;

  /* Wenn die Arbeitszeiten bereits explizit gegeben sind, ist gar keine Schichtplanung ntig. */
  if (agents.count>=0) {list.push(jQuery.extend(true,{},agents)); return list;}

  var workingAgents=[];

  var efficiencyPerInterval=getEfficiency(agents,callcenter,model);

  for (var i=0;i<48;i++) {
    /* Produktivitt ggf. bercksichtigen */
    var c=Math.round(agents.countPerInterval[i]*efficiencyPerInterval[i]);

    /* Feierabend fr die ersten workingAgents.size()-c Agenten */
    while (c<workingAgents.length) {
      list.push(createAgent(agents,workingAgents[0],i-1));
      workingAgents.shift();
    }

    /* Schichtende prfen */
    while (workingAgents.length>0 && i-workingAgents[0]>=preferredShiftLength) {
      list.push(createAgent(agents,workingAgents[0],i-1));
      workingAgents.shift();
    }

    /* Agenten hinzufgen */
    if (c>workingAgents.length) {
      var c2=c-workingAgents.length;
      for (var j=0;j<c2;j++) workingAgents.push(i);
    }
  }

  /* Feierabend fr alle */
  while (workingAgents.length>0) {
    list.push(createAgent(agents,workingAgents[0],47));
    workingAgents.shift();
  }

  /* Agenten zu Gruppen zusammenfassen */
  var i=1;
  while (i<list.length) {
    if (list[i].workingTimeStart==list[i-1].workingTimeStart && list[i].workingTimeEnd==list[i-1].workingTimeEnd) {
      /* Agent i zu i-1 hizufgen; i ndert sich nicht */
      list[i-1].count++;
      list.splice(i,1);
    } else {
      /* Neue Agentengruppe, i erhhen */
      i++;
    }
  }

  return list;
}

function getFreshCallsDistOn48Base(caller) {
  if (caller.freshCallsDist24!=null) {
    var dist48=[];
    for (var i=0;i<24;i++) {dist48.push(caller.freshCallsDist24[i]/2); dist48.push(caller.freshCallsDist24[i]/2);}
    return dist48;
  }
  if (caller.freshCallsDist48!=null) {
    return caller.freshCallsDist48;
  }
  if (caller.freshCallsDist96!=null) {
    var dist48=[];
    for (var i=0;i<48;i++) dist48.push(caller.freshCallsDist96[2*i]+caller.freshCallsDist96[2*i+1]);
	return dist48;
  }
  return null;
}

function calcAgentDistributionFromCallers(viewer,agents,caller) {
  if (agents.count>=0) return null;
  if (agents.count==-1) return agents.countPerInterval;

  var dist=[];
  for (var i=0;i<48;i++) dist.push(0);

  /* Kundenanknfteverteilungen mit korrekter Gewichtung aufaddieren */
  for (var i=0;i<Math.min(agents.byCallers.length,agents.byCallersRate.length);i++) {
    var index=-1;
    for (var j=0;j<caller.length;j++) if (caller[j].name==agents.byCallers[i]) {index=j; break;}
    if (index<0) continue;
    var dist48=getFreshCallsDistOn48Base(caller[index]);
    var temp=viewer.mul(dist48,Math.max(0,agents.byCallersRate[i]));
    dist=viewer.add(dist,temp);
  }

  /* Auf Anzahl an verfgbaren Halbstundenintervallen normieren */
  var result;
  var sum=viewer.sum(dist);
  if (sum>0) {
    dist=viewer.mul(dist,agents.byCallersAvailableHalfhours/sum);
    result=viewer.round(dist);
    sum=viewer.sum(result);
    dist=viewer.max(dist,result);
    while (sum<agents.byCallersAvailableHalfhours) {
      var index=-1;
      var value=0;
      for (var i=0;i<dist.length;i++) {
        var d=dist[i]-Math.floor(dist[i]);
        if (d>value) {value=d; index=i;}
      }
      if (index==-1) break;
      result[index]++;
      dist[index]=result[index];
      sum++;
    }
  } else {
    result=[];
	for (var i=0;i<48;i++) result.push(0);
  }
  return result;
}

function calcAgentShifts(viewer,agents,callcenter,model) {
  var group;
  if (agents.count==-2) {
    group=jQuery.extend(true,{},agents);
    group.countPerInterval=calcAgentDistributionFromCallers(viewer,group,model.caller);
    group.count=-1;
  } else {
    group=agents;
  }

  var preferredShiftLength=model.preferredShiftLength;
  if (group.preferredShiftLength>0) preferredShiftLength=this.preferredShiftLength;

  return calcAgentShiftsInt(group,preferredShiftLength,callcenter,model);
}

function getEfficiency(agenten,callcenter,model) {
  if (agenten.efficiencyPerInterval!=null) return efficiencyPerInterval;
  if (callcenter.efficiencyPerInterval!=null) return callcenter.efficiencyPerInterval;
  return model.efficiencyPerInterval;
}

function viewerAgentenLineChartAgentenProInterval(statistic,viewer,nr) {
  var dist=[];
  for (var i=0;i<48;i++) dist.push(0);

  /* Liste ber alle Callcenter ? */
  if (nr<0) {
    for (var i=0;i<statistic.editModel.callcenter.length;i++) if (statistic.editModel.callcenter[i].active) dist=viewer.add(dist,viewerAgentenLineChartAgentenProInterval(statistic,viewer,i));
    return dist;
  }

  /* Agentenliste aufstellen und ggf. Schichtplne berechnen */

  var editNr=-1, index=-1;
  for (var i=0;i<statistic.editModel.callcenter.length;i++) if (statistic.editModel.callcenter[i].active) {
    index++;
    if (index==nr) {editNr=i; break;}
  }
  var callcenter=statistic.editModel.callcenter[editNr];
  var translatedAgents=[];
  
  for (var i=0;i<callcenter.agents.length;i++) {
    var agents=calcAgentShifts(viewer,callcenter.agents[i],callcenter,statistic.editModel,true);
	for (var j=0;j<agents.length;j++) translatedAgents.push(agents[j]);
  }

  /* Zusammenzhlen */
  for (var i=0;i<48;i++) {
    var count=0;
    for (var j=0;j<translatedAgents.length;j++) {
      var a=translatedAgents[j];
      if (a.workingTimeStart>1800*i+1799) continue;
      if (a.workingTimeEnd<=1800*i+1 && !a.workingNoEndTime) continue;
      count+=a.count;
    }
    dist[i]=count;
  }
  return dist;
}

function viewerAgentenLineChart(language,statistic,content,dataType,nr) {
  var viewer=new CallcenterSimulatorViewerLineChart(language,content);
  var agenten, type;
  var arbeit, gesamt;

  if (typeof nr==='undefined') nr=-1;
  if (nr<0) {
    agenten=statistic.agentenGlobal;
    type=viewer.tr("SimStatistic.AllAgents");
  } else {
    agenten=statistic.agentenProCallcenter[nr];
    type=agenten.name;
  }

  switch (dataType) {
    case DATA_TYPE_SERVICETIMEPART:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.WorkLoad"),viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.Productivity.ActiveAgents"));
    	arbeit=viewer.add(agenten.technischerLeerlaufProIntervall,viewer.add(agenten.arbeitProIntervall,agenten.postProcessingProIntervall));
    	gesamt=viewer.add(arbeit,agenten.leerlaufProIntervall);
    	viewer.addSeries(viewer.tr("SimStatistic.WorkLoad")+" ("+type+")","red",viewer.div(arbeit,gesamt));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.ActiveAgents")+" ("+type+")","black",viewerAgentenLineChartAgentenProInterval(statistic,viewer,nr));
    	viewer.addFillColor(0);
    	break;

    case DATA_TYPE_SERVICETIMEPART_FULL:
    	viewer.setupDayPercent(viewer.tr("SimStatistic.WorkLoad"),viewer.tr("SimStatistic.AveragePerHalfHourInterval"),viewer.tr("SimStatistic.Productivity.ActiveAgents"));
    	var colors=["blue","green","cyan","magenta","orange"];
    	arbeit=viewer.add(agenten.technischerLeerlaufProIntervall,viewer.add(agenten.arbeitProIntervall,agenten.postProcessingProIntervall));
    	gesamt=viewer.add(arbeit,agenten.leerlaufProIntervall);
    	var colorNr=0, count=0;
    	for (var i=0;i<agenten.dataByCaller.length;i++) {
          if (agenten.dataByCallerTechnial[i]+agenten.dataByCallerService[i]+agenten.dataByCallerPostProcessing[i]==0) continue;
		  count++;
          var name=agenten.dataByCaller[i];
          var c=colors[colorNr%colors.length]; colorNr++;
          var teil=viewer.add(agenten.dataByCallerTechnialProIntervall[i],viewer.add(agenten.dataByCallerServiceProIntervall[i],agenten.dataByCallerPostProcessingProIntervall[i]));
          viewer.addSeries(viewer.tr("SimStatistic.WorkLoad")+" ("+type+", "+name+")",c,viewer.div(teil,gesamt));
    	}
    	viewer.addSeries(viewer.tr("SimStatistic.WorkLoad")+" ("+type+")","red",viewer.div(arbeit,gesamt));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.ActiveAgents")+" ("+type+")","black",viewerAgentenLineChartAgentenProInterval(statistic,viewer,nr));
    	viewer.addFillColor(count);
    	break;

    case DATA_TYPE_FREETIME:
    	viewer.setupDay(viewer.tr("SimStatistic.IdleTime"),viewer.tr("SimStatistic.AveragePerHalfHourInterval")+" ("+viewer.tr("Statistic.Units.InMinutes")+")",viewer.tr("SimStatistic.Productivity.ActiveAgents"));
    	viewer.addSeries(viewer.tr("SimStatistic.IdleTime")+" ("+type+")","red",viewer.div(agenten.leerlaufProIntervall,statistic.simDays*60));
    	viewer.addSeriesToSecondSet(viewer.tr("SimStatistic.ActiveAgents")+" ("+type+")","black",viewerAgentenLineChartAgentenProInterval(statistic,viewer,nr));
    	viewer.addFillColor(0);
    	break;
  }
  
  viewer.done();

  return viewer;
}

function viewerQueueLineChart(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerLineChart(language,content);
  
  switch (dataType) {
    case DATA_TYPE_QUEUE:
      viewer.setupDay(viewer.tr("Statistic.QueueLength"),viewer.tr("Statistic.QueueLength"),viewer.tr("Statistic.QueueLength"));
      viewer.addSeries(viewer.tr("Statistic.QueueLength")+" ("+viewer.tr("Statistic.QueueLength.AveragePerHalfHourInterval")+")","red",statistic.meanQueueLengthProIntervall);
      viewer.addFillColor(0);
	  break;
  }
  
  viewer.done();
  
  return viewer;
}

/* Balkendiagramme */
  
function viewerAgentenBarChart(language,statistic,content,dataType) {
  var viewer=new CallcenterSimulatorViewerBarChart(language,content);
  var div;
  
  switch (dataType) {
    case DATA_TYPE_WORKING_TIME:
      viewer.setupBarChart(viewer.tr("SimStatistic.AgentWorkingTimes"),viewer.tr("SimStatistic.AgentGroups"),viewer.tr("SimStatistic.Time")+" ("+viewer.tr("Statistic.Units.InMinutes")+")",false);
      div=statistic.simDays*60;
      for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
      	var a=statistic.agentenProCallcenter[i];
      	viewer.addValue(a.postProcessingGesamt/div,viewer.tr("SimStatistic.PostProcessingTime"),a.name);
      	viewer.addValue(a.arbeitGesamt/div,viewer.tr("SimStatistic.HoldingTime"),a.name);
      	viewer.addValue(a.technischerLeerlaufGesamt/div,viewer.tr("SimStatistic.TechnicalFreeTime"),a.name);
      	viewer.addValue(a.leerlaufGesamt/div,viewer.tr("SimStatistic.IdleTime"),a.name);
      }
      viewer.setSeriesPaint(0,"green");
      viewer.setSeriesPaint(1,"red");
      viewer.setSeriesPaint(2,"blue");
      viewer.setSeriesPaint(3,"#DDD");
      break;

    case DATA_TYPE_WORKING_TIME_BY_SKILL:
      viewer.setupBarChart(viewer.tr("SimStatistic.AgentWorkingTimes"),viewer.tr("SimStatistic.AgentGroups"),viewer.tr("SimStatistic.Time")+" ("+viewer.tr("Statistic.Units.InMinutes")+")",false);
      div=statistic.simDays*60;
      for (var i=0;i<statistic.agentenProSkilllevel.length;i++) {
      	var a=statistic.agentenProSkilllevel[i];
      	viewer.addValue(a.postProcessingGesamt/div,viewer.tr("SimStatistic.PostProcessingTime"),a.name);
      	viewer.addValue(a.arbeitGesamt/div,viewer.tr("SimStatistic.HoldingTime"),a.name);
      	viewer.addValue(a.technischerLeerlaufGesamt/div,viewer.tr("SimStatistic.TechnicalFreeTime"),a.name);
      	viewer.addValue(a.leerlaufGesamt/div,viewer.tr("SimStatistic.IdleTime"),a.name);
      }
      viewer.setSeriesPaint(0,"green");
      viewer.setSeriesPaint(1,"red");
      viewer.setSeriesPaint(2,"blue");
      viewer.setSeriesPaint(3,"#DDD");
      break;
  }
  
  viewer.done();

  return viewer;
}
/*
(c) Alexander Herzog
*/

'use strict';

/* Setup */

function setupViewers(language,statistic) {
  var data=[];
  
  data.push({label: language.tr("SimStatistic.ResultOverview"), type: language.tr("Statistic.Type.Text"), viewer: viewerBaseInformation});
  data.push({label: language.tr("SimStatistic.ModelInformation"), type: language.tr("Statistic.Type.Text"), viewer: viewerModel});
  data.push({label: language.tr("SimStatistic.ConfidenceIntervals"), type: language.tr("Statistic.Type.Text"), viewer: viewerConfidenceInformation});  
  data.push({label: language.tr("SimStatistic.ThresholdsAndRecommendations"), type: language.tr("Statistic.Type.Text"), viewer: viewerThresholds});  
  
  var subKundenPart1=[
	{label: language.tr("SimStatistic.FreshCalls"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS},
	{label: language.tr("SimStatistic.RecallingClients"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_RECALLS},
	{label: language.tr("SimStatistic.Calls"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS},
	{label: language.tr("SimStatistic.ForwardedCalls.Number"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_CONTINUE},
	{label: language.tr("SimStatistic.ForwardedCalls.Part"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_CONTINUE_PART},
	{label: language.tr("SimStatistic.RetryCalls"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_RETRIED}
  ];
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) subKundenPart1.push({label: statistic.kundenProTyp[i].name, type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER, nr: i});
  subKundenPart1.push({label: language.tr("SimStatistic.AllClients.Short"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER, nr: -1});
  
  var subKundenPart2=[
    {label: language.tr("SimStatistic.WaitingTimeDistribution")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CLIENT_WAITINGTIME_DIST},
	{label: language.tr("SimStatistic.WaitingTimeDistribution")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CALLER_WAITINGTIME_DIST},
	{label: language.tr("SimStatistic.WaitingTimeDistribution")+" ["+language.tr("SimStatistic.long")+"] ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CLIENT_WAITINGTIME_DIST_LONG},
	{label: language.tr("SimStatistic.WaitingTimeDistribution")+" ["+language.tr("SimStatistic.long")+"] ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CALLER_WAITINGTIME_DIST_LONG},
	{label: language.tr("SimStatistic.ResidenceTimeDistribution")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CLIENT_STAYINGTIME_DIST},
	{label: language.tr("SimStatistic.ResidenceTimeDistribution")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CALLER_STAYINGTIME_DIST},
	{label: language.tr("SimStatistic.ResidenceTimeDistribution")+" ["+language.tr("SimStatistic.long")+"] ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CLIENT_STAYINGTIME_DIST_LONG},
	{label: language.tr("SimStatistic.ResidenceTimeDistribution")+" ["+language.tr("SimStatistic.long")+"] ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CALLER_STAYINGTIME_DIST_LONG},
  ];
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    subKundenPart2.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST, nr: i});
	subKundenPart2.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST, nr: i});
	subKundenPart2.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnClientBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST_LONG, nr: i});
	subKundenPart2.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnCallBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST_LONG, nr: i});
  }
  subKundenPart2.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST, nr: -1});
  subKundenPart2.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST, nr: -1});
  subKundenPart2.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnClientBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_WAITINGANDSTAYINGTIME_DIST_LONG, nr: -1});
  subKundenPart2.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnCallBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_WAITINGANDSTAYINGTIME_DIST_LONG, nr: -1});
  
  var subKundenPart3=[
	{label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CLIENT_CANCELTIME_DIST},
	{label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CALLER_CANCELTIME_DIST},
	{label: language.tr("SimStatistic.Overview")+" ["+language.tr("SimStatistic.long")+"] ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG},
	{label: language.tr("SimStatistic.Overview")+" ["+language.tr("SimStatistic.long")+"] ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_CALLER_CANCELTIME_DIST_LONG},	  
  ];
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    subKundenPart3.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_CANCELTIME_DIST, nr: i});
	subKundenPart3.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_CANCELTIME_DIST, nr: i});
	subKundenPart3.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnClientBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG, nr: i});
	subKundenPart3.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnCallBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_CANCELTIME_DIST_LONG, nr: i});
  }
  subKundenPart3.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_CANCELTIME_DIST, nr: -1});
  subKundenPart3.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_CANCELTIME_DIST, nr: -1});
  subKundenPart3.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnClientBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_CANCELTIME_DIST_LONG, nr: -1});
  subKundenPart3.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnCallBasis")+") ["+language.tr("SimStatistic.long")+"]", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_CANCELTIME_DIST_LONG, nr: -1});
  
  var subKundenPart4=[
    {label: language.tr("SimStatistic.WaitingTimes")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_WAITINGTIME},
	{label: language.tr("SimStatistic.WaitingTimes")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_WAITINGTIME},
	{label: language.tr("SimStatistic.ResidenceTimes")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_STAYINGTIME},
	{label: language.tr("SimStatistic.ResidenceTimes")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_STAYINGTIME},
	{label: language.tr("SimStatistic.CancelTimes")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_CANCELTIME},
	{label: language.tr("SimStatistic.CancelTimes")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_CANCELTIME},
  ];
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    subKundenPart4.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_WAITING_AND_CANCEL, nr: i});
	subKundenPart4.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_WAITING_AND_CANCEL, nr: i});
  }
  subKundenPart4.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_WAITING_AND_CANCEL, nr: -1});
  subKundenPart4.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_WAITING_AND_CANCEL, nr: -1});
  
  var subKundenPart5=[
    {label: language.tr("SimStatistic.SuccessfulCalls")+" ("+language.tr("SimStatistic.Number")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_SUCCESS},
	{label: language.tr("SimStatistic.SuccessfulCalls")+" ("+language.tr("SimStatistic.Part")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_SUCCESS_PART},
    {label: language.tr("SimStatistic.SuccessfulClients")+" ("+language.tr("SimStatistic.Number")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_SUCCESS},
    {label: language.tr("SimStatistic.SuccessfulClients")+" ("+language.tr("SimStatistic.Part")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_SUCCESS_PART},
    {label: language.tr("SimStatistic.CanceledCalls")+" ("+language.tr("SimStatistic.Number")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_CANCEL},
	{label: language.tr("SimStatistic.CanceledCalls")+" ("+language.tr("SimStatistic.Part")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_CANCEL_PART},
    {label: language.tr("SimStatistic.CanceledCallers")+" ("+language.tr("SimStatistic.Number")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_CANCEL},
    {label: language.tr("SimStatistic.CanceledCallers")+" ("+language.tr("SimStatistic.Part")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_CANCEL_PART}
  ];
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    subKundenPart5.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_SUCCESS, nr: i});
	subKundenPart5.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_SUCCESS, nr: i});
  }
  subKundenPart5.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_SUCCESS, nr: -1});
  subKundenPart5.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_SUCCESS, nr: -1});
  
  var subKundenPart6=[
	  {label: language.tr("SimStatistic.Overview")+" "+language.tr("SimStatistic.OnCallBasis")+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_SERVICE_LEVEL},
	  {label: language.tr("SimStatistic.Overview")+" "+language.tr("SimStatistic.OnClientBasis")+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_SERVICE_LEVEL},
	  {label: language.tr("SimStatistic.Overview")+" "+language.tr("SimStatistic.OnCallBasis")+" ("+language.tr("SimStatistic.CalculatedOn.AllCalls")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CALLS_SERVICE_LEVEL_ALL},
	  {label: language.tr("SimStatistic.Overview")+" "+language.tr("SimStatistic.OnClientBasis")+" ("+language.tr("SimStatistic.CalculatedOn.AllClients")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerKundenIntervalTable, select: DATA_TYPE_CLIENTS_SERVICE_LEVEL_ALL}
  ];
  if (statistic.kundenProTyp.length>1) for (var i=0;i<statistic.kundenProTyp.length;i++) {
    subKundenPart6.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_SERVICE_LEVEL, nr: i});
    subKundenPart6.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_SERVICE_LEVEL, nr: i});
    subKundenPart6.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.CalculatedOn.AllClients")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_SERVICE_LEVEL_ALL, nr: i});
    subKundenPart6.push({label: statistic.kundenProTyp[i].name+" ("+language.tr("SimStatistic.CalculatedOn.AllCalls")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_SERVICE_LEVEL_ALL, nr: i});	
  }
  subKundenPart6.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_SERVICE_LEVEL, nr: -1});
  subKundenPart6.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_SERVICE_LEVEL, nr: -1});
  subKundenPart6.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.CalculatedOn.AllClients")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CLIENT_SERVICE_LEVEL_ALL, nr: -1});
  subKundenPart6.push({label: language.tr("SimStatistic.AllClients.Short")+" ("+language.tr("SimStatistic.CalculatedOn.AllCalls")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerKundenLineChart, select: DATA_TYPE_CALLER_SERVICE_LEVEL_ALL, nr: -1});

  var subKunden=[
    {label: language.tr("SimStatistic.Category.NumberOfCallers"), sub: [
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Text"), viewer: viewerKundenText, select: DATA_TYPE_COUNT},
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_COUNT},
	  {label: language.tr("SimStatistic.PartsPerCallerType"), closed: true, sub: [
		{label: language.tr("SimStatistic.FreshCalls"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerKundenPieChart, select: DATA_TYPE_FRESH_CALLS},
		{label: language.tr("SimStatistic.Calls"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerKundenPieChart, select: DATA_TYPE_CALLS},
		{label: language.tr("SimStatistic.RecallingClients"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerKundenPieChart, select: DATA_TYPE_RECALLS_PIE},
		{label: language.tr("SimStatistic.CanceledCalls"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerKundenPieChart, select: DATA_TYPE_CANCELED_CALLS},
		{label: language.tr("SimStatistic.ForwardedCalls"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerKundenPieChart, select: DATA_TYPE_CONTINUED_CALLS},
		{label: language.tr("SimStatistic.RetryCalls"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerKundenPieChart, select: DATA_TYPE_RETRIED_CALLS}
	  ]}
	]},
	{label: language.tr("SimStatistic.Category.NumberOfCallersOverTheDay"), closed: true, sub: subKundenPart1},
	{label: language.tr("SimStatistic.Category.WaitingTimesPerCallerType"), sub: [
      {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Text"), viewer: viewerKundenText, select: DATA_TYPE_WAITINGTIME},
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_WAITINGTIME},
	  {label: language.tr("SimStatistic.WaitingTime")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_WAITINGTIME_BYCLIENT},
	  {label: language.tr("SimStatistic.WaitingTime")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_WAITINGTIME_BYCALL},
	  {label: language.tr("SimStatistic.ResidenceTime")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_STAYINGTIME_BYCLIENT},
	  {label: language.tr("SimStatistic.ResidenceTime")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_STAYINGTIME_BYCALL},
	  {label: language.tr("SimStatistic.WaitingAndResidenceTimes")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_WAITINGANDSTAYINGTIME_BYCLIENT},
	  {label: language.tr("SimStatistic.WaitingAndResidenceTimes")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_WAITINGANDSTAYINGTIME_BYCALL}
	]},
	{label: language.tr("SimStatistic.Category.WaitingAndResidenceTimesDistribution"), closed: true, sub: subKundenPart2},
	{label: language.tr("SimStatistic.CancelTimeDistribution"), closed: true, sub: subKundenPart3},
	{label: language.tr("SimStatistic.Category.WaitingTimesOverTheDay"), sub: subKundenPart4},
	{label: language.tr("SimStatistic.AccessibilityPerCallerType"), sub: [
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Text"), viewer: viewerKundenText, select: DATA_TYPE_SUCCESS},
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_SUCCESS},
	  {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.OnClientBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_SUCCESS_BYCLIENT},
	  {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.OnCallBasis")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_SUCCESS_BYCALL}
	]},
	{label: language.tr("SimStatistic.Accessibility.OverTheDay"), sub: subKundenPart5},
	{label: language.tr("SimStatistic.ServiceLevelPerCallerType"), sub: [
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Text"), viewer: viewerKundenText, select: DATA_TYPE_SERVICE_LEVEL},
	  {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerKundenTable, select: DATA_TYPE_SERVICE_LEVEL},
      {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulClients")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_SERVICELEVEL_BYCLIENT},
      {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.CalculatedOn.SuccessfulCalls")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_SERVICELEVEL_BYCALL},
      {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.CalculatedOn.AllClients")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_SERVICELEVEL_BYCLIENT_ALL},
      {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.CalculatedOn.AllCalls")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerKundenBarChart, select: DATA_TYPE_SERVICELEVEL_BYCALL_ALL}
	]},
	{label: language.tr("SimStatistic.ServiceLevel.OverTheDay"), sub: subKundenPart6}
  ];
  data.push({label: '<b>'+language.tr("SimStatistic.Clients")+'</b>', sub: subKunden});
  
  var subAgentenPart1=[
	{label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Text"), viewer: viewerAgentenText, select: SORT_BY_CALLCENTER},
	{label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenTable, select: SORT_BY_CALLCENTER},
	{label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerAgentenBarChart, select: DATA_TYPE_WORKING_TIME},
  ];
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
    subAgentenPart1.push({label: statistic.agentenProCallcenter[i].name, type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerAgentenPieChart, select: DATA_TYPE_CALLCENTER, nr: i});
  }
  subAgentenPart1.push({label: language.tr("SimStatistic.AllCallcenter"), type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerAgentenPieChart, select: DATA_TYPE_ALL});
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
    subAgentenPart1.push({label: statistic.agentenProCallcenter[i].name+" ("+language.tr("SimStatistic.Detailed")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerAgentenPieChart, select: DATA_TYPE_CALLCENTER_FULL, nr: i});
  }
  subAgentenPart1.push({label: language.tr("SimStatistic.AllCallcenter")+" ("+language.tr("SimStatistic.Detailed")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerAgentenPieChart, select: DATA_TYPE_ALL_FULL});

  var subAgentenPart2=[
   {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_TYPE_AUSLASTUNG},
   {label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.Detailed")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_TYPE_AUSLASTUNG_DETAILS},
   {label: language.tr("SimStatistic.NumberOfCalls"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_TYPE_CALLS},
  ];
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
    subAgentenPart2.push({label: statistic.agentenProCallcenter[i].name, type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerAgentenLineChart, select: DATA_TYPE_SERVICETIMEPART, nr: i});
  }
  subAgentenPart2.push({label: language.tr("SimStatistic.AllCallcenter"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerAgentenLineChart, select: DATA_TYPE_SERVICETIMEPART});
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
    subAgentenPart2.push({label: statistic.agentenProCallcenter[i].name+" ("+language.tr("SimStatistic.Detailed")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerAgentenLineChart, select: DATA_TYPE_SERVICETIMEPART_FULL, nr: i});
  }
  subAgentenPart2.push({label: language.tr("SimStatistic.AllCallcenter")+" ("+language.tr("SimStatistic.Detailed")+")", type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerAgentenLineChart, select: DATA_TYPE_SERVICETIMEPART_FULL});
  subAgentenPart2.push({label: language.tr("SimStatistic.Queue"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_TYPE_QUEUE});
  subAgentenPart2.push({label: language.tr("SimStatistic.Queue"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerQueueLineChart, select: DATA_TYPE_QUEUE});

  var subAgentenPart3=[
    {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_TYPE_BEREITZEIT},
  ];
  if (statistic.agentenProCallcenter.length>1) for (var i=0;i<statistic.agentenProCallcenter.length;i++) {
    subAgentenPart3.push({label: statistic.agentenProCallcenter[i].name, type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerAgentenLineChart, select: DATA_TYPE_FREETIME, nr: i});
  }
  subAgentenPart3.push({label: language.tr("SimStatistic.AllCallcenter"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerAgentenLineChart, select: DATA_TYPE_FREETIME});

  var subAgentenPart4=[
    {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Text"), viewer: viewerAgentenText, select: SORT_BY_SKILL_LEVEL},
    {label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenTable, select: SORT_BY_SKILL_LEVEL},
	
	{label: language.tr("SimStatistic.Overview")+" ("+language.tr("SimStatistic.Detailed")+")", type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_TYPE_SKILL_LEVEL_DETAILS},
	
	{label: language.tr("SimStatistic.Overview"), type: language.tr("Statistic.Type.Graphics"), type2: "Bar", viewer: viewerAgentenBarChart, select: DATA_TYPE_WORKING_TIME_BY_SKILL},
  ];
  if (statistic.agentenProSkilllevel.length>1) for (var i=0;i<statistic.agentenProSkilllevel.length;i++) {
    subAgentenPart4.push({label: statistic.agentenProSkilllevel[i].name, type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerAgentenPieChart, select: DATA_TYPE_SKILL_LEVEL, nr: i});
  }
  if (statistic.agentenProSkilllevel.length>1) for (var i=0;i<statistic.agentenProSkilllevel.length;i++) {
    subAgentenPart4.push({label: statistic.agentenProSkilllevel[i].name, type: language.tr("Statistic.Type.Graphics"), type2: "Pie", viewer: viewerAgentenPieChart, select: DATA_TYPE_SKILL_LEVEL_FULL, nr: i});
  }

  var subAgenten=[
    {label: language.tr("SimStatistic.Category.WorkLoadPerCallcenter"), sub: subAgentenPart1},
	{label: language.tr("SimStatistic.Category.WorkLoadOverTheDay"), sub: subAgentenPart2},
	{label: language.tr("SimStatistic.Category.IdleTimeOverTheDay"), sub: subAgentenPart3},
	{label: language.tr("SimStatistic.Category.WorkLoadPerSkillLevel"), closed: true, sub: subAgentenPart4}
  ];
  data.push({label: '<b>'+language.tr("SimStatistic.ActiveAgents")+'</b>', sub: subAgenten});
  
  var ver=statistic.editModel.version.split(".");
  if (parseInt(ver[0])*100+parseInt(ver[1])>=300) {
    var subAgenten2=[		
      {label: language.tr("SimStatistic.AgentsOnModelBasis.AgentsInSimulation"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_MODEL_SIM_AGENTS},
      {label: language.tr("SimStatistic.AgentsOnModelBasis.AgentsInModel"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_MODEL_MODEL_AGENTS},		
      {label: language.tr("SimStatistic.AgentsOnModelBasis.AgentsWithAddition"), type: language.tr("Statistic.Type.Table"), viewer: viewerAgentenIntervalTable, select: DATA_MODEL_FULL_AGENTS}
    ];
    data.push({label: '<b>'+language.tr("SimStatistic.AgentsOnModelBasis")+'</b>', sub: subAgenten2});
  }
  
  var subErlangC=[
    {label: language.tr("SimStatistic.ErlangCComparison.Success"), type: language.tr("Statistic.Type.Table"), viewer: viewerErlangCTable, select: ERLANGC_DATA_SUCCESS},
    {label: language.tr("SimStatistic.ErlangCComparison.Success"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerErlangCLineChart, select: ERLANGC_DATA_SUCCESS},
    {label: language.tr("SimStatistic.ErlangCComparison.WaitingTime"), type: language.tr("Statistic.Type.Table"), viewer: viewerErlangCTable, select: ERLANGC_DATA_WAITING_TIME},
    {label: language.tr("SimStatistic.ErlangCComparison.WaitingTime"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerErlangCLineChart, select: ERLANGC_DATA_WAITING_TIME},
    {label: language.tr("SimStatistic.ErlangCComparison.ServiceLevel"), type: language.tr("Statistic.Type.Table"), viewer: viewerErlangCTable, select: ERLANGC_DATA_SERVICE_LEVEL},
    {label: language.tr("SimStatistic.ErlangCComparison.ServiceLevel"), type: language.tr("Statistic.Type.Graphics"), type2: "Line", viewer: viewerErlangCLineChart, select: ERLANGC_DATA_SERVICE_LEVEL}
  ];
  data.push({label: "<b>"+language.tr("SimStatistic.ErlangCComparison")+"</b>", sub: subErlangC});
  
  data.push({label: language.tr("SimStatistic.Costs"), type: language.tr("Statistic.Type.Text"), viewer: viewerCosts});
  data.push({label: language.tr("SimStatistic.SystemData"), type: language.tr("Statistic.Type.Text"), viewer: viewerSystemInformation});
 
  return data;
}
